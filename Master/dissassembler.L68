00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 8/18/2020 8:52:00 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Team 9 Disassembler
00000000                             3  * Written by : Mariana Huynh, Hanny Long, Alex Van Matre
00000000                             4  * Date       : 07/20/20
00000000                             5  * Description: Disassmbles a program that is loaded into
00000000                             6  *              memory
00000000                             7  *-----------------------------------------------------------
00001000                             8                ORG    $1000
00001000                             9  START:                                           ; first instruction of program
00001000  4DF9 00004E18             10      LEA      Values,A6
00001006  4EB9 00004872             11      JSR      Print
0000100C  2279 00004E46             12      MOVE.L   PrintPointer,A1
00001012  13FC 0000 00004E4A        13      MOVE.B   #0,PrintLines
0000101A  4EB9 00004BB6             14      JSR      PrintSpace
00001020                            15  
00001020                            16  * Put program code here
00001020                            17  
00001020                            18  * I/O
00001020  227C 00000000             19               MOVEA.L #0, A1                      ; Clear A1
00001026  43F9 00004BC0             20               LEA IntroMsg, A1
0000102C  103C 000E                 21               MOVE.B #14, D0                      ; print contents of A1
00001030  4E4F                      22               TRAP #15
00001032                            23  
00001032                            24  * Get start address
00001032                            25  GetStartAddr
00001032  43F9 00004C95             26               LEA     AskStartAddr,A1             ; load asking for start address message
00001038  103C 000E                 27               MOVE.B  #14,D0
0000103C  4E4F                      28               TRAP    #15                         ; print to screen
0000103E                            29  
0000103E  227C 00000000             30               MOVEA.L #0,A1                       ; Clear A1
00001044  43F9 00000600             31               LEA     StartAddr,A1                ; Move variable StartAddr for storing
0000104A                            32  
0000104A  103C 0002                 33               MOVE.B  #2,D0                       ; trap task 2: takes in input from keyboard and stores into A1
0000104E  4E4F                      34               TRAP    #15
00001050                            35  
00001050  B27C 0008                 36               CMP     #8,D1                       ; check if input is 8 chars long
00001054  6600 00E4                 37               BNE     InvalidAddrHandler
00001058                            38  
00001058  4242                      39               CLR     D2                          ; clear toggle for if validated start/end address
0000105A                            40  
0000105A  6000 002C                 41               BRA     AsciiToHex                  ; convert input to hex
0000105E                            42  
0000105E                            43  * Get end address
0000105E                            44  GetEndAddr
0000105E  43F9 00004CBE             45               LEA     AskEndAddr,A1               ; load asking for end address message
00001064  103C 000E                 46               MOVE.B  #14,D0
00001068  4E4F                      47               TRAP    #15
0000106A                            48  
0000106A  227C 00000000             49               MOVEA.L #0,A1                       ; Clear A1
00001070  43F9 00000500             50               LEA     EndAddr,A1                  ; move variable EndAddr for storing
00001076                            51  
00001076  103C 0002                 52               MOVE.B  #2,D0                       ; trap task 2: takes in input from keyboard and stores into A1
0000107A  4E4F                      53               TRAP    #15
0000107C                            54  
0000107C  B27C 0008                 55               CMP     #8,D1                       ; Check if the given value was 8 characters long, if not it needs to be given again
00001080  6600 00B8                 56               BNE     InvalidAddrHandler
00001084                            57  
00001084  6000 0002                 58               BRA     AsciiToHex                  ; convert input to hex
00001088                            59  
00001088                            60  * Convert from ASCII to hex
00001088                            61  AsciiToHex
00001088  7600                      62               MOVE.L  #0,D3                       ; initialize D3 to 0
0000108A  7808                      63               MOVE.L  #8,D4                       ; initialize D4 to 8, for number of iterations in for_loop1
0000108C  7A00                      64               MOVE.L  #0,D5                       ; initialize D5 to 0, for storing result of converted input to hex
0000108E                            65  
0000108E                            66  ConvertForLoop
0000108E  B803                      67               CMP.B   D3,D4                       ; for number of iterations
00001090  6700 0056                 68               BEQ     SaveStart                   ; if equal to each other, move on to validate start address
00001094  5283                      69               ADDQ.L  #1,D3                       ; D3++
00001096                            70  
00001096  E985                      71               ASL.L    #4,D5                      ; shift to the left 4 bits (1 hex character)
00001098  1219                      72               MOVE.B  (A1)+,D1                    ; read one char into D1
0000109A                            73  
0000109A  B23C 0030                 74               CMP.B   #$30,D1                     ; check the char, "A-F", "0-9", "a-f"
0000109E  6D00 009A                 75               BLT     InvalidAddrHandler          ; D1 < 0x30
000010A2  B23C 0039                 76               CMP.B   #$39,D1
000010A6  6F00 0022                 77               BLE     ConvertNum                  ; 0x30 (0) <= D1 <= 0x39 (9)  <-- see ASCII chart
000010AA  B23C 0041                 78               CMP.B   #$41,D1
000010AE  6D00 008A                 79               BLT     InvalidAddrHandler          ; 0x39 < D1 < 0x41
000010B2                            80  
000010B2  B23C 0046                 81               CMP.B   #$46,D1
000010B6  6F00 0026                 82               BLE     ConvertUppercase            ; 0x41 (A) <= D1 <= 0x46 (F)
000010BA  B23C 0061                 83               CMP.B   #$61,D1
000010BE  6D00 007A                 84               BLT     InvalidAddrHandler          ; 0x47 < D1 < 0x61
000010C2  B23C 0066                 85               CMP.B   #$66,D1
000010C6  6F00 000C                 86               BLE     ConvertLowercase            ; 0x66 (f) < D1
000010CA                            87  
000010CA                            88  ConvertNum
000010CA  0481 00000030             89               SUB.L   #$30,D1                     ; convert char (0-9) to number
000010D0  DA81                      90               ADD.L   D1,D5
000010D2  60BA                      91               BRA     ConvertForLoop              ; go back and do next character
000010D4                            92  
000010D4                            93  ConvertLowercase
000010D4  0481 00000057             94               SUB.L   #$57,D1                     ; convert char (a-f) to number
000010DA  DA81                      95               ADD.L   D1,D5
000010DC  60B0                      96               BRA     ConvertForLoop              ; go back and do next character
000010DE                            97  
000010DE                            98  ConvertUppercase
000010DE  0481 00000037             99               SUB.L   #$37,D1                     ; convert char (A-F) to number
000010E4  DA81                     100               ADD.L   D1,D5
000010E6  60A6                     101               BRA     ConvertForLoop              ; go back and do next character
000010E8                           102  
000010E8                           103  * Save start and end (and validate end) addresses
000010E8                           104  SaveStart
000010E8  B47C 0001                105               CMP         #1,D2
000010EC  6700 0010                106               BEQ         ValidateEnd             ; if D2 = 1, already validated start address
000010F0  5242                     107               ADDI        #1,D2                   ; if initially 0, add 1 to toggle to ValidateEnd
000010F2                           108  
000010F2  4EB9 00001116            109               JSR         PutStartToMemory        ; move converted starting address from D3 to defined memory location
000010F8  4245                     110               CLR         D5
000010FA  6000 FF62                111               BRA         GetEndAddr              ; ask user for new end address
000010FE                           112  
000010FE                           113  ValidateEnd
000010FE  BAB9 00000600            114               CMP.L       StartAddr,D5            ; check if starting address is less than or equal to ending address
00001104  6F00 0052                115               BLE         InvalidEndHandler       ; if yes, = error (start must be less than end)
00001108                           116  
00001108  4242                     117               CLR.W       D2
0000110A  4EB9 0000111E            118               JSR         PutEndToMemory          ; move ending address in D3 to defined memory location
00001110  4245                     119               CLR.W       D5
00001112                           120  
00001112  6000 0012                121               BRA         LoadAddr
00001116                           122  
00001116                           123  PutStartToMemory
00001116  23C5 00000600            124               MOVE.L      D5,StartAddr
0000111C  4E75                     125               RTS
0000111E                           126  
0000111E                           127  PutEndToMemory
0000111E  23C5 00000500            128               MOVE.L      D5,EndAddr
00001124  4E75                     129               RTS
00001126                           130  
00001126                           131  LoadAddr
00001126  4282                     132               CLR.L       D2
00001128  2479 00000600            133               MOVE.L      StartAddr,A2
0000112E  2679 00000500            134               MOVE.L      EndAddr,A3
00001134  4EB9 00001186            135               JSR         ReadNextLoopStart
0000113A                           136  
0000113A                           137  * Invalid input handlers
0000113A                           138  InvalidAddrHandler
0000113A  B47C 0001                139               CMP         #1,D2                   ; if toggle at D2 = 1 then end address error
0000113E  6700 0018                140               BEQ         InvalidEndHandler
00001142  6000 0002                141               BRA         InvalidStartHandler ; else starting address error
00001146                           142  
00001146                           143  InvalidStartHandler
00001146  227C 00000000            144               MOVEA.L     #0,A1                   ; clear A1
0000114C  4EB9 0000116A            145               JSR         DispInvalidStartError
00001152  4245                     146               CLR         D5
00001154  6000 FEDC                147               BRA         GetStartAddr            ; ask for starting address again
00001158                           148  
00001158                           149  InvalidEndHandler
00001158  227C 00000000            150               MOVEA.L     #0,A1                   ; clear A1
0000115E  4EB9 00001178            151               JSR         DispInvalidEndError
00001164  4245                     152               CLR         D5
00001166  6000 FEF6                153               BRA         GetEndAddr
0000116A                           154  
0000116A                           155  DispInvalidStartError
0000116A  43F9 00004D1B            156               LEA         InvalidStartMessage,A1  ; load error message
00001170  103C 000D                157               MOVE.B      #13,D0                  ; print contents of A1
00001174  4E4F                     158               TRAP        #15
00001176  4E75                     159               RTS
00001178                           160  
00001178                           161  DispInvalidEndError
00001178  43F9 00004D4E            162               LEA         InvalidEndMessage,A1    ; load error message
0000117E  103C 000D                163               MOVE.B      #13,D0                  ; print contents of A1
00001182  4E4F                     164               TRAP        #15
00001184  4E75                     165               RTS
00001186                           166  
00001186                           167  * Opcode Parsing
00001186                           168  ReadNextLoopStart
00001186  284A                     169               MOVE.L      A2,A4
00001188                           170  
00001188                           171  ReadNextLoop
00001188  B9CB                     172               CMPA.L      A3,A4
0000118A  6C00 0018                173               BGE         AskExitOrRestart
0000118E                           174  
0000118E                           175               ;MOVE.B     -(A4),A4
0000118E                           176  
0000118E  4EB9 00004884            177               JSR         PrintLine
00001194                           178  
00001194  4EB9 000048CE            179               JSR         PrintAddr
0000119A                           180  
0000119A  4EB9 0000121E            181               JSR         DecodingMachineCode
000011A0                           182               ;MOVE.W      (A4)+,D7                   ; read one word at a time and store in D7
000011A0  4EF8 1188                183               JMP         ReadNextLoop
000011A4                           184  
000011A4                           185  AskExitOrRestart
000011A4  43F9 00004CE5            186               LEA         AskRestartOrExitMsg,A1 ; ask user to restart or exit program
000011AA  103C 000E                187               MOVE.B      #14,D0
000011AE  4E4F                     188               TRAP        #15
000011B0                           189  
000011B0  103C 0004                190               MOVE.B      #4,D0                  ; trap task #4: get user input (digit)
000011B4  4E4F                     191               TRAP        #15
000011B6                           192  
000011B6  B23C 0001                193               CMP.B       #1,D1                  ; if user inputs 1, restart program
000011BA  6700 000C                194               BEQ         ClearEverything
000011BE  B23C 0000                195               CMP.B       #0,D1                  ; if 0, terminate program
000011C2  66E0                     196               BNE         AskExitOrRestart       ; if not 0 nor 1, prompt again
000011C4  6000 0052                197               BRA         quit
000011C8                           198  
000011C8                           199  ClearEverything
000011C8                           200  * Clear data registers
000011C8  4280                     201               CLR.L       D0
000011CA  4281                     202               CLR.L       D1
000011CC  4282                     203               CLR.L       D2
000011CE  4283                     204               CLR.L       D3
000011D0  4284                     205               CLR.L       D4
000011D2  4285                     206               CLR.L       D5
000011D4  4286                     207               CLR.L       D6
000011D6  4287                     208               CLR.L       D7
000011D8                           209  
000011D8                           210  * Clear address registers
000011D8  207C 00000000            211               MOVEA.L     #0, A0
000011DE  227C 00000000            212               MOVEA.L     #0, A1
000011E4  247C 00000000            213               MOVEA.L     #0, A2
000011EA  267C 00000000            214               MOVEA.L     #0, A3
000011F0  287C 00000000            215               MOVEA.L     #0, A4
000011F6  2A7C 00000000            216               MOVEA.L     #0, A5
000011FC  2C7C 00000000            217               MOVEA.L     #0, A6
00001202  2E7C 00000000            218               MOVEA.L     #0, A7
00001208                           219  
00001208                           220  * Clear memory locations that variables used
00001208  42B9 00000600            221               CLR.L       StartAddr
0000120E  42B9 00000500            222               CLR.L       EndAddr
00001214                           223  
00001214  6000 FDEA                224               BRA         START
00001218                           225  
00001218                           226  quit
00001218  103C 0009                227               MOVE.B      #9, D0
0000121C  4E4F                     228               TRAP        #15
0000121E                           229  
0000121E                           230  *-----------------------------------------------------------
0000121E                           231  * Title      : Opcode decoding
0000121E                           232  * Written by :
0000121E                           233  * Date       :
0000121E                           234  * Description: decoding opcode from machine code by looking at the bit and narrowing down the possibility
0000121E                           235  *-----------------------------------------------------------
0000121E                           236  *******     ASSUME (A4) IS ALREADY is the MACHINE CODE                  ********
0000121E                           237  *******     NOTE: MACHINE CODE ARE WORD SIZE                            ********
0000121E                           238  *******     The code narrow down the opcode posibility by               ********
0000121E                           239  *******     looking at the bit and branch                               ********
0000121E                           240  *******     Using D3,D4 for loop and,D5 result                          ********
0000121E                           241  *******     Using D0, D1 to hold temperary data                         ********
0000121E                           242  *******     POSTCONDITION: (A4) will hold 0 after RTS from this SR      ********
0000121E                           243  *******                    except for if the opcode is NOP or RTS       ********
0000121E                           244  ;Ctrl+F "Print" to see where all the print is
0000121E                           245  ;If nothing work BUG is in GetNextD4bit subroutine or InvalidOpcode subroutine, both is at the bottom of the file
0000121E                           246  
0000121E                           247  DecodingMachineCode
0000121E  4242                     248              CLR     D2
00001220  341C                     249              MOVE.W  (A4)+,D2        ; create copy of data in A4 to fix restart
00001222                           250  
00001222  0C42 4E71                251              CMPI.W  #20081,D2    ; NOP if equal
00001226  6700 38F8                252              BEQ     PrintNOP       ; Call Output PrintNOP subroutine
0000122A                           253              ;RTS                    ; Return to get more input
0000122A                           254  
0000122A  0C42 4E75                255              CMPI.W  #20085,D2    ; RTS if equal
0000122E  6700 3932                256              BEQ     PrintRTS       ; Call Output PrintRTS subroutine
00001232                           257              ;RTS                    ; Return to get more input
00001232                           258  
00001232  7804                     259              MOVE.L  #4,D4          ; get the next 4 bit from (A4) in to D5
00001234  4EB9 00004856            260              JSR     GetNextD4bit   ; D5 hold the first 4 bit of (A4)
0000123A                           261  
0000123A                           262      ; cmp to see whice opcode the frist 4 bit match with
0000123A  BABC 0000000E            263              CMP.L   #14,D5
00001240  6700 0062                264              BEQ     LSL_ASL_Opcode
00001244                           265  
00001244  BABC 0000000D            266              CMP.L   #13,D5
0000124A  6700 0434                267              BEQ     ADD_Opcode
0000124E                           268  
0000124E  BABC 0000000C            269              CMP.L   #12,D5
00001254  6700 0DA2                270              BEQ     MULS_W_AND_Opcode
00001258                           271  
00001258  BABC 00000009            272              CMP.L   #9,D5
0000125E  6700 1814                273              BEQ     SUB_Opcode
00001262                           274  
00001262  BABC 00000008            275              CMP.L   #8,D5
00001268  6700 21A2                276              BEQ     DIVU_W_Opcode
0000126C                           277  
0000126C  BABC 00000006            278              CMP.L   #6,D5
00001272  6700 234A                279              BEQ     Bcc_Opcode
00001276                           280  
00001276  BABC 00000004            281              CMP.L   #4,D5
0000127C  6700 23D8                282              BEQ     NeedMoreBit
00001280                           283  
00001280  BABC 00000003            284              CMP.L   #3,D5
00001286  6700 2F60                285              BEQ     MOVE_W_Opcode
0000128A                           286  
0000128A  BABC 00000002            287              CMP.L   #2,D5
00001290  6700 31DC                288              BEQ     MOVE_L_Opcode
00001294                           289  
00001294  BABC 00000001            290              CMP.L   #1,D5
0000129A  6700 33C2                291              BEQ     MOVE_B_Opcode
0000129E                           292  
0000129E  4EF9 0000484E            293              JMP     InvalidOpcode  ; Call Output NotFound subroutine, since it did not match with any first 4 bit of the opcode
000012A4                           294  
000012A4                           295  
000012A4                           296  *************************************************                LSL_ASL_Opcode                  *************************************************
000012A4                           297  ; first four bit is (1110 #### #### ####)
000012A4                           298  LSL_ASL_Opcode
000012A4  7803                     299              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 11-9) in to D5
000012A6  4EB9 00004856            300              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which is count or register it is
000012AC                           301  
000012AC  2005                     302              MOVE.L  D5,D0          ; D0 will hold the count or register
000012AE                           303         ; D0 will hold the count or register (position 11-9)
000012AE                           304  
000012AE  7801                     305              MOVE.L  #1,D4          ; get the next 1 bit from (A4)(position 8) in to D5
000012B0  4EB9 00004856            306              JSR     GetNextD4bit   ; D5 hold the next 1 bit of (A4), which tell us the direction
000012B6                           307  
000012B6  BABC 00000001            308              CMP.L   #1,D5          ; D5 should be 1 since we are shifting left
000012BC  6600 3590                309              BNE     InvalidOpcode  ; if D5 doesn't equal 1 it is not a valid machine code
000012C0                           310  
000012C0  7802                     311              MOVE.L  #2,D4          ; get the next 2 bit from (A4)(position 7-6) in to D5
000012C2  4EB9 00004856            312              JSR     GetNextD4bit   ; D5 hold the next 2 bit of (A4), which tell us the size
000012C8                           313  
000012C8  BABC 00000003            314              CMP.L   #3,D5          ; if size is 3 then it is a memory shift
000012CE  4EF9 0000147C            315              JMP     MemShift
000012D4                           316  
000012D4  2205                     317              MOVE.L  D5,D1          ; D1 will hold the size
000012D6                           318         ; D1 will hold the size (position 7-6)
000012D6                           319  
000012D6  7803                     320              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
000012D8  4EB9 00004856            321              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us immediate shift count or register shift count
000012DE                           322  
000012DE  BABC 00000000            323              CMP.L   #0,D5          ; D5 is 3 bit from (A4)(position 5-3), if 0 mean it is a ASL by count
000012E4  6700 0026                324              BEQ     ASL_Count_Opcode
000012E8                           325  
000012E8  BABC 00000001            326              CMP.L   #1,D5           ; D5 is 3 bit from (A4)(position 5-3), if 1 mean it is a LSL by count
000012EE  6700 00AC                327              BEQ     LSL_Count_Opcode
000012F2                           328  
000012F2  BABC 00000004            329              CMP.L   #4,D5           ; D5 is 3 bit from (A4)(position 5-3), if 4 mean it is a ASL by Register
000012F8  6700 0142                330              BEQ     ASL_Register_Opcode
000012FC                           331  
000012FC  BABC 00000005            332              CMP.L   #5,D5           ; D5 is 3 bit from (A4)(position 5-3), if 5 mean it is a LSL by Register
00001302  6700 0158                333              BEQ     LSL_Register_Opcode
00001306                           334  
00001306  4EF9 0000484E            335              JMP     InvalidOpcode       ; if it is not invalid because position 5-3 did not match any posibility
0000130C                           336  
0000130C                           337  ASL_Count_Opcode
0000130C  7803                     338              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000130E  4EB9 00004856            339              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
00001314                           340  
00001314  4EB9 0000133C            341              JSR     ASL_Output_Size    ;output ASL and size from D1
0000131A                           342  
0000131A  4EB9 0000142C            343              JSR     CheckCount     ; change D0 to 8 if D0 equal to 0
00001320                           344  
00001320  1E05                     345              MOVE.B  D5,D7
00001322  1A00                     346              MOVE.B  D0,D5
00001324                           347  
00001324  12EE 0029                348              MOVE.B  41(A6),(A1)+             *#
00001328  4EB9 00004A0A            349              JSR     PrintRegNum
0000132E                           350  
0000132E  1A07                     351              MOVE.B  D7,D5
00001330  12EE 0025                352              MOVE.B  37(A6),(A1)+             *,
00001334  4EB9 000049D0            353              JSR     PrintDataReg
0000133A                           354  
0000133A  4E75                     355              RTS                    ; Return to get more input
0000133C                           356  
0000133C                           357  ASL_Output_Size    ; subroutine for outputting size from D1
0000133C  B2BC 00000000            358              CMP.L   #0,D1           ; if D1 is 0 it is byte size
00001342  6700 001C                359              BEQ     ASL_Output_Byte
00001346                           360  
00001346  B2BC 00000001            361              CMP.L   #1,D1           ; if D1 is 1 it is word size
0000134C  6700 0026                362              BEQ     ASL_Output_Word
00001350                           363  
00001350  B2BC 00000002            364              CMP.L   #2,D1           ; if D1 is 2 it is long size
00001356  6700 0030                365              BEQ     ASL_Output_Long
0000135A                           366  
0000135A  4EF9 0000484E            367              JMP     InvalidOpcode    ; if it is not 0,1,2 it is not a valid size
00001360                           368  
00001360                           369  ASL_Output_Byte
00001360  4EB9 00004A40            370              JSR     PrintASL
00001366  4EB9 00004B7E            371              JSR     LengthB
0000136C  4EB9 00004BB6            372              JSR     PrintSpace
00001372  4E75                     373              RTS                     ; return from subroutine
00001374                           374  
00001374                           375  ASL_Output_Word
00001374  4EB9 00004A40            376              JSR     PrintASL
0000137A  4EB9 00004B88            377              JSR     LengthW
00001380  4EB9 00004BB6            378              JSR     PrintSpace
00001386  4E75                     379              RTS                     ; return from subroutine
00001388                           380  
00001388                           381  ASL_Output_Long
00001388  4EB9 00004A40            382              JSR     PrintASL
0000138E  4EB9 00004B92            383              JSR     LengthL
00001394  4EB9 00004BB6            384              JSR     PrintSpace
0000139A  4E75                     385              RTS                     ; return from subroutine
0000139C                           386  
0000139C                           387  
0000139C                           388  LSL_Count_Opcode
0000139C  7803                     389              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000139E  4EB9 00004856            390              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
000013A4                           391  
000013A4  4EB9 000013CC            392              JSR     LSL_Output_Size    ;output LSL and size from D1
000013AA                           393  
000013AA  4EB9 0000142C            394              JSR     CheckCount     ; change D0 to 8 if D0 equal to 0
000013B0                           395  
000013B0  1E05                     396              MOVE.B  D5,D7
000013B2  1A00                     397              MOVE.B  D0,D5
000013B4                           398  
000013B4  12EE 0029                399              MOVE.B  41(A6),(A1)+             *#
000013B8  4EB9 00004A0A            400              JSR     PrintRegNum
000013BE                           401  
000013BE  1A07                     402              MOVE.B  D7,D5
000013C0  12EE 0025                403              MOVE.B  37(A6),(A1)+             *,
000013C4  4EB9 000049D0            404              JSR     PrintDataReg
000013CA                           405  
000013CA  4E75                     406              RTS                    ; Return to get more input
000013CC                           407  
000013CC                           408  LSL_Output_Size    ; subroutine for outputting size from D1
000013CC  B2BC 00000000            409              CMP.L   #0,D1           ; if D1 is 0 it is byte size
000013D2  6700 001C                410              BEQ     LSL_Output_Byte
000013D6                           411  
000013D6  B2BC 00000001            412              CMP.L   #1,D1           ; if D1 is 1 it is word size
000013DC  6700 0026                413              BEQ     LSL_Output_Word
000013E0                           414  
000013E0  B2BC 00000002            415              CMP.L   #2,D1           ; if D1 is 2 it is long size
000013E6  6700 0030                416              BEQ     LSL_Output_Long
000013EA                           417  
000013EA  4EF9 0000484E            418              JMP     InvalidOpcode    ; if it is not 0,1,2 it is not a valid size
000013F0                           419  
000013F0                           420  LSL_Output_Byte
000013F0  4EB9 00004AC2            421              JSR     PrintLSL
000013F6  4EB9 00004B7E            422              JSR     LengthB
000013FC  4EB9 00004BB6            423              JSR     PrintSpace
00001402  4E75                     424              RTS                     ; return from subroutine
00001404                           425  
00001404                           426  LSL_Output_Word
00001404  4EB9 00004AC2            427              JSR     PrintLSL
0000140A  4EB9 00004B88            428              JSR     LengthW
00001410  4EB9 00004BB6            429              JSR     PrintSpace
00001416  4E75                     430              RTS                     ; return from subroutine
00001418                           431  
00001418                           432  LSL_Output_Long
00001418  4EB9 00004AC2            433              JSR     PrintLSL
0000141E  4EB9 00004B92            434              JSR     LengthL
00001424  4EB9 00004BB6            435              JSR     PrintSpace
0000142A  4E75                     436              RTS                     ; return from subroutine
0000142C                           437  
0000142C                           438  CheckCount  ; Subroutine for change D0 to 8 if D0 equal to 0
0000142C  B0BC 00000000            439              CMP.L   #0,D0
00001432  6700 0004                440              BEQ     D0_to_8
00001436  4E75                     441              RTS                     ; return from subroutine
00001438                           442  
00001438  7008                     443  D0_to_8     MOVE.L  #8,D0
0000143A  4E75                     444              RTS                     ; return from subroutine
0000143C                           445  
0000143C                           446  ASL_Register_Opcode
0000143C  7803                     447              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000143E  4EB9 00004856            448              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
00001444                           449  
00001444  4EB8 133C                450              JSR     ASL_Output_Size    ;output ASL and size from D1
00001448                           451  
00001448  1E05                     452              MOVE.B  D5,D7
0000144A  1A00                     453              MOVE.B  D0,D5
0000144C  4EB9 000049D0            454              JSR     PrintDataReg
00001452                           455  
00001452  1A07                     456              MOVE.B  D7,D5
00001454  4EB9 000049D0            457              JSR     PrintDataReg
0000145A                           458  
0000145A  4E75                     459              RTS                    ; Return to get more input
0000145C                           460  
0000145C                           461  
0000145C                           462  LSL_Register_Opcode
0000145C  7803                     463              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000145E  4EB9 00004856            464              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
00001464                           465  
00001464  4EB8 13CC                466              JSR     LSL_Output_Size    ;output ASL and size from D1
00001468                           467  
00001468  1E05                     468              MOVE.B  D5,D7
0000146A  1A00                     469              MOVE.B  D0,D5
0000146C  4EB9 000049D0            470              JSR     PrintDataReg
00001472                           471  
00001472  1A07                     472              MOVE.B  D7,D5
00001474  4EB9 000049D0            473              JSR     PrintDataReg
0000147A                           474  
0000147A  4E75                     475              RTS                    ; Return to get more input
0000147C                           476  
0000147C                           477  MemShift    ; D0 will hold the count or register (position 11-9)
0000147C  B0BC 00000001            478              CMP.L   #1,D0
00001482  6700 0012                479              BEQ     LSL_MemShift
00001486  B0BC 00000000            480              CMP.L   #0,D0
0000148C  6700 0100                481              BEQ     ASL_MemShift
00001490  4EF9 0000484E            482              JMP     InvalidOpcode  ; for memory shift (position 11-9)need to be 0 or 1
00001496                           483  
00001496                           484  LSL_MemShift     ; D5 should hold the value of position 5-3
00001496  7803                     485              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00001498  4EB9 00004856            486              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us mode
0000149E                           487  
0000149E  BABC 00000002            488              CMP.L   #2,D5               ; if position 5-3 is 2 then it is mode 2
000014A4  6700 0026                489              BEQ     LSL_MemShift_Mode_2
000014A8                           490  
000014A8  BABC 00000003            491              CMP.L   #3,D5               ; if position 5-3 is 3 then it is mode 3
000014AE  6700 003E                492              BEQ     LSL_MemShift_Mode_3
000014B2                           493  
000014B2  BABC 00000004            494              CMP.L   #4,D5               ; if position 5-3 is 4 then it is mode 4
000014B8  6700 0056                495              BEQ     LSL_MemShift_Mode_4
000014BC                           496  
000014BC  BABC 00000007            497              CMP.L   #7,D5               ; if position 5-3 is 7 then it is mode 7
000014C2  6700 006E                498              BEQ     LSL_MemShift_Mode_7
000014C6                           499  
000014C6  4EF9 0000484E            500              JMP     InvalidOpcode       ; if it is not Addressing mode 2,3,4,7 it is invalid
000014CC                           501  
000014CC                           502  LSL_MemShift_Mode_2
000014CC  7803                     503              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000014CE  4EB9 00004856            504              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000014D4  4EB9 00004AC2            505              JSR     PrintLSL
000014DA  4EB9 00004B88            506              JSR     LengthW
000014E0  4EB9 00004BB6            507              JSR     PrintSpace
000014E6  4EB9 000049E8            508              JSR     PrintIndirAddrReg
000014EC  4E75                     509              RTS                    ; Return to get more input
000014EE                           510  
000014EE                           511  LSL_MemShift_Mode_3
000014EE  7803                     512              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000014F0  4EB9 00004856            513              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000014F6  4EB9 00004AC2            514              JSR     PrintLSL
000014FC  4EB9 00004B88            515              JSR     LengthW
00001502  4EB9 00004BB6            516              JSR     PrintSpace
00001508  4EB9 000049F6            517              JSR     PrintPostIncAddrReg
0000150E  4E75                     518              RTS                    ; Return to get more input
00001510                           519  
00001510                           520  LSL_MemShift_Mode_4
00001510  7803                     521              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001512  4EB9 00004856            522              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001518  4EB9 00004AC2            523              JSR     PrintLSL
0000151E  4EB9 00004B88            524              JSR     LengthW
00001524  4EB9 00004BB6            525              JSR     PrintSpace
0000152A  4EB9 00004A00            526              JSR     PrintPreDeincAddrReg
00001530  4E75                     527              RTS                    ; Return to get more input
00001532                           528  
00001532                           529  LSL_MemShift_Mode_7
00001532  7803                     530              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001534  4EB9 00004856            531              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
0000153A                           532  
0000153A  BABC 00000001            533              CMP.L   #1,D5               ; check if the register is 1
00001540  6700 0032                534              BEQ     LSL_MemShift_xxxL   ; if mode is 7 and register is 1, it is <xxx>.L
00001544                           535  
00001544  BABC 00000000            536              CMP.L   #0,D5               ; check if the register is 0
0000154A  6700 0008                537              BEQ     LSL_MemShift_xxxW   ; if mode is 7 and register is 1, it is <xxx>.W
0000154E                           538  
0000154E  4EF9 0000484E            539              JMP     InvalidOpcode       ; if it is not <xxx>.W or <xxx>.L
00001554                           540  
00001554                           541  LSL_MemShift_xxxW
00001554  4EB9 00004AC2            542              JSR     PrintLSL
0000155A  4EB9 00004B88            543              JSR     LengthW
00001560  4EB9 00004BB6            544              JSR     PrintSpace
00001566  4EB9 00004950            545              JSR     PrintByteOrWord
0000156C  4EB9 00004B88            546              JSR     LengthW
00001572  4E75                     547              RTS                    ; Return to get more input
00001574                           548  
00001574                           549  LSL_MemShift_xxxL
00001574  4EB9 00004AC2            550              JSR     PrintLSL
0000157A  4EB9 00004B88            551              JSR     LengthW
00001580  4EB9 00004BB6            552              JSR     PrintSpace
00001586  4EB9 00004966            553              JSR     PrintLong
0000158C  4E75                     554              RTS                    ; Return to get more input
0000158E                           555  
0000158E                           556  ASL_MemShift    ; D5 should hold the value of position 5-3
0000158E  7803                     557              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001590  4EB9 00004856            558              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us mode
00001596                           559  
00001596  BABC 00000002            560              CMP.L   #2,D5               ; if position 5-3 is 2 then it is mode 2
0000159C  6700 0026                561              BEQ     ASL_MemShift_Mode_2
000015A0                           562  
000015A0  BABC 00000003            563              CMP.L   #3,D5               ; if position 5-3 is 3 then it is mode 3
000015A6  6700 003E                564              BEQ     ASL_MemShift_Mode_3
000015AA                           565  
000015AA  BABC 00000004            566              CMP.L   #4,D5               ; if position 5-3 is 4 then it is mode 4
000015B0  6700 0056                567              BEQ     ASL_MemShift_Mode_4
000015B4                           568  
000015B4  BABC 00000007            569              CMP.L   #7,D5               ; if position 5-3 is 7 then it is mode 7
000015BA  6700 006E                570              BEQ     ASL_MemShift_Mode_7
000015BE                           571  
000015BE  4EF9 0000484E            572              JMP     InvalidOpcode       ; if it is not Addressing mode 2,3,4,7 it is invalid
000015C4                           573  
000015C4                           574  ASL_MemShift_Mode_2
000015C4  7803                     575              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000015C6  4EB9 00004856            576              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000015CC  4EB9 00004A40            577              JSR     PrintASL
000015D2  4EB9 00004B88            578              JSR     LengthW
000015D8  4EB9 00004BB6            579              JSR     PrintSpace
000015DE  4EB9 000049E8            580              JSR     PrintIndirAddrReg
000015E4  4E75                     581              RTS                    ; Return to get more input
000015E6                           582  
000015E6                           583  ASL_MemShift_Mode_3
000015E6  7803                     584              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000015E8  4EB9 00004856            585              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000015EE  4EB9 00004A40            586              JSR     PrintASL
000015F4  4EB9 00004B88            587              JSR     LengthW
000015FA  4EB9 00004BB6            588              JSR     PrintSpace
00001600  4EB9 000049F6            589              JSR     PrintPostIncAddrReg
00001606  4E75                     590              RTS                    ; Return to get more input
00001608                           591  
00001608                           592  ASL_MemShift_Mode_4
00001608  7803                     593              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000160A  4EB9 00004856            594              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001610  4EB9 00004A40            595              JSR     PrintASL
00001616  4EB9 00004B88            596              JSR     LengthW
0000161C  4EB9 00004BB6            597              JSR     PrintSpace
00001622  4EB9 00004A00            598              JSR     PrintPreDeincAddrReg
00001628  4E75                     599              RTS                    ; Return to get more input
0000162A                           600  
0000162A                           601  ASL_MemShift_Mode_7
0000162A  7803                     602              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000162C  4EB9 00004856            603              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001632                           604  
00001632  BABC 00000001            605              CMP.L   #1,D5               ; check if the register is 1
00001638  6700 002C                606              BEQ     ASL_MemShift_xxxL   ; if mode is 7 and register is 1, it is <xxx>.L
0000163C                           607  
0000163C  BABC 00000000            608              CMP.L   #0,D5               ; check if the register is 0
00001642  6700 0008                609              BEQ     ASL_MemShift_xxxW   ; if mode is 7 and register is 1, it is <xxx>.W
00001646                           610  
00001646  4EF9 0000484E            611              JMP     InvalidOpcode  ; if it is not <xxx>.W or <xxx>.L
0000164C                           612  
0000164C                           613  ASL_MemShift_xxxW
0000164C  4EB9 00004A40            614              JSR     PrintASL
00001652  4EB9 00004B88            615              JSR     LengthW
00001658  4EB9 00004BB6            616              JSR     PrintSpace
0000165E  4EB9 00004950            617              JSR     PrintByteOrWord
00001664  4E75                     618              RTS                    ; Return to get more input
00001666                           619  
00001666                           620  ASL_MemShift_xxxL
00001666  4EB9 00004A40            621              JSR     PrintASL
0000166C  4EB9 00004B88            622              JSR     LengthW
00001672  4EB9 00004BB6            623              JSR     PrintSpace
00001678  4EB9 00004966            624              JSR     PrintLong
0000167E  4E75                     625              RTS                    ; Return to get more input
00001680                           626  
00001680                           627  
00001680                           628  *************************************************                ADD_Opcode                 *************************************************
00001680                           629  ; first four bit is (1101 #### #### ####)
00001680  7803                     630  ADD_Opcode  MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00001682  4EB9 00004856            631              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001688                           632  
00001688  2005                     633              MOVE.L  D5,D0               ; D0 will hold the register
0000168A                           634          ; D0 will hold the register (position 11-9)
0000168A                           635  
0000168A  7803                     636              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
0000168C  4EB9 00004856            637              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the opmode
00001692                           638  
00001692  BABC 00000000            639              CMP.L   #0,D5               ; if opmode is 0, it is a byte with location specified is a source  (<ea> + Dn -> Dn)
00001698  6700 003A                640              BEQ     ADD_B_SrcEA
0000169C                           641  
0000169C  BABC 00000001            642              CMP.L   #1,D5               ; if opmode is 1, it is a word with location specified is a source  (<ea> + Dn -> Dn)
000016A2  6700 01FE                643              BEQ     ADD_W_SrcEA
000016A6                           644  
000016A6  BABC 00000002            645              CMP.L   #2,D5               ; if opmode is 2, it is a long with location specified is a source  (<ea> + Dn -> Dn)
000016AC  6700 03C2                646              BEQ     ADD_L_SrcEA
000016B0                           647  
000016B0  BABC 00000004            648              CMP.L   #4,D5               ; if opmode is 4, it is a byte with location specified is a Destination (Dn + <ea> -> <ea>)
000016B6  6700 0586                649              BEQ     ADD_B_DesEA
000016BA                           650  
000016BA  BABC 00000005            651              CMP.L   #5,D5               ; if opmode is 5, it is a word with location specified is a Destination (Dn + <ea> -> <ea>)
000016C0  6700 06BA                652              BEQ     ADD_W_DesEA
000016C4                           653  
000016C4  BABC 00000006            654              CMP.L   #6,D5               ; if opmode is 6, it is a long with location specified is a Destination (Dn + <ea> -> <ea>)
000016CA  6700 07EE                655              BEQ     ADD_L_DesEA
000016CE                           656  
000016CE  4EF9 0000484E            657              JMP     InvalidOpcode       ; if it is not one of the opmode the opcode is invalid
000016D4                           658  
000016D4  7803                     659  ADD_B_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000016D6  4EB9 00004856            660              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000016DC                           661  
000016DC  BABC 00000000            662              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000016E2  6700 003A                663              BEQ     ADD_B_SrcEA_M0
000016E6                           664  
000016E6  BABC 00000001            665              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
000016EC  6700 005E                666              BEQ     ADD_B_SrcEA_M1
000016F0                           667  
000016F0  BABC 00000002            668              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000016F6  6700 0082                669              BEQ     ADD_B_SrcEA_M2
000016FA                           670  
000016FA  BABC 00000003            671              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001700  6700 00A6                672              BEQ     ADD_B_SrcEA_M3
00001704                           673  
00001704  BABC 00000004            674              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000170A  6700 00CA                675              BEQ     ADD_B_SrcEA_M4
0000170E                           676  
0000170E  BABC 00000007            677              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001714  6700 00EE                678              BEQ     ADD_B_SrcEA_M7
00001718                           679  
00001718  4EF9 0000484E            680              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000171E                           681  
0000171E                           682  ADD_B_SrcEA_M0
0000171E  7803                     683              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001720  4EB9 00004856            684              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001726  4EB9 00004A10            685              JSR     PrintAdd
0000172C  4EB9 00004B7E            686              JSR     LengthB
00001732  4EB9 00004BB6            687              JSR     PrintSpace
00001738  4EB9 000049D0            688              JSR     PrintDataReg
0000173E                           689  
0000173E  1A00                     690              MOVE.B  D0,D5
00001740  12EE 0025                691              MOVE.B  37(A6),(A1)+             *,
00001744  4EB9 000049D0            692              JSR     PrintDataReg
0000174A                           693  
0000174A  4E75                     694              RTS                     ; return to input to get more input
0000174C                           695  
0000174C                           696  ADD_B_SrcEA_M1
0000174C  7803                     697              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000174E  4EB9 00004856            698              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001754  4EB9 00004A10            699              JSR     PrintAdd
0000175A  4EB9 00004B7E            700              JSR     LengthB
00001760  4EB9 00004BB6            701              JSR     PrintSpace
00001766  4EB9 000049DC            702              JSR     PrintAddrReg
0000176C                           703  
0000176C  1A00                     704              MOVE.B  D0,D5
0000176E  12EE 0025                705              MOVE.B  37(A6),(A1)+             *,
00001772  4EB9 000049D0            706              JSR     PrintDataReg
00001778  4E75                     707              RTS                     ; return to input to get more input
0000177A                           708  
0000177A                           709  ADD_B_SrcEA_M2
0000177A  7803                     710              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000177C  4EB9 00004856            711              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001782  4EB9 00004A10            712              JSR     PrintAdd
00001788  4EB9 00004B7E            713              JSR     LengthB
0000178E  4EB9 00004BB6            714              JSR     PrintSpace
00001794  4EB9 000049E8            715              JSR     PrintIndirAddrReg
0000179A                           716  
0000179A  1A00                     717              MOVE.B  D0,D5
0000179C  12EE 0025                718              MOVE.B  37(A6),(A1)+             *,
000017A0  4EB9 000049D0            719              JSR     PrintDataReg
000017A6                           720  
000017A6  4E75                     721              RTS                     ; return to input to get more input
000017A8                           722  
000017A8                           723  ADD_B_SrcEA_M3
000017A8  7803                     724              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000017AA  4EB9 00004856            725              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000017B0  4EB9 00004A10            726              JSR     PrintAdd
000017B6  4EB9 00004B7E            727              JSR     LengthB
000017BC  4EB9 00004BB6            728              JSR     PrintSpace
000017C2  4EB9 000049F6            729              JSR     PrintPostIncAddrReg
000017C8                           730  
000017C8  1A00                     731              MOVE.B  D0,D5
000017CA  12EE 0025                732              MOVE.B  37(A6),(A1)+             *,
000017CE  4EB9 000049D0            733              JSR     PrintDataReg
000017D4  4E75                     734              RTS                     ; return to input to get more input
000017D6                           735  
000017D6                           736  ADD_B_SrcEA_M4
000017D6  7803                     737              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000017D8  4EB9 00004856            738              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000017DE  4EB9 00004A10            739              JSR     PrintAdd
000017E4  4EB9 00004B7E            740              JSR     LengthB
000017EA  4EB9 00004BB6            741              JSR     PrintSpace
000017F0  4EB9 00004A00            742              JSR     PrintPreDeincAddrReg
000017F6                           743  
000017F6  1A00                     744              MOVE.B  D0,D5
000017F8  12EE 0025                745              MOVE.B  37(A6),(A1)+             *,
000017FC  4EB9 000049D0            746              JSR     PrintDataReg
00001802  4E75                     747              RTS                     ; return to input to get more input
00001804                           748  
00001804                           749  ADD_B_SrcEA_M7
00001804  7803                     750              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001806  4EB9 00004856            751              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000180C                           752  
0000180C  BABC 00000000            753              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001812  6700 001C                754              BEQ     ADD_B_SrcEA_xxxW
00001816                           755  
00001816  BABC 00000001            756              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
0000181C  6700 0038                757              BEQ     ADD_B_SrcEA_xxxL
00001820                           758  
00001820  BABC 00000004            759              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00001826  6700 0054                760              BEQ     ADD_B_SrcEA_Data
0000182A                           761  
0000182A  4EF9 0000484E            762              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001830                           763  
00001830                           764  ADD_B_SrcEA_xxxW
00001830  4EB9 00004A10            765              JSR     PrintAdd
00001836  4EB9 00004B7E            766              JSR     LengthB
0000183C  4EB9 00004BB6            767              JSR     PrintSpace
00001842  4EB9 00004950            768              JSR     PrintByteOrWord
00001848                           769  
00001848  1A00                     770              MOVE.B  D0,D5
0000184A  12EE 0025                771              MOVE.B  37(A6),(A1)+             *,
0000184E  4EB9 000049D0            772              JSR     PrintDataReg
00001854  4E75                     773              RTS                     ; return to input to get more input
00001856                           774  
00001856                           775  ADD_B_SrcEA_xxxL
00001856  4EB9 00004A10            776              JSR     PrintAdd
0000185C  4EB9 00004B7E            777              JSR     LengthB
00001862  4EB9 00004BB6            778              JSR     PrintSpace
00001868  4EB9 00004966            779              JSR     PrintLong
0000186E                           780  
0000186E  1A00                     781              MOVE.B  D0,D5
00001870  12EE 0025                782              MOVE.B  37(A6),(A1)+             *,
00001874  4EB9 000049D0            783              JSR     PrintDataReg
0000187A  4E75                     784              RTS                     ; return to input to get more input
0000187C                           785  
0000187C                           786  ADD_B_SrcEA_Data
0000187C  4EB9 00004A10            787              JSR     PrintAdd
00001882  4EB9 00004B7E            788              JSR     LengthB
00001888  4EB9 00004BB6            789              JSR     PrintSpace
0000188E  4EB9 00004944            790              JSR     PrintImmediateData
00001894                           791  
00001894  1A00                     792              MOVE.B  D0,D5
00001896  12EE 0025                793              MOVE.B  37(A6),(A1)+             *,
0000189A  4EB9 000049D0            794              JSR     PrintDataReg
000018A0  4E75                     795              RTS                     ; return to input to get more input
000018A2                           796  
000018A2  7803                     797  ADD_W_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000018A4  4EB9 00004856            798              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000018AA                           799  
000018AA  BABC 00000000            800              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000018B0  6700 003A                801              BEQ     ADD_W_SrcEA_M0
000018B4                           802  
000018B4  BABC 00000001            803              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
000018BA  6700 005E                804              BEQ     ADD_W_SrcEA_M1
000018BE                           805  
000018BE  BABC 00000002            806              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000018C4  6700 0082                807              BEQ     ADD_W_SrcEA_M2
000018C8                           808  
000018C8  BABC 00000003            809              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000018CE  6700 00A6                810              BEQ     ADD_W_SrcEA_M3
000018D2                           811  
000018D2  BABC 00000004            812              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000018D8  6700 00CA                813              BEQ     ADD_W_SrcEA_M4
000018DC                           814  
000018DC  BABC 00000007            815              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000018E2  6700 00EE                816              BEQ     ADD_W_SrcEA_M7
000018E6                           817  
000018E6  4EF9 0000484E            818              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000018EC                           819  
000018EC                           820  ADD_W_SrcEA_M0
000018EC  7803                     821              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000018EE  4EB9 00004856            822              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000018F4  4EB9 00004A10            823              JSR     PrintAdd
000018FA  4EB9 00004B88            824              JSR     LengthW
00001900  4EB9 00004BB6            825              JSR     PrintSpace
00001906  4EB9 000049D0            826              JSR     PrintDataReg
0000190C                           827  
0000190C  1A00                     828              MOVE.B  D0,D5
0000190E  12EE 0025                829              MOVE.B  37(A6),(A1)+             *,
00001912  4EB9 000049D0            830              JSR     PrintDataReg
00001918  4E75                     831              RTS                     ; return to input to get more input
0000191A                           832  
0000191A                           833  ADD_W_SrcEA_M1
0000191A  7803                     834              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000191C  4EB9 00004856            835              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001922  4EB9 00004A10            836              JSR     PrintAdd
00001928  4EB9 00004B88            837              JSR     LengthW
0000192E  4EB9 00004BB6            838              JSR     PrintSpace
00001934  4EB9 000049DC            839              JSR     PrintAddrReg
0000193A                           840  
0000193A  1A00                     841              MOVE.B  D0,D5
0000193C  12EE 0025                842              MOVE.B  37(A6),(A1)+             *,
00001940  4EB9 000049D0            843              JSR     PrintDataReg
00001946  4E75                     844              RTS                     ; return to input to get more input
00001948                           845  
00001948                           846  ADD_W_SrcEA_M2
00001948  7803                     847              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000194A  4EB9 00004856            848              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001950  4EB9 00004A10            849              JSR     PrintAdd
00001956  4EB9 00004B88            850              JSR     LengthW
0000195C  4EB9 00004BB6            851              JSR     PrintSpace
00001962  4EB9 000049E8            852              JSR     PrintIndirAddrReg
00001968                           853  
00001968  1A00                     854              MOVE.B  D0,D5
0000196A  12EE 0025                855              MOVE.B  37(A6),(A1)+             *,
0000196E  4EB9 000049D0            856              JSR     PrintDataReg
00001974  4E75                     857              RTS                     ; return to input to get more input
00001976                           858  
00001976                           859  ADD_W_SrcEA_M3
00001976  7803                     860              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001978  4EB9 00004856            861              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000197E  4EB9 00004A10            862              JSR     PrintAdd
00001984  4EB9 00004B88            863              JSR     LengthW
0000198A  4EB9 00004BB6            864              JSR     PrintSpace
00001990  4EB9 000049F6            865              JSR     PrintPostIncAddrReg
00001996                           866  
00001996  1A00                     867              MOVE.B  D0,D5
00001998  12EE 0025                868              MOVE.B  37(A6),(A1)+             *,
0000199C  4EB9 000049D0            869              JSR     PrintDataReg
000019A2  4E75                     870              RTS                     ; return to input to get more input
000019A4                           871  
000019A4                           872  ADD_W_SrcEA_M4
000019A4  7803                     873              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000019A6  4EB9 00004856            874              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000019AC  4EB9 00004A10            875              JSR     PrintAdd
000019B2  4EB9 00004B88            876              JSR     LengthW
000019B8  4EB9 00004BB6            877              JSR     PrintSpace
000019BE  4EB9 00004A00            878              JSR     PrintPreDeincAddrReg
000019C4                           879  
000019C4  1A00                     880              MOVE.B  D0,D5
000019C6  12EE 0025                881              MOVE.B  37(A6),(A1)+             *,
000019CA  4EB9 000049D0            882              JSR     PrintDataReg
000019D0  4E75                     883              RTS                     ; return to input to get more input
000019D2                           884  
000019D2                           885  ADD_W_SrcEA_M7
000019D2  7803                     886              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000019D4  4EB9 00004856            887              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000019DA                           888  
000019DA  BABC 00000000            889              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000019E0  6700 001C                890              BEQ     ADD_W_SrcEA_xxxW
000019E4                           891  
000019E4  BABC 00000001            892              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000019EA  6700 0038                893              BEQ     ADD_W_SrcEA_xxxL
000019EE                           894  
000019EE  BABC 00000004            895              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
000019F4  6700 0054                896              BEQ     ADD_W_SrcEA_Data
000019F8                           897  
000019F8  4EF9 0000484E            898              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000019FE                           899  
000019FE                           900  ADD_W_SrcEA_xxxW
000019FE  4EB9 00004A10            901              JSR     PrintAdd
00001A04  4EB9 00004B88            902              JSR     LengthW
00001A0A  4EB9 00004BB6            903              JSR     PrintSpace
00001A10  4EB9 00004950            904              JSR     PrintByteOrWord
00001A16                           905  
00001A16  1A00                     906              MOVE.B  D0,D5
00001A18  12EE 0025                907              MOVE.B  37(A6),(A1)+             *,
00001A1C  4EB9 000049D0            908              JSR     PrintDataReg
00001A22  4E75                     909              RTS                     ; return to input to get more input
00001A24                           910  
00001A24                           911  ADD_W_SrcEA_xxxL
00001A24  4EB9 00004A10            912              JSR     PrintAdd
00001A2A  4EB9 00004B88            913              JSR     LengthW
00001A30  4EB9 00004BB6            914              JSR     PrintSpace
00001A36  4EB9 00004966            915              JSR     PrintLong
00001A3C                           916  
00001A3C  1A00                     917              MOVE.B  D0,D5
00001A3E  12EE 0025                918              MOVE.B  37(A6),(A1)+             *,
00001A42  4EB9 000049D0            919              JSR     PrintDataReg
00001A48  4E75                     920              RTS                     ; return to input to get more input
00001A4A                           921  
00001A4A                           922  ADD_W_SrcEA_Data
00001A4A  4EB9 00004A10            923              JSR     PrintAdd
00001A50  4EB9 00004B88            924              JSR     LengthW
00001A56  4EB9 00004BB6            925              JSR     PrintSpace
00001A5C  4EB9 00004944            926              JSR     PrintImmediateData
00001A62                           927  
00001A62  1A00                     928              MOVE.B  D0,D5
00001A64  12EE 0025                929              MOVE.B  37(A6),(A1)+             *,
00001A68  4EB9 000049D0            930              JSR     PrintDataReg
00001A6E  4E75                     931              RTS                     ; return to input to get more input
00001A70                           932  
00001A70  7803                     933  ADD_L_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001A72  4EB9 00004856            934              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001A78                           935  
00001A78  BABC 00000000            936              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00001A7E  6700 003A                937              BEQ     ADD_L_SrcEA_M0
00001A82                           938  
00001A82  BABC 00000001            939              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00001A88  6700 005E                940              BEQ     ADD_L_SrcEA_M1
00001A8C                           941  
00001A8C  BABC 00000002            942              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001A92  6700 0082                943              BEQ     ADD_L_SrcEA_M2
00001A96                           944  
00001A96  BABC 00000003            945              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001A9C  6700 00A6                946              BEQ     ADD_L_SrcEA_M3
00001AA0                           947  
00001AA0  BABC 00000004            948              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001AA6  6700 00CA                949              BEQ     ADD_L_SrcEA_M4
00001AAA                           950  
00001AAA  BABC 00000007            951              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001AB0  6700 00EE                952              BEQ     ADD_L_SrcEA_M7
00001AB4                           953  
00001AB4  4EF9 0000484E            954              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001ABA                           955  
00001ABA                           956  ADD_L_SrcEA_M0
00001ABA  7803                     957              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001ABC  4EB9 00004856            958              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001AC2  4EB9 00004A10            959              JSR     PrintAdd
00001AC8  4EB9 00004B92            960              JSR     LengthL
00001ACE  4EB9 00004BB6            961              JSR     PrintSpace
00001AD4  4EB9 000049D0            962              JSR     PrintDataReg
00001ADA                           963  
00001ADA  1A00                     964              MOVE.B  D0,D5
00001ADC  12EE 0025                965              MOVE.B  37(A6),(A1)+             *,
00001AE0  4EB9 000049D0            966              JSR     PrintDataReg
00001AE6  4E75                     967              RTS                     ; return to input to get more input
00001AE8                           968  
00001AE8                           969  ADD_L_SrcEA_M1
00001AE8  7803                     970              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001AEA  4EB9 00004856            971              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001AF0  4EB9 00004A10            972              JSR     PrintAdd
00001AF6  4EB9 00004B92            973              JSR     LengthL
00001AFC  4EB9 00004BB6            974              JSR     PrintSpace
00001B02  4EB9 000049DC            975              JSR     PrintAddrReg
00001B08                           976  
00001B08  1A00                     977              MOVE.B  D0,D5
00001B0A  12EE 0025                978              MOVE.B  37(A6),(A1)+             *,
00001B0E  4EB9 000049D0            979              JSR     PrintDataReg
00001B14  4E75                     980              RTS                     ; return to input to get more input
00001B16                           981  
00001B16                           982  ADD_L_SrcEA_M2
00001B16  7803                     983              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001B18  4EB9 00004856            984              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001B1E  4EB9 00004A10            985              JSR     PrintAdd
00001B24  4EB9 00004B92            986              JSR     LengthL
00001B2A  4EB9 00004BB6            987              JSR     PrintSpace
00001B30  4EB9 000049E8            988              JSR     PrintIndirAddrReg
00001B36                           989  
00001B36  1A00                     990              MOVE.B  D0,D5
00001B38  12EE 0025                991              MOVE.B  37(A6),(A1)+             *,
00001B3C  4EB9 000049D0            992              JSR     PrintDataReg
00001B42  4E75                     993              RTS                     ; return to input to get more input
00001B44                           994  
00001B44                           995  ADD_L_SrcEA_M3
00001B44  7803                     996              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001B46  4EB9 00004856            997              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001B4C  4EB9 00004A10            998              JSR     PrintAdd
00001B52  4EB9 00004B92            999              JSR     LengthL
00001B58  4EB9 00004BB6           1000              JSR     PrintSpace
00001B5E  4EB9 000049F6           1001              JSR     PrintPostIncAddrReg
00001B64                          1002  
00001B64  1A00                    1003              MOVE.B  D0,D5
00001B66  12EE 0025               1004              MOVE.B  37(A6),(A1)+             *,
00001B6A  4EB9 000049D0           1005              JSR     PrintDataReg
00001B70  4E75                    1006              RTS                     ; return to input to get more input
00001B72                          1007  
00001B72                          1008  ADD_L_SrcEA_M4
00001B72  7803                    1009              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001B74  4EB9 00004856           1010              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001B7A  4EB9 00004A10           1011              JSR     PrintAdd
00001B80  4EB9 00004B92           1012              JSR     LengthL
00001B86  4EB9 00004BB6           1013              JSR     PrintSpace
00001B8C  4EB9 00004A00           1014              JSR     PrintPreDeincAddrReg
00001B92                          1015  
00001B92  1A00                    1016              MOVE.B  D0,D5
00001B94  12EE 0025               1017              MOVE.B  37(A6),(A1)+             *,
00001B98  4EB9 000049D0           1018              JSR     PrintDataReg
00001B9E  4E75                    1019              RTS                     ; return to input to get more input
00001BA0                          1020  
00001BA0                          1021  ADD_L_SrcEA_M7
00001BA0  7803                    1022              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001BA2  4EB9 00004856           1023              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001BA8                          1024  
00001BA8  BABC 00000000           1025              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001BAE  6700 001C               1026              BEQ     ADD_L_SrcEA_xxxW
00001BB2                          1027  
00001BB2  BABC 00000001           1028              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001BB8  6700 0038               1029              BEQ     ADD_L_SrcEA_xxxL
00001BBC                          1030  
00001BBC  BABC 00000004           1031              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00001BC2  6700 0054               1032              BEQ     ADD_L_SrcEA_Data
00001BC6                          1033  
00001BC6  4EF9 0000484E           1034              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001BCC                          1035  
00001BCC                          1036  ADD_L_SrcEA_xxxW
00001BCC  4EB9 00004A10           1037              JSR     PrintAdd
00001BD2  4EB9 00004B92           1038              JSR     LengthL
00001BD8  4EB9 00004BB6           1039              JSR     PrintSpace
00001BDE  4EB9 00004950           1040              JSR     PrintByteOrWord
00001BE4                          1041  
00001BE4  1A00                    1042              MOVE.B  D0,D5
00001BE6  12EE 0025               1043              MOVE.B  37(A6),(A1)+             *,
00001BEA  4EB9 000049D0           1044              JSR     PrintDataReg
00001BF0  4E75                    1045              RTS                     ; return to input to get more input
00001BF2                          1046  
00001BF2                          1047  ADD_L_SrcEA_xxxL
00001BF2  4EB9 00004A10           1048              JSR     PrintAdd
00001BF8  4EB9 00004B92           1049              JSR     LengthL
00001BFE  4EB9 00004BB6           1050              JSR     PrintSpace
00001C04  4EB9 00004966           1051              JSR     PrintLong
00001C0A                          1052  
00001C0A  1A00                    1053              MOVE.B  D0,D5
00001C0C  12EE 0025               1054              MOVE.B  37(A6),(A1)+             *,
00001C10  4EB9 000049D0           1055              JSR     PrintDataReg
00001C16  4E75                    1056              RTS                     ; return to input to get more input
00001C18                          1057  
00001C18                          1058  ADD_L_SrcEA_Data
00001C18  4EB9 00004A10           1059              JSR     PrintAdd
00001C1E  4EB9 00004B92           1060              JSR     LengthL
00001C24  4EB9 00004BB6           1061              JSR     PrintSpace
00001C2A  4EB9 00004944           1062              JSR     PrintImmediateData
00001C30                          1063  
00001C30  1A00                    1064              MOVE.B  D0,D5
00001C32  12EE 0025               1065              MOVE.B  37(A6),(A1)+             *,
00001C36  4EB9 000049D0           1066              JSR     PrintDataReg
00001C3C  4E75                    1067              RTS                     ; return to input to get more input
00001C3E                          1068  
00001C3E  7803                    1069  ADD_B_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001C40  4EB9 00004856           1070              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001C46                          1071  
00001C46  BABC 00000002           1072              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001C4C  6700 0026               1073              BEQ     ADD_B_DesEA_M2
00001C50                          1074  
00001C50  BABC 00000003           1075              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001C56  6700 004E               1076              BEQ     ADD_B_DesEA_M3
00001C5A                          1077  
00001C5A  BABC 00000004           1078              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001C60  6700 0072               1079              BEQ     ADD_B_DesEA_M4
00001C64                          1080  
00001C64  BABC 00000007           1081              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001C6A  6700 009A               1082              BEQ     ADD_B_DesEA_M7
00001C6E                          1083  
00001C6E  4EF9 0000484E           1084              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001C74                          1085  
00001C74                          1086  ADD_B_DesEA_M2
00001C74  7803                    1087              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001C76  4EB9 00004856           1088              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001C7C  4EB9 00004A10           1089              JSR     PrintAdd
00001C82  4EB9 00004B7E           1090              JSR     LengthB
00001C88  4EB9 00004BB6           1091              JSR     PrintSpace
00001C8E                          1092  
00001C8E  1E05                    1093              MOVE.B  D5,D7
00001C90  1A00                    1094              MOVE.B  D0,D5
00001C92  4EB9 000049D0           1095              JSR     PrintDataReg
00001C98                          1096  
00001C98  1A07                    1097              MOVE.B  D7,D5
00001C9A  12EE 0025               1098              MOVE.B  37(A6),(A1)+             *,
00001C9E  4EB9 000049E8           1099              JSR     PrintIndirAddrReg
00001CA4  4E75                    1100              RTS                     ; return to input to get more input
00001CA6                          1101  
00001CA6                          1102  ADD_B_DesEA_M3
00001CA6  7803                    1103              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001CA8  4EB9 00004856           1104              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001CAE  4EB9 00004A10           1105              JSR     PrintAdd
00001CB4  4EB9 00004B7E           1106              JSR     LengthB
00001CBA  4EB9 00004BB6           1107              JSR     PrintSpace
00001CC0  4EB9 000049F6           1108              JSR     PrintPostIncAddrReg
00001CC6                          1109  
00001CC6  1A00                    1110              MOVE.B  D0,D5
00001CC8  12EE 0025               1111              MOVE.B  37(A6),(A1)+             *,
00001CCC  4EB9 000049D0           1112              JSR     PrintDataReg
00001CD2  4E75                    1113              RTS                     ; return to input to get more input
00001CD4                          1114  
00001CD4                          1115  ADD_B_DesEA_M4
00001CD4  7803                    1116              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001CD6  4EB9 00004856           1117              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001CDC  4EB9 00004A10           1118              JSR     PrintAdd
00001CE2  4EB9 00004B7E           1119              JSR     LengthB
00001CE8  4EB9 00004BB6           1120              JSR     PrintSpace
00001CEE                          1121  
00001CEE  1E05                    1122              MOVE.B  D5,D7
00001CF0  1A00                    1123              MOVE.B  D0,D5
00001CF2  4EB9 000049D0           1124              JSR     PrintDataReg
00001CF8                          1125  
00001CF8  1A07                    1126              MOVE.B  D7,D5
00001CFA  12EE 0025               1127              MOVE.B  37(A6),(A1)+             *,
00001CFE  4EB9 00004A00           1128              JSR     PrintPreDeincAddrReg
00001D04  4E75                    1129              RTS                     ; return to input to get more input
00001D06                          1130  
00001D06                          1131  ADD_B_DesEA_M7
00001D06  7803                    1132              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001D08  4EB9 00004856           1133              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001D0E                          1134  
00001D0E  BABC 00000000           1135              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001D14  6700 0012               1136              BEQ     ADD_B_DesEA_xxxW
00001D18                          1137  
00001D18  BABC 00000001           1138              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001D1E  6700 0032               1139              BEQ     ADD_B_DesEA_xxxL
00001D22                          1140  
00001D22  4EF9 0000484E           1141              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001D28                          1142  
00001D28                          1143  ADD_B_DesEA_xxxW
00001D28  4EB9 00004A10           1144              JSR     PrintAdd
00001D2E  4EB9 00004B7E           1145              JSR     LengthB
00001D34  4EB9 00004BB6           1146              JSR     PrintSpace
00001D3A                          1147  
00001D3A  1E05                    1148              MOVE.B  D5,D7
00001D3C  1A00                    1149              MOVE.B  D0,D5
00001D3E  4EB9 000049D0           1150              JSR     PrintDataReg
00001D44                          1151  
00001D44  1A07                    1152              MOVE.B  D7,D5
00001D46  12EE 0025               1153              MOVE.B  37(A6),(A1)+             *,
00001D4A  4EB9 00004950           1154              JSR     PrintByteOrWord
00001D50  4E75                    1155              RTS                     ; return to input to get more input
00001D52                          1156  
00001D52                          1157  ADD_B_DesEA_xxxL
00001D52  4EB9 00004A10           1158              JSR     PrintAdd
00001D58  4EB9 00004B7E           1159              JSR     LengthB
00001D5E  4EB9 00004BB6           1160              JSR     PrintSpace
00001D64                          1161  
00001D64  1E05                    1162              MOVE.B  D5,D7
00001D66  1A00                    1163              MOVE.B  D0,D5
00001D68  4EB9 000049D0           1164              JSR     PrintDataReg
00001D6E                          1165  
00001D6E  1A07                    1166              MOVE.B  D7,D5
00001D70  12EE 0025               1167              MOVE.B  37(A6),(A1)+             *,
00001D74  4EB9 00004966           1168              JSR     PrintLong
00001D7A  4E75                    1169              RTS                     ; return to input to get more input
00001D7C                          1170  
00001D7C  7803                    1171  ADD_W_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001D7E  4EB9 00004856           1172              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001D84                          1173  
00001D84  BABC 00000002           1174              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001D8A  6700 0026               1175              BEQ     ADD_W_DesEA_M2
00001D8E                          1176  
00001D8E  BABC 00000003           1177              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001D94  6700 004E               1178              BEQ     ADD_W_DesEA_M3
00001D98                          1179  
00001D98  BABC 00000004           1180              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001D9E  6700 0072               1181              BEQ     ADD_W_DesEA_M4
00001DA2                          1182  
00001DA2  BABC 00000007           1183              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001DA8  6700 009A               1184              BEQ     ADD_W_DesEA_M7
00001DAC                          1185  
00001DAC  4EF9 0000484E           1186              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001DB2                          1187  
00001DB2                          1188  ADD_W_DesEA_M2
00001DB2  7803                    1189              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001DB4  4EB9 00004856           1190              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001DBA  4EB9 00004A10           1191              JSR     PrintAdd
00001DC0  4EB9 00004B88           1192              JSR     LengthW
00001DC6  4EB9 00004BB6           1193              JSR     PrintSpace
00001DCC                          1194  
00001DCC  1E05                    1195              MOVE.B  D5,D7
00001DCE  1A00                    1196              MOVE.B  D0,D5
00001DD0  4EB9 000049D0           1197              JSR     PrintDataReg
00001DD6                          1198  
00001DD6  1A07                    1199              MOVE.B  D7,D5
00001DD8  12EE 0025               1200              MOVE.B  37(A6),(A1)+             *,
00001DDC  4EB9 000049E8           1201              JSR     PrintIndirAddrReg
00001DE2  4E75                    1202              RTS                     ; return to input to get more input
00001DE4                          1203  
00001DE4                          1204  ADD_W_DesEA_M3
00001DE4  7803                    1205              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001DE6  4EB9 00004856           1206              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001DEC  4EB9 00004A10           1207              JSR     PrintAdd
00001DF2  4EB9 00004B88           1208              JSR     LengthW
00001DF8  4EB9 00004BB6           1209              JSR     PrintSpace
00001DFE  4EB9 000049F6           1210              JSR     PrintPostIncAddrReg
00001E04                          1211  
00001E04  1A00                    1212              MOVE.B  D0,D5
00001E06  12EE 0025               1213              MOVE.B  37(A6),(A1)+             *,
00001E0A  4EB9 000049D0           1214              JSR     PrintDataReg
00001E10  4E75                    1215              RTS                     ; return to input to get more input
00001E12                          1216  
00001E12                          1217  ADD_W_DesEA_M4
00001E12  7803                    1218              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001E14  4EB9 00004856           1219              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001E1A  4EB9 00004A10           1220              JSR     PrintAdd
00001E20  4EB9 00004B88           1221              JSR     LengthW
00001E26  4EB9 00004BB6           1222              JSR     PrintSpace
00001E2C                          1223  
00001E2C  1E05                    1224              MOVE.B  D5,D7
00001E2E  1A00                    1225              MOVE.B  D0,D5
00001E30  4EB9 000049D0           1226              JSR     PrintDataReg
00001E36                          1227  
00001E36  1A07                    1228              MOVE.B  D7,D5
00001E38  12EE 0025               1229              MOVE.B  37(A6),(A1)+             *,
00001E3C  4EB9 00004A00           1230              JSR     PrintPreDeincAddrReg
00001E42  4E75                    1231              RTS                     ; return to input to get more input
00001E44                          1232  
00001E44                          1233  ADD_W_DesEA_M7
00001E44  7803                    1234              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001E46  4EB9 00004856           1235              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001E4C                          1236  
00001E4C  BABC 00000000           1237              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001E52  6700 0012               1238              BEQ     ADD_W_DesEA_xxxW
00001E56                          1239  
00001E56  BABC 00000001           1240              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001E5C  6700 0032               1241              BEQ     ADD_W_DesEA_xxxL
00001E60                          1242  
00001E60  4EF9 0000484E           1243              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001E66                          1244  
00001E66                          1245  ADD_W_DesEA_xxxW
00001E66  4EB9 00004A10           1246              JSR     PrintAdd
00001E6C  4EB9 00004B88           1247              JSR     LengthW
00001E72  4EB9 00004BB6           1248              JSR     PrintSpace
00001E78                          1249  
00001E78  1E05                    1250              MOVE.B  D5,D7
00001E7A  1A00                    1251              MOVE.B  D0,D5
00001E7C  4EB9 000049D0           1252              JSR     PrintDataReg
00001E82                          1253  
00001E82  1A07                    1254              MOVE.B  D7,D5
00001E84  12EE 0025               1255              MOVE.B  37(A6),(A1)+             *,
00001E88  4EB9 00004950           1256              JSR     PrintByteOrWord
00001E8E  4E75                    1257              RTS                     ; return to input to get more input
00001E90                          1258  
00001E90                          1259  ADD_W_DesEA_xxxL
00001E90  4EB9 00004A10           1260              JSR     PrintAdd
00001E96  4EB9 00004B88           1261              JSR     LengthW
00001E9C  4EB9 00004BB6           1262              JSR     PrintSpace
00001EA2                          1263  
00001EA2  1E05                    1264              MOVE.B  D5,D7
00001EA4  1A00                    1265              MOVE.B  D0,D5
00001EA6  4EB9 000049D0           1266              JSR     PrintDataReg
00001EAC                          1267  
00001EAC  1A07                    1268              MOVE.B  D7,D5
00001EAE  12EE 0025               1269              MOVE.B  37(A6),(A1)+             *,
00001EB2  4EB9 00004966           1270              JSR     PrintLong
00001EB8  4E75                    1271              RTS                     ; return to input to get more input
00001EBA                          1272  
00001EBA                          1273  ADD_L_DesEA
00001EBA  7803                    1274              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001EBC  4EB9 00004856           1275              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001EC2                          1276  
00001EC2  BABC 00000002           1277              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001EC8  6700 0026               1278              BEQ     ADD_L_DesEA_M2
00001ECC                          1279  
00001ECC  BABC 00000003           1280              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001ED2  6700 004E               1281              BEQ     ADD_L_DesEA_M3
00001ED6                          1282  
00001ED6  BABC 00000004           1283              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001EDC  6700 0072               1284              BEQ     ADD_L_DesEA_M4
00001EE0                          1285  
00001EE0  BABC 00000007           1286              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001EE6  6700 009A               1287              BEQ     ADD_L_DesEA_M7
00001EEA                          1288  
00001EEA  4EF9 0000484E           1289              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001EF0                          1290  
00001EF0                          1291  ADD_L_DesEA_M2
00001EF0  7803                    1292              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001EF2  4EB9 00004856           1293              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001EF8  4EB9 00004A10           1294              JSR     PrintAdd
00001EFE  4EB9 00004B92           1295              JSR     LengthL
00001F04  4EB9 00004BB6           1296              JSR     PrintSpace
00001F0A                          1297  
00001F0A  1E05                    1298              MOVE.B  D5,D7
00001F0C  1A00                    1299              MOVE.B  D0,D5
00001F0E  4EB9 000049D0           1300              JSR     PrintDataReg
00001F14                          1301  
00001F14  1A07                    1302              MOVE.B  D7,D5
00001F16  12EE 0025               1303              MOVE.B  37(A6),(A1)+             *,
00001F1A  4EB9 000049E8           1304              JSR     PrintIndirAddrReg
00001F20  4E75                    1305              RTS                     ; return to input to get more input
00001F22                          1306  
00001F22                          1307  ADD_L_DesEA_M3
00001F22  7803                    1308              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001F24  4EB9 00004856           1309              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001F2A  4EB9 00004A10           1310              JSR     PrintAdd
00001F30  4EB9 00004B92           1311              JSR     LengthL
00001F36  4EB9 00004BB6           1312              JSR     PrintSpace
00001F3C  4EB9 000049F6           1313              JSR     PrintPostIncAddrReg
00001F42                          1314  
00001F42  1A00                    1315              MOVE.B  D0,D5
00001F44  12EE 0025               1316              MOVE.B  37(A6),(A1)+             *,
00001F48  4EB9 000049D0           1317              JSR     PrintDataReg
00001F4E  4E75                    1318              RTS                     ; return to input to get more input
00001F50                          1319  
00001F50                          1320  ADD_L_DesEA_M4
00001F50  7803                    1321              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001F52  4EB9 00004856           1322              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001F58  4EB9 00004A10           1323              JSR     PrintAdd
00001F5E  4EB9 00004B92           1324              JSR     LengthL
00001F64  4EB9 00004BB6           1325              JSR     PrintSpace
00001F6A                          1326  
00001F6A  1E05                    1327              MOVE.B  D5,D7
00001F6C  1A00                    1328              MOVE.B  D0,D5
00001F6E  4EB9 000049D0           1329              JSR     PrintDataReg
00001F74                          1330  
00001F74  1A07                    1331              MOVE.B  D7,D5
00001F76  12EE 0025               1332              MOVE.B  37(A6),(A1)+             *,
00001F7A  4EB9 00004A00           1333              JSR     PrintPreDeincAddrReg
00001F80  4E75                    1334              RTS                     ; return to input to get more input
00001F82                          1335  
00001F82                          1336  ADD_L_DesEA_M7
00001F82  7803                    1337              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001F84  4EB9 00004856           1338              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001F8A                          1339  
00001F8A  BABC 00000000           1340              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001F90  6700 0012               1341              BEQ     ADD_L_DesEA_xxxW
00001F94                          1342  
00001F94  BABC 00000001           1343              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001F9A  6700 0032               1344              BEQ     ADD_L_DesEA_xxxL
00001F9E                          1345  
00001F9E  4EF9 0000484E           1346              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001FA4                          1347  
00001FA4                          1348  ADD_L_DesEA_xxxW
00001FA4  4EB9 00004A10           1349              JSR     PrintAdd
00001FAA  4EB9 00004B92           1350              JSR     LengthL
00001FB0  4EB9 00004BB6           1351              JSR     PrintSpace
00001FB6                          1352  
00001FB6  1E05                    1353              MOVE.B  D5,D7
00001FB8  1A00                    1354              MOVE.B  D0,D5
00001FBA  4EB9 000049D0           1355              JSR     PrintDataReg
00001FC0                          1356  
00001FC0  1A07                    1357              MOVE.B  D7,D5
00001FC2  12EE 0025               1358              MOVE.B  37(A6),(A1)+             *,
00001FC6  4EB9 00004950           1359              JSR     PrintByteOrWord
00001FCC  4E75                    1360              RTS                     ; return to input to get more input
00001FCE                          1361  
00001FCE                          1362  ADD_L_DesEA_xxxL
00001FCE  4EB9 00004A10           1363              JSR     PrintAdd
00001FD4  4EB9 00004B92           1364              JSR     LengthL
00001FDA  4EB9 00004BB6           1365              JSR     PrintSpace
00001FE0                          1366  
00001FE0  1E05                    1367              MOVE.B  D5,D7
00001FE2  1A00                    1368              MOVE.B  D0,D5
00001FE4  4EB9 000049D0           1369              JSR     PrintDataReg
00001FEA                          1370  
00001FEA  1A07                    1371              MOVE.B  D7,D5
00001FEC  12EE 0025               1372              MOVE.B  37(A6),(A1)+             *,
00001FF0  4EB9 00004966           1373              JSR     PrintLong
00001FF6  4E75                    1374              RTS                     ; return to input to get more input
00001FF8                          1375  
00001FF8                          1376  
00001FF8                          1377  *************************************************                MULS_W_AND_Opcode          *************************************************
00001FF8                          1378  ; first four bit is (1100 #### #### ####)
00001FF8                          1379  MULS_W_AND_Opcode
00001FF8  7803                    1380              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00001FFA  4EB9 00004856           1381              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00002000                          1382  
00002000  2005                    1383              MOVE.L  D5,D0               ; D0 will hold the register
00002002                          1384          ; D0 will hold the register (position 11-9)
00002002                          1385  
00002002  7803                    1386              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00002004  4EB9 00004856           1387              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the opmode, and opcode
0000200A                          1388  
0000200A  BABC 00000000           1389              CMP.L   #0,D5               ; if opmode is 0, it is a byte with location specified is a source  (<ea> ^ Dn -> Dn)
00002010  6700 0044               1390              BEQ     And_B_SrcEA
00002014                          1391  
00002014  BABC 00000001           1392              CMP.L   #1,D5               ; if opmode is 1, it is a word with location specified is a source  (<ea> ^ Dn -> Dn)
0000201A  6700 01D0               1393              BEQ     And_W_SrcEA
0000201E                          1394  
0000201E  BABC 00000002           1395              CMP.L   #2,D5               ; if opmode is 2, it is a long with location specified is a source  (<ea> ^ Dn -> Dn)
00002024  6700 035C               1396              BEQ     And_L_SrcEA
00002028                          1397  
00002028  BABC 00000004           1398              CMP.L   #4,D5               ; if opmode is 4, it is a byte with location specified is desination (Dn ^ <ea> -> <ea>)
0000202E  6700 04E8               1399              BEQ     And_B_DesEA
00002032                          1400  
00002032  BABC 00000005           1401              CMP.L   #5,D5               ; if opmode is 5, it is a word with location specified is desination (Dn ^ <ea> -> <ea>)
00002038  6700 0620               1402              BEQ     And_W_DesEA
0000203C                          1403  
0000203C  BABC 00000006           1404              CMP.L   #6,D5               ; if opmode is 6, it is a long with location specified is desination (Dn ^ <ea> -> <ea>)
00002042  6700 0758               1405              BEQ     And_L_DesEA
00002046                          1406  
00002046  BABC 00000007           1407              CMP.L   #7,D5               ; if opmode is 7, the opcode is MULS.W
0000204C  6700 0890               1408              BEQ     MULS_W
00002050                          1409  
00002050  4EF9 0000484E           1410              JMP     InvalidOpcode       ; it is not valid since it is not one of the valid opmode
00002056                          1411  
00002056  7803                    1412  And_B_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002058  4EB9 00004856           1413              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
0000205E                          1414  
0000205E  BABC 00000000           1415              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002064  6700 0030               1416              BEQ     And_B_SrcEA_M0
00002068                          1417  
00002068  BABC 00000002           1418              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
0000206E  6700 0054               1419              BEQ     And_B_SrcEA_M2
00002072                          1420  
00002072  BABC 00000003           1421              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002078  6700 0078               1422              BEQ     And_B_SrcEA_M3
0000207C                          1423  
0000207C  BABC 00000004           1424              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002082  6700 009C               1425              BEQ     And_B_SrcEA_M4
00002086                          1426  
00002086  BABC 00000007           1427              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
0000208C  6700 00C0               1428              BEQ     And_B_SrcEA_M7
00002090                          1429  
00002090  4EF9 0000484E           1430              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002096                          1431  
00002096                          1432  And_B_SrcEA_M0
00002096  7803                    1433              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002098  4EB9 00004856           1434              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000209E  4EB9 00004A32           1435              JSR     PrintAnd
000020A4  4EB9 00004B7E           1436              JSR     LengthB
000020AA  4EB9 00004BB6           1437              JSR     PrintSpace
000020B0  4EB9 000049D0           1438              JSR     PrintDataReg
000020B6                          1439  
000020B6  1A00                    1440              MOVE.B  D0,D5
000020B8  12EE 0025               1441              MOVE.B  37(A6),(A1)+             *,
000020BC  4EB9 000049D0           1442              JSR     PrintDataReg
000020C2  4E75                    1443              RTS                     ; return to input to get more input
000020C4                          1444  
000020C4                          1445  And_B_SrcEA_M2
000020C4  7803                    1446              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000020C6  4EB9 00004856           1447              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000020CC  4EB9 00004A32           1448              JSR     PrintAnd
000020D2  4EB9 00004B7E           1449              JSR     LengthB
000020D8  4EB9 00004BB6           1450              JSR     PrintSpace
000020DE  4EB9 000049E8           1451              JSR     PrintIndirAddrReg
000020E4                          1452  
000020E4  1A00                    1453              MOVE.B  D0,D5
000020E6  12EE 0025               1454              MOVE.B  37(A6),(A1)+             *,
000020EA  4EB9 000049D0           1455              JSR     PrintDataReg
000020F0  4E75                    1456              RTS                     ; return to input to get more input
000020F2                          1457  
000020F2                          1458  And_B_SrcEA_M3
000020F2  7803                    1459              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000020F4  4EB9 00004856           1460              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000020FA  4EB9 00004A32           1461              JSR     PrintAnd
00002100  4EB9 00004B7E           1462              JSR     LengthB
00002106  4EB9 00004BB6           1463              JSR     PrintSpace
0000210C  4EB9 000049F6           1464              JSR     PrintPostIncAddrReg
00002112                          1465  
00002112  1A00                    1466              MOVE.B  D0,D5
00002114  12EE 0025               1467              MOVE.B  37(A6),(A1)+             *,
00002118  4EB9 000049D0           1468              JSR     PrintDataReg
0000211E  4E75                    1469              RTS                     ; return to input to get more input
00002120                          1470  
00002120                          1471  And_B_SrcEA_M4
00002120  7803                    1472              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002122  4EB9 00004856           1473              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002128  4EB9 00004A32           1474              JSR     PrintAnd
0000212E  4EB9 00004B7E           1475              JSR     LengthB
00002134  4EB9 00004BB6           1476              JSR     PrintSpace
0000213A  4EB9 00004A00           1477              JSR     PrintPreDeincAddrReg
00002140                          1478  
00002140  1A00                    1479              MOVE.B  D0,D5
00002142  12EE 0025               1480              MOVE.B  37(A6),(A1)+             *,
00002146  4EB9 000049D0           1481              JSR     PrintDataReg
0000214C  4E75                    1482              RTS                     ; return to input to get more input
0000214E                          1483  
0000214E                          1484  And_B_SrcEA_M7
0000214E  7803                    1485              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002150  4EB9 00004856           1486              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002156                          1487  
00002156  BABC 00000000           1488              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
0000215C  6700 001C               1489              BEQ     And_B_SrcEA_xxxW
00002160                          1490  
00002160  BABC 00000001           1491              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002166  6700 0038               1492              BEQ     And_B_SrcEA_xxxL
0000216A                          1493  
0000216A  BABC 00000004           1494              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002170  6700 0054               1495              BEQ     And_B_SrcEA_Data
00002174                          1496  
00002174  4EF9 0000484E           1497              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000217A                          1498  
0000217A                          1499  And_B_SrcEA_xxxW
0000217A  4EB9 00004A32           1500              JSR     PrintAnd
00002180  4EB9 00004B7E           1501              JSR     LengthB
00002186  4EB9 00004BB6           1502              JSR     PrintSpace
0000218C  4EB9 00004950           1503              JSR     PrintByteOrWord
00002192                          1504  
00002192  1A00                    1505              MOVE.B  D0,D5
00002194  12EE 0025               1506              MOVE.B  37(A6),(A1)+             *,
00002198  4EB9 000049D0           1507              JSR     PrintDataReg
0000219E  4E75                    1508              RTS                     ; return to input to get more input
000021A0                          1509  
000021A0                          1510  And_B_SrcEA_xxxL
000021A0  4EB9 00004A32           1511              JSR     PrintAnd
000021A6  4EB9 00004B7E           1512              JSR     LengthB
000021AC  4EB9 00004BB6           1513              JSR     PrintSpace
000021B2  4EB9 00004966           1514              JSR     PrintLong
000021B8                          1515  
000021B8  1A00                    1516              MOVE.B  D0,D5
000021BA  12EE 0025               1517              MOVE.B  37(A6),(A1)+             *,
000021BE  4EB9 000049D0           1518              JSR     PrintDataReg
000021C4  4E75                    1519              RTS                     ; return to input to get more input
000021C6                          1520  
000021C6                          1521  And_B_SrcEA_Data
000021C6  4EB9 00004A32           1522              JSR     PrintAnd
000021CC  4EB9 00004B7E           1523              JSR     LengthB
000021D2  4EB9 00004BB6           1524              JSR     PrintSpace
000021D8  4EB9 00004944           1525              JSR     PrintImmediateData
000021DE                          1526  
000021DE  1A00                    1527              MOVE.B  D0,D5
000021E0  12EE 0025               1528              MOVE.B  37(A6),(A1)+             *,
000021E4  4EB9 000049D0           1529              JSR     PrintDataReg
000021EA  4E75                    1530              RTS                     ; return to input to get more input
000021EC                          1531  
000021EC  7803                    1532  And_W_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000021EE  4EB9 00004856           1533              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000021F4                          1534  
000021F4  BABC 00000000           1535              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000021FA  6700 0030               1536              BEQ     And_W_SrcEA_M0
000021FE                          1537  
000021FE  BABC 00000002           1538              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002204  6700 0054               1539              BEQ     And_W_SrcEA_M2
00002208                          1540  
00002208  BABC 00000003           1541              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
0000220E  6700 0078               1542              BEQ     And_W_SrcEA_M3
00002212                          1543  
00002212  BABC 00000004           1544              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002218  6700 009C               1545              BEQ     And_W_SrcEA_M4
0000221C                          1546  
0000221C  BABC 00000007           1547              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002222  6700 00C0               1548              BEQ     And_W_SrcEA_M7
00002226                          1549  
00002226  4EF9 0000484E           1550              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000222C                          1551  
0000222C                          1552  And_W_SrcEA_M0
0000222C  7803                    1553              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000222E  4EB9 00004856           1554              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002234  4EB9 00004A32           1555              JSR     PrintAnd
0000223A  4EB9 00004B88           1556              JSR     LengthW
00002240  4EB9 00004BB6           1557              JSR     PrintSpace
00002246  4EB9 000049D0           1558              JSR     PrintDataReg
0000224C                          1559  
0000224C  1A00                    1560              MOVE.B  D0,D5
0000224E  12EE 0025               1561              MOVE.B  37(A6),(A1)+             *,
00002252  4EB9 000049D0           1562              JSR     PrintDataReg
00002258  4E75                    1563              RTS                     ; return to input to get more input
0000225A                          1564  
0000225A                          1565  And_W_SrcEA_M2
0000225A  7803                    1566              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000225C  4EB9 00004856           1567              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002262  4EB9 00004A32           1568              JSR     PrintAnd
00002268  4EB9 00004B88           1569              JSR     LengthW
0000226E  4EB9 00004BB6           1570              JSR     PrintSpace
00002274  4EB9 000049E8           1571              JSR     PrintIndirAddrReg
0000227A                          1572  
0000227A  1A00                    1573              MOVE.B  D0,D5
0000227C  12EE 0025               1574              MOVE.B  37(A6),(A1)+             *,
00002280  4EB9 000049D0           1575              JSR     PrintDataReg
00002286  4E75                    1576              RTS                     ; return to input to get more input
00002288                          1577  
00002288                          1578  And_W_SrcEA_M3
00002288  7803                    1579              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000228A  4EB9 00004856           1580              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002290  4EB9 00004A32           1581              JSR     PrintAnd
00002296  4EB9 00004B88           1582              JSR     LengthW
0000229C  4EB9 00004BB6           1583              JSR     PrintSpace
000022A2  4EB9 000049F6           1584              JSR     PrintPostIncAddrReg
000022A8                          1585  
000022A8  1A00                    1586              MOVE.B  D0,D5
000022AA  12EE 0025               1587              MOVE.B  37(A6),(A1)+             *,
000022AE  4EB9 000049D0           1588              JSR     PrintDataReg
000022B4  4E75                    1589              RTS                     ; return to input to get more input
000022B6                          1590  
000022B6                          1591  And_W_SrcEA_M4
000022B6  7803                    1592              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000022B8  4EB9 00004856           1593              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000022BE  4EB9 00004A32           1594              JSR     PrintAnd
000022C4  4EB9 00004B88           1595              JSR     LengthW
000022CA  4EB9 00004BB6           1596              JSR     PrintSpace
000022D0  4EB9 00004A00           1597              JSR     PrintPreDeincAddrReg
000022D6                          1598  
000022D6  1A00                    1599              MOVE.B  D0,D5
000022D8  12EE 0025               1600              MOVE.B  37(A6),(A1)+             *,
000022DC  4EB9 000049D0           1601              JSR     PrintDataReg
000022E2  4E75                    1602              RTS                     ; return to input to get more input
000022E4                          1603  
000022E4                          1604  And_W_SrcEA_M7
000022E4  7803                    1605              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000022E6  4EB9 00004856           1606              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000022EC                          1607  
000022EC  BABC 00000000           1608              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000022F2  6700 001C               1609              BEQ     And_W_SrcEA_xxxW
000022F6                          1610  
000022F6  BABC 00000001           1611              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000022FC  6700 0038               1612              BEQ     And_W_SrcEA_xxxL
00002300                          1613  
00002300  BABC 00000004           1614              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002306  6700 0054               1615              BEQ     And_W_SrcEA_Data
0000230A                          1616  
0000230A  4EF9 0000484E           1617              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002310                          1618  
00002310                          1619  And_W_SrcEA_xxxW
00002310  4EB9 00004A32           1620              JSR     PrintAnd
00002316  4EB9 00004B88           1621              JSR     LengthW
0000231C  4EB9 00004BB6           1622              JSR     PrintSpace
00002322  4EB9 00004950           1623              JSR     PrintByteOrWord
00002328                          1624  
00002328  1A00                    1625              MOVE.B  D0,D5
0000232A  12EE 0025               1626              MOVE.B  37(A6),(A1)+             *,
0000232E  4EB9 000049D0           1627              JSR     PrintDataReg
00002334  4E75                    1628              RTS                     ; return to input to get more input
00002336                          1629  
00002336                          1630  And_W_SrcEA_xxxL
00002336  4EB9 00004A32           1631              JSR     PrintAnd
0000233C  4EB9 00004B88           1632              JSR     LengthW
00002342  4EB9 00004BB6           1633              JSR     PrintSpace
00002348  4EB9 00004966           1634              JSR     PrintLong
0000234E                          1635  
0000234E  1A00                    1636              MOVE.B  D0,D5
00002350  12EE 0025               1637              MOVE.B  37(A6),(A1)+             *,
00002354  4EB9 000049D0           1638              JSR     PrintDataReg
0000235A  4E75                    1639              RTS                     ; return to input to get more input
0000235C                          1640  
0000235C                          1641  And_W_SrcEA_Data
0000235C  4EB9 00004A32           1642              JSR     PrintAnd
00002362  4EB9 00004B88           1643              JSR     LengthW
00002368  4EB9 00004BB6           1644              JSR     PrintSpace
0000236E  4EB9 00004944           1645              JSR     PrintImmediateData
00002374                          1646  
00002374  1A00                    1647              MOVE.B  D0,D5
00002376  12EE 0025               1648              MOVE.B  37(A6),(A1)+             *,
0000237A  4EB9 000049D0           1649              JSR     PrintDataReg
00002380  4E75                    1650              RTS                     ; return to input to get more input
00002382                          1651  
00002382  7803                    1652  And_L_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002384  4EB9 00004856           1653              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
0000238A                          1654  
0000238A  BABC 00000000           1655              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002390  6700 0030               1656              BEQ     And_L_SrcEA_M0
00002394                          1657  
00002394  BABC 00000002           1658              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
0000239A  6700 0054               1659              BEQ     And_L_SrcEA_M2
0000239E                          1660  
0000239E  BABC 00000003           1661              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000023A4  6700 0078               1662              BEQ     And_L_SrcEA_M3
000023A8                          1663  
000023A8  BABC 00000004           1664              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000023AE  6700 009C               1665              BEQ     And_L_SrcEA_M4
000023B2                          1666  
000023B2  BABC 00000007           1667              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000023B8  6700 00C0               1668              BEQ     And_L_SrcEA_M7
000023BC                          1669  
000023BC  4EF9 0000484E           1670              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000023C2                          1671  
000023C2                          1672  And_L_SrcEA_M0
000023C2  7803                    1673              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000023C4  4EB9 00004856           1674              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000023CA  4EB9 00004A32           1675              JSR     PrintAnd
000023D0  4EB9 00004B92           1676              JSR     LengthL
000023D6  4EB9 00004BB6           1677              JSR     PrintSpace
000023DC  4EB9 000049D0           1678              JSR     PrintDataReg
000023E2                          1679  
000023E2  1A00                    1680              MOVE.B  D0,D5
000023E4  12EE 0025               1681              MOVE.B  37(A6),(A1)+             *,
000023E8  4EB9 000049D0           1682              JSR     PrintDataReg
000023EE  4E75                    1683              RTS                     ; return to input to get more input
000023F0                          1684  
000023F0                          1685  And_L_SrcEA_M2
000023F0  7803                    1686              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000023F2  4EB9 00004856           1687              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000023F8  4EB9 00004A32           1688              JSR     PrintAnd
000023FE  4EB9 00004B92           1689              JSR     LengthL
00002404  4EB9 00004BB6           1690              JSR     PrintSpace
0000240A  4EB9 000049E8           1691              JSR     PrintIndirAddrReg
00002410                          1692  
00002410  1A00                    1693              MOVE.B  D0,D5
00002412  12EE 0025               1694              MOVE.B  37(A6),(A1)+             *,
00002416  4EB9 000049D0           1695              JSR     PrintDataReg
0000241C  4E75                    1696              RTS                     ; return to input to get more input
0000241E                          1697  
0000241E                          1698  And_L_SrcEA_M3
0000241E  7803                    1699              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002420  4EB9 00004856           1700              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002426  4EB9 00004A32           1701              JSR     PrintAnd
0000242C  4EB9 00004B92           1702              JSR     LengthL
00002432  4EB9 00004BB6           1703              JSR     PrintSpace
00002438  4EB9 000049F6           1704              JSR     PrintPostIncAddrReg
0000243E                          1705  
0000243E  1A00                    1706              MOVE.B  D0,D5
00002440  12EE 0025               1707              MOVE.B  37(A6),(A1)+             *,
00002444  4EB9 000049D0           1708              JSR     PrintDataReg
0000244A  4E75                    1709              RTS                     ; return to input to get more input
0000244C                          1710  
0000244C                          1711  And_L_SrcEA_M4
0000244C  7803                    1712              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000244E  4EB9 00004856           1713              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002454  4EB9 00004A32           1714              JSR     PrintAnd
0000245A  4EB9 00004B92           1715              JSR     LengthL
00002460  4EB9 00004BB6           1716              JSR     PrintSpace
00002466  4EB9 00004A00           1717              JSR     PrintPreDeincAddrReg
0000246C                          1718  
0000246C  1A00                    1719              MOVE.B  D0,D5
0000246E  12EE 0025               1720              MOVE.B  37(A6),(A1)+             *,
00002472  4EB9 000049D0           1721              JSR     PrintDataReg
00002478  4E75                    1722              RTS                     ; return to input to get more input
0000247A                          1723  
0000247A                          1724  And_L_SrcEA_M7
0000247A  7803                    1725              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000247C  4EB9 00004856           1726              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002482                          1727  
00002482  BABC 00000000           1728              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002488  6700 001C               1729              BEQ     And_L_SrcEA_xxxW
0000248C                          1730  
0000248C  BABC 00000001           1731              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002492  6700 0038               1732              BEQ     And_L_SrcEA_xxxL
00002496                          1733  
00002496  BABC 00000004           1734              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
0000249C  6700 0054               1735              BEQ     And_L_SrcEA_Data
000024A0                          1736  
000024A0  4EF9 0000484E           1737              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000024A6                          1738  
000024A6                          1739  And_L_SrcEA_xxxW
000024A6  4EB9 00004A32           1740              JSR     PrintAnd
000024AC  4EB9 00004B92           1741              JSR     LengthL
000024B2  4EB9 00004BB6           1742              JSR     PrintSpace
000024B8  4EB9 00004950           1743              JSR     PrintByteOrWord
000024BE                          1744  
000024BE  1A00                    1745              MOVE.B  D0,D5
000024C0  12EE 0025               1746              MOVE.B  37(A6),(A1)+             *,
000024C4  4EB9 000049D0           1747              JSR     PrintDataReg
000024CA  4E75                    1748              RTS                     ; return to input to get more input
000024CC                          1749  
000024CC                          1750  And_L_SrcEA_xxxL
000024CC  4EB9 00004A32           1751              JSR     PrintAnd
000024D2  4EB9 00004B92           1752              JSR     LengthL
000024D8  4EB9 00004BB6           1753              JSR     PrintSpace
000024DE  4EB9 00004966           1754              JSR     PrintLong
000024E4                          1755  
000024E4  1A00                    1756              MOVE.B  D0,D5
000024E6  12EE 0025               1757              MOVE.B  37(A6),(A1)+             *,
000024EA  4EB9 000049D0           1758              JSR     PrintDataReg
000024F0  4E75                    1759              RTS                     ; return to input to get more input
000024F2                          1760  
000024F2                          1761  And_L_SrcEA_Data
000024F2  4EB9 00004A32           1762              JSR     PrintAnd
000024F8  4EB9 00004B92           1763              JSR     LengthL
000024FE  4EB9 00004BB6           1764              JSR     PrintSpace
00002504  4EB9 00004944           1765              JSR     PrintImmediateData
0000250A                          1766  
0000250A  1A00                    1767              MOVE.B  D0,D5
0000250C  12EE 0025               1768              MOVE.B  37(A6),(A1)+             *,
00002510  4EB9 000049D0           1769              JSR     PrintDataReg
00002516  4E75                    1770              RTS                     ; return to input to get more input
00002518                          1771  
00002518  7803                    1772  And_B_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000251A  4EB9 00004856           1773              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002520                          1774  
00002520  BABC 00000002           1775              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002526  6700 0026               1776              BEQ     And_B_DesEA_M2
0000252A                          1777  
0000252A  BABC 00000003           1778              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002530  6700 004E               1779              BEQ     And_B_DesEA_M3
00002534                          1780  
00002534  BABC 00000004           1781              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000253A  6700 0076               1782              BEQ     And_B_DesEA_M4
0000253E                          1783  
0000253E  BABC 00000007           1784              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002544  6700 009E               1785              BEQ     And_B_DesEA_M7
00002548                          1786  
00002548  4EF9 0000484E           1787              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000254E                          1788  
0000254E                          1789  And_B_DesEA_M2
0000254E  7803                    1790              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002550  4EB9 00004856           1791              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002556  4EB9 00004A32           1792              JSR     PrintAnd
0000255C  4EB9 00004B7E           1793              JSR     LengthB
00002562  4EB9 00004BB6           1794              JSR     PrintSpace
00002568                          1795  
00002568  1E05                    1796              MOVE.B  D5,D7
0000256A  1A00                    1797              MOVE.B  D0,D5
0000256C  4EB9 000049D0           1798              JSR     PrintDataReg
00002572                          1799  
00002572  1A07                    1800              MOVE.B  D7,D5
00002574  12EE 0025               1801              MOVE.B  37(A6),(A1)+             *,
00002578  4EB9 000049E8           1802              JSR     PrintIndirAddrReg
0000257E  4E75                    1803              RTS                     ; return to input to get more input
00002580                          1804  
00002580                          1805  And_B_DesEA_M3
00002580  7803                    1806              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002582  4EB9 00004856           1807              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002588  4EB9 00004A32           1808              JSR     PrintAnd
0000258E  4EB9 00004B7E           1809              JSR     LengthB
00002594  4EB9 00004BB6           1810              JSR     PrintSpace
0000259A                          1811  
0000259A  1E05                    1812              MOVE.B  D5,D7
0000259C  1A00                    1813              MOVE.B  D0,D5
0000259E  4EB9 000049D0           1814              JSR     PrintDataReg
000025A4                          1815  
000025A4  1A07                    1816              MOVE.B  D7,D5
000025A6  12EE 0025               1817              MOVE.B  37(A6),(A1)+             *,
000025AA  4EB9 000049F6           1818              JSR     PrintPostIncAddrReg
000025B0  4E75                    1819              RTS                     ; return to input to get more input
000025B2                          1820  
000025B2                          1821  And_B_DesEA_M4
000025B2  7803                    1822              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000025B4  4EB9 00004856           1823              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000025BA  4EB9 00004A32           1824              JSR     PrintAnd
000025C0  4EB9 00004B7E           1825              JSR     LengthB
000025C6  4EB9 00004BB6           1826              JSR     PrintSpace
000025CC                          1827  
000025CC  1E05                    1828              MOVE.B  D5,D7
000025CE  1A00                    1829              MOVE.B  D0,D5
000025D0  4EB9 000049D0           1830              JSR     PrintDataReg
000025D6                          1831  
000025D6  1A07                    1832              MOVE.B  D7,D5
000025D8  12EE 0025               1833              MOVE.B  37(A6),(A1)+             *,
000025DC  4EB9 00004A00           1834              JSR     PrintPreDeincAddrReg
000025E2  4E75                    1835              RTS                     ; return to input to get more input
000025E4                          1836  
000025E4                          1837  And_B_DesEA_M7
000025E4  7803                    1838              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000025E6  4EB9 00004856           1839              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000025EC                          1840  
000025EC  BABC 00000000           1841              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000025F2  6700 0012               1842              BEQ     And_B_DesEA_xxxW
000025F6                          1843  
000025F6  BABC 00000001           1844              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000025FC  6700 0032               1845              BEQ     And_B_DesEA_xxxL
00002600                          1846  
00002600  4EF9 0000484E           1847              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002606                          1848  
00002606                          1849  And_B_DesEA_xxxW
00002606  4EB9 00004A32           1850              JSR     PrintAnd
0000260C  4EB9 00004B7E           1851              JSR     LengthB
00002612  4EB9 00004BB6           1852              JSR     PrintSpace
00002618                          1853  
00002618  1E05                    1854              MOVE.B  D5,D7
0000261A  1A00                    1855              MOVE.B  D0,D5
0000261C  4EB9 000049D0           1856              JSR     PrintDataReg
00002622                          1857  
00002622  1A07                    1858              MOVE.B  D7,D5
00002624  12EE 0025               1859              MOVE.B  37(A6),(A1)+             *,
00002628  4EB9 00004950           1860              JSR     PrintByteOrWord
0000262E  4E75                    1861              RTS                     ; return to input to get more input
00002630                          1862  
00002630                          1863  And_B_DesEA_xxxL
00002630  4EB9 00004A32           1864              JSR     PrintAnd
00002636  4EB9 00004B7E           1865              JSR     LengthB
0000263C  4EB9 00004BB6           1866              JSR     PrintSpace
00002642                          1867  
00002642  1E05                    1868              MOVE.B  D5,D7
00002644  1A00                    1869              MOVE.B  D0,D5
00002646  4EB9 000049D0           1870              JSR     PrintDataReg
0000264C                          1871  
0000264C  1A07                    1872              MOVE.B  D7,D5
0000264E  12EE 0025               1873              MOVE.B  37(A6),(A1)+             *,
00002652  4EB9 00004966           1874              JSR     PrintLong
00002658  4E75                    1875              RTS                     ; return to input to get more input
0000265A                          1876  
0000265A  7803                    1877  And_W_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000265C  4EB9 00004856           1878              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002662                          1879  
00002662  BABC 00000002           1880              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002668  6700 0026               1881              BEQ     And_W_DesEA_M2
0000266C                          1882  
0000266C  BABC 00000003           1883              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002672  6700 004E               1884              BEQ     And_W_DesEA_M3
00002676                          1885  
00002676  BABC 00000004           1886              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000267C  6700 0076               1887              BEQ     And_W_DesEA_M4
00002680                          1888  
00002680  BABC 00000007           1889              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002686  6700 009E               1890              BEQ     And_W_DesEA_M7
0000268A                          1891  
0000268A  4EF9 0000484E           1892              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002690                          1893  
00002690                          1894  And_W_DesEA_M2
00002690  7803                    1895              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002692  4EB9 00004856           1896              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002698  4EB9 00004A32           1897              JSR     PrintAnd
0000269E  4EB9 00004B88           1898              JSR     LengthW
000026A4  4EB9 00004BB6           1899              JSR     PrintSpace
000026AA                          1900  
000026AA  1E05                    1901              MOVE.B  D5,D7
000026AC  1A00                    1902              MOVE.B  D0,D5
000026AE  4EB9 000049D0           1903              JSR     PrintDataReg
000026B4                          1904  
000026B4  1A07                    1905              MOVE.B  D7,D5
000026B6  12EE 0025               1906              MOVE.B  37(A6),(A1)+             *,
000026BA  4EB9 000049E8           1907              JSR     PrintIndirAddrReg
000026C0  4E75                    1908              RTS                     ; return to input to get more input
000026C2                          1909  
000026C2                          1910  And_W_DesEA_M3
000026C2  7803                    1911              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000026C4  4EB9 00004856           1912              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000026CA  4EB9 00004A32           1913              JSR     PrintAnd
000026D0  4EB9 00004B88           1914              JSR     LengthW
000026D6  4EB9 00004BB6           1915              JSR     PrintSpace
000026DC                          1916  
000026DC  1E05                    1917              MOVE.B  D5,D7
000026DE  1A00                    1918              MOVE.B  D0,D5
000026E0  4EB9 000049D0           1919              JSR     PrintDataReg
000026E6                          1920  
000026E6  1A07                    1921              MOVE.B  D7,D5
000026E8  12EE 0025               1922              MOVE.B  37(A6),(A1)+             *,
000026EC  4EB9 000049F6           1923              JSR     PrintPostIncAddrReg
000026F2  4E75                    1924              RTS                     ; return to input to get more input
000026F4                          1925  
000026F4                          1926  And_W_DesEA_M4
000026F4  7803                    1927              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000026F6  4EB9 00004856           1928              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000026FC  4EB9 00004A32           1929              JSR     PrintAnd
00002702  4EB9 00004B88           1930              JSR     LengthW
00002708  4EB9 00004BB6           1931              JSR     PrintSpace
0000270E                          1932  
0000270E  1E05                    1933              MOVE.B  D5,D7
00002710  1A00                    1934              MOVE.B  D0,D5
00002712  4EB9 000049D0           1935              JSR     PrintDataReg
00002718                          1936  
00002718  1A07                    1937              MOVE.B  D7,D5
0000271A  12EE 0025               1938              MOVE.B  37(A6),(A1)+             *,
0000271E  4EB9 00004A00           1939              JSR     PrintPreDeincAddrReg
00002724  4E75                    1940              RTS                     ; return to input to get more input
00002726                          1941  
00002726                          1942  And_W_DesEA_M7
00002726  7803                    1943              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002728  4EB9 00004856           1944              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000272E                          1945  
0000272E  BABC 00000000           1946              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002734  6700 0012               1947              BEQ     And_W_DesEA_xxxW
00002738                          1948  
00002738  BABC 00000001           1949              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
0000273E  6700 0032               1950              BEQ     And_W_DesEA_xxxL
00002742                          1951  
00002742  4EF9 0000484E           1952              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002748                          1953  
00002748                          1954  And_W_DesEA_xxxW
00002748  4EB9 00004A32           1955              JSR     PrintAnd
0000274E  4EB9 00004B88           1956              JSR     LengthW
00002754  4EB9 00004BB6           1957              JSR     PrintSpace
0000275A                          1958  
0000275A  1E05                    1959              MOVE.B  D5,D7
0000275C  1A00                    1960              MOVE.B  D0,D5
0000275E  4EB9 000049D0           1961              JSR     PrintDataReg
00002764                          1962  
00002764  1A07                    1963              MOVE.B  D7,D5
00002766  12EE 0025               1964              MOVE.B  37(A6),(A1)+             *,
0000276A  4EB9 00004950           1965              JSR     PrintByteOrWord
00002770  4E75                    1966              RTS                     ; return to input to get more input
00002772                          1967  
00002772                          1968  And_W_DesEA_xxxL
00002772  4EB9 00004A32           1969              JSR     PrintAnd
00002778  4EB9 00004B88           1970              JSR     LengthW
0000277E  4EB9 00004BB6           1971              JSR     PrintSpace
00002784                          1972  
00002784  1E05                    1973              MOVE.B  D5,D7
00002786  1A00                    1974              MOVE.B  D0,D5
00002788  4EB9 000049D0           1975              JSR     PrintDataReg
0000278E                          1976  
0000278E  1A07                    1977              MOVE.B  D7,D5
00002790  12EE 0025               1978              MOVE.B  37(A6),(A1)+             *,
00002794  4EB9 00004966           1979              JSR     PrintLong
0000279A  4E75                    1980              RTS                     ; return to input to get more input
0000279C                          1981  
0000279C  7803                    1982  And_L_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000279E  4EB9 00004856           1983              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000027A4                          1984  
000027A4  BABC 00000002           1985              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000027AA  6700 0026               1986              BEQ     And_L_DesEA_M2
000027AE                          1987  
000027AE  BABC 00000003           1988              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000027B4  6700 004E               1989              BEQ     And_L_DesEA_M3
000027B8                          1990  
000027B8  BABC 00000004           1991              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000027BE  6700 0076               1992              BEQ     And_L_DesEA_M4
000027C2                          1993  
000027C2  BABC 00000007           1994              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000027C8  6700 009E               1995              BEQ     And_L_DesEA_M7
000027CC                          1996  
000027CC  4EF9 0000484E           1997              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000027D2                          1998  
000027D2                          1999  And_L_DesEA_M2
000027D2  7803                    2000              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000027D4  4EB9 00004856           2001              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000027DA  4EB9 00004A32           2002              JSR     PrintAnd
000027E0  4EB9 00004B92           2003              JSR     LengthL
000027E6  4EB9 00004BB6           2004              JSR     PrintSpace
000027EC                          2005  
000027EC  1E05                    2006              MOVE.B  D5,D7
000027EE  1A00                    2007              MOVE.B  D0,D5
000027F0  4EB9 000049D0           2008              JSR     PrintDataReg
000027F6                          2009  
000027F6  1A07                    2010              MOVE.B  D7,D5
000027F8  12EE 0025               2011              MOVE.B  37(A6),(A1)+             *,
000027FC  4EB9 000049E8           2012              JSR     PrintIndirAddrReg
00002802  4E75                    2013              RTS                     ; return to input to get more input
00002804                          2014  
00002804                          2015  And_L_DesEA_M3
00002804  7803                    2016              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002806  4EB9 00004856           2017              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000280C  4EB9 00004A32           2018              JSR     PrintAnd
00002812  4EB9 00004B92           2019              JSR     LengthL
00002818  4EB9 00004BB6           2020              JSR     PrintSpace
0000281E                          2021  
0000281E  1E05                    2022              MOVE.B  D5,D7
00002820  1A00                    2023              MOVE.B  D0,D5
00002822  4EB9 000049D0           2024              JSR     PrintDataReg
00002828                          2025  
00002828  1A07                    2026              MOVE.B  D7,D5
0000282A  12EE 0025               2027              MOVE.B  37(A6),(A1)+             *,
0000282E  4EB9 000049F6           2028              JSR     PrintPostIncAddrReg
00002834  4E75                    2029              RTS                     ; return to input to get more input
00002836                          2030  
00002836                          2031  And_L_DesEA_M4
00002836  7803                    2032              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002838  4EB9 00004856           2033              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000283E  4EB9 00004A32           2034              JSR     PrintAnd
00002844  4EB9 00004B92           2035              JSR     LengthL
0000284A  4EB9 00004BB6           2036              JSR     PrintSpace
00002850                          2037  
00002850  1E05                    2038              MOVE.B  D5,D7
00002852  1A00                    2039              MOVE.B  D0,D5
00002854  4EB9 000049D0           2040              JSR     PrintDataReg
0000285A                          2041  
0000285A  1A07                    2042              MOVE.B  D7,D5
0000285C  12EE 0025               2043              MOVE.B  37(A6),(A1)+             *,
00002860  4EB9 00004A00           2044              JSR     PrintPreDeincAddrReg
00002866  4E75                    2045              RTS                     ; return to input to get more input
00002868                          2046  
00002868                          2047  And_L_DesEA_M7
00002868  7803                    2048              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000286A  4EB9 00004856           2049              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002870                          2050  
00002870  BABC 00000000           2051              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002876  6700 0012               2052              BEQ     And_L_DesEA_xxxW
0000287A                          2053  
0000287A  BABC 00000001           2054              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002880  6700 0032               2055              BEQ     And_L_DesEA_xxxL
00002884                          2056  
00002884  4EF9 0000484E           2057              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000288A                          2058  
0000288A                          2059  And_L_DesEA_xxxW
0000288A  4EB9 00004A32           2060              JSR     PrintAnd
00002890  4EB9 00004B92           2061              JSR     LengthL
00002896  4EB9 00004BB6           2062              JSR     PrintSpace
0000289C                          2063  
0000289C  1E05                    2064              MOVE.B  D5,D7
0000289E  1A00                    2065              MOVE.B  D0,D5
000028A0  4EB9 000049D0           2066              JSR     PrintDataReg
000028A6                          2067  
000028A6  1A07                    2068              MOVE.B  D7,D5
000028A8  12EE 0025               2069              MOVE.B  37(A6),(A1)+             *,
000028AC  4EB9 00004950           2070              JSR     PrintByteOrWord
000028B2  4E75                    2071              RTS                     ; return to input to get more input
000028B4                          2072  
000028B4                          2073  And_L_DesEA_xxxL
000028B4  4EB9 00004A32           2074              JSR     PrintAnd
000028BA  4EB9 00004B92           2075              JSR     LengthL
000028C0  4EB9 00004BB6           2076              JSR     PrintSpace
000028C6                          2077  
000028C6  1E05                    2078              MOVE.B  D5,D7
000028C8  1A00                    2079              MOVE.B  D0,D5
000028CA  4EB9 000049D0           2080              JSR     PrintDataReg
000028D0                          2081  
000028D0  1A07                    2082              MOVE.B  D7,D5
000028D2  12EE 0025               2083              MOVE.B  37(A6),(A1)+             *,
000028D6  4EB9 00004966           2084              JSR     PrintLong
000028DC  4E75                    2085              RTS                     ; return to input to get more input
000028DE                          2086  
000028DE  7803                    2087  MULS_W      MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000028E0  4EB9 00004856           2088              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000028E6                          2089  
000028E6  BABC 00000000           2090              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000028EC  6700 0030               2091              BEQ     MULS_W_M0
000028F0                          2092  
000028F0  BABC 00000002           2093              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000028F6  6700 0054               2094              BEQ     MULS_W_M2
000028FA                          2095  
000028FA  BABC 00000003           2096              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002900  6700 0078               2097              BEQ     MULS_W_M3
00002904                          2098  
00002904  BABC 00000004           2099              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000290A  6700 009C               2100              BEQ     MULS_W_M4
0000290E                          2101  
0000290E  BABC 00000007           2102              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002914  6700 00C0               2103              BEQ     MULS_W_M7
00002918                          2104  
00002918  4EF9 0000484E           2105              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000291E                          2106  
0000291E  7803                    2107  MULS_W_M0   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002920  4EB9 00004856           2108              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002926  4EB9 00004B0E           2109              JSR     PrintMuls
0000292C  4EB9 00004B88           2110              JSR     LengthW
00002932  4EB9 00004BB6           2111              JSR     PrintSpace
00002938  4EB9 000049D0           2112              JSR     PrintDataReg
0000293E                          2113  
0000293E  1A00                    2114              MOVE.B  D0,D5
00002940  12EE 0025               2115              MOVE.B  37(A6),(A1)+             *,
00002944  4EB9 000049D0           2116              JSR     PrintDataReg
0000294A  4E75                    2117              RTS                     ; return to input to get more input
0000294C                          2118  
0000294C  7803                    2119  MULS_W_M2   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000294E  4EB9 00004856           2120              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002954  4EB9 00004B0E           2121              JSR     PrintMuls
0000295A  4EB9 00004B88           2122              JSR     LengthW
00002960  4EB9 00004BB6           2123              JSR     PrintSpace
00002966  4EB9 000049E8           2124              JSR     PrintIndirAddrReg
0000296C                          2125  
0000296C  1A00                    2126              MOVE.B  D0,D5
0000296E  12EE 0025               2127              MOVE.B  37(A6),(A1)+             *,
00002972  4EB9 000049D0           2128              JSR     PrintDataReg
00002978  4E75                    2129              RTS                     ; return to input to get more input
0000297A                          2130  
0000297A  7803                    2131  MULS_W_M3   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000297C  4EB9 00004856           2132              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002982  4EB9 00004B0E           2133              JSR     PrintMuls
00002988  4EB9 00004B88           2134              JSR     LengthW
0000298E  4EB9 00004BB6           2135              JSR     PrintSpace
00002994  4EB9 000049F6           2136              JSR     PrintPostIncAddrReg
0000299A                          2137  
0000299A  1A00                    2138              MOVE.B  D0,D5
0000299C  12EE 0025               2139              MOVE.B  37(A6),(A1)+             *,
000029A0  4EB9 000049D0           2140              JSR     PrintDataReg
000029A6  4E75                    2141              RTS                     ; return to input to get more input
000029A8                          2142  
000029A8  7803                    2143  MULS_W_M4   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000029AA  4EB9 00004856           2144              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000029B0  4EB9 00004B0E           2145              JSR     PrintMuls
000029B6  4EB9 00004B88           2146              JSR     LengthW
000029BC  4EB9 00004BB6           2147              JSR     PrintSpace
000029C2  4EB9 00004A00           2148              JSR     PrintPreDeincAddrReg
000029C8                          2149  
000029C8  1A00                    2150              MOVE.B  D0,D5
000029CA  12EE 0025               2151              MOVE.B  37(A6),(A1)+             *,
000029CE  4EB9 000049D0           2152              JSR     PrintDataReg
000029D4  4E75                    2153              RTS                     ; return to input to get more input
000029D6                          2154  
000029D6  7803                    2155  MULS_W_M7   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000029D8  4EB9 00004856           2156              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000029DE                          2157  
000029DE  BABC 00000000           2158              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000029E4  6700 001C               2159              BEQ     MULS_W_xxxW
000029E8                          2160  
000029E8  BABC 00000001           2161              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000029EE  6700 0038               2162              BEQ     MULS_W_xxxL
000029F2                          2163  
000029F2  BABC 00000004           2164              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
000029F8  6700 0054               2165              BEQ     MULS_W_Data
000029FC                          2166  
000029FC  4EF9 0000484E           2167              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002A02                          2168  
00002A02                          2169  MULS_W_xxxW
00002A02  4EB9 00004B0E           2170              JSR     PrintMuls
00002A08  4EB9 00004B88           2171              JSR     LengthW
00002A0E  4EB9 00004BB6           2172              JSR     PrintSpace
00002A14  4EB9 00004950           2173              JSR     PrintByteOrWord
00002A1A                          2174  
00002A1A  1A00                    2175              MOVE.B  D0,D5
00002A1C  12EE 0025               2176              MOVE.B  37(A6),(A1)+             *,
00002A20  4EB9 000049D0           2177              JSR     PrintDataReg
00002A26  4E75                    2178              RTS                     ; return to input to get more input
00002A28                          2179  
00002A28                          2180  MULS_W_xxxL
00002A28  4EB9 00004B0E           2181              JSR     PrintMuls
00002A2E  4EB9 00004B88           2182              JSR     LengthW
00002A34  4EB9 00004BB6           2183              JSR     PrintSpace
00002A3A  4EB9 00004966           2184              JSR     PrintLong
00002A40                          2185  
00002A40  1A00                    2186              MOVE.B  D0,D5
00002A42  12EE 0025               2187              MOVE.B  37(A6),(A1)+             *,
00002A46  4EB9 000049D0           2188              JSR     PrintDataReg
00002A4C  4E75                    2189              RTS                     ; return to input to get more input
00002A4E                          2190  
00002A4E                          2191  MULS_W_Data
00002A4E  4EB9 00004B0E           2192              JSR     PrintMuls
00002A54  4EB9 00004B88           2193              JSR     LengthW
00002A5A  4EB9 00004BB6           2194              JSR     PrintSpace
00002A60  4EB9 00004944           2195              JSR     PrintImmediateData
00002A66                          2196  
00002A66  1A00                    2197              MOVE.B  D0,D5
00002A68  12EE 0025               2198              MOVE.B  37(A6),(A1)+             *,
00002A6C  4EB9 000049D0           2199              JSR     PrintDataReg
00002A72  4E75                    2200              RTS                     ; return to input to get more input
00002A74                          2201  
00002A74                          2202  *************************************************                SUB_Opcode                 *************************************************
00002A74                          2203  ; first four bit is (1001 #### #### ####)
00002A74  7803                    2204  SUB_Opcode  MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00002A76  4EB9 00004856           2205              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00002A7C                          2206  
00002A7C  2005                    2207              MOVE.L  D5,D0               ; D0 will hold the register
00002A7E                          2208          ; D0 will hold the register (position 11-9)
00002A7E                          2209  
00002A7E  7803                    2210              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00002A80  4EB9 00004856           2211              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the opmode
00002A86                          2212  
00002A86  BABC 00000000           2213              CMP.L   #0,D5               ; if opmode is 0, it is a byte with location specified is a source  (Dn - <ea> -> <ea>)
00002A8C  6700 003A               2214              BEQ     SUB_B_SrcEA
00002A90                          2215  
00002A90  BABC 00000001           2216              CMP.L   #1,D5               ; if opmode is 1, it is a word with location specified is a source  (Dn - <ea> -> <ea>)
00002A96  6700 01FE               2217              BEQ     SUB_W_SrcEA
00002A9A                          2218  
00002A9A  BABC 00000002           2219              CMP.L   #2,D5               ; if opmode is 2, it is a long with location specified is a source  (Dn - <ea> -> <ea>)
00002AA0  6700 03C2               2220              BEQ     SUB_L_SrcEA
00002AA4                          2221  
00002AA4  BABC 00000004           2222              CMP.L   #4,D5               ; if opmode is 4, it is a byte with location specified is a Destination (<ea> - Dn -> <ea>)
00002AAA  6700 0586               2223              BEQ     SUB_B_DesEA
00002AAE                          2224  
00002AAE  BABC 00000005           2225              CMP.L   #5,D5               ; if opmode is 5, it is a word with location specified is a Destination (<ea> - Dn -> <ea>)
00002AB4  6700 06C8               2226              BEQ     SUB_W_DesEA
00002AB8                          2227  
00002AB8  BABC 00000006           2228              CMP.L   #6,D5               ; if opmode is 6, it is a long with location specified is a Destination (<ea> - Dn -> <ea>)
00002ABE  6700 080A               2229              BEQ     SUB_L_DesEA
00002AC2                          2230  
00002AC2  4EF9 0000484E           2231              JMP     InvalidOpcode       ; if it is not one of the opmode the opcode is invalid
00002AC8                          2232  
00002AC8  7803                    2233  SUB_B_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002ACA  4EB9 00004856           2234              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002AD0                          2235  
00002AD0  BABC 00000000           2236              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002AD6  6700 003A               2237              BEQ     SUB_B_SrcEA_M0
00002ADA                          2238  
00002ADA  BABC 00000001           2239              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00002AE0  6700 005E               2240              BEQ     SUB_B_SrcEA_M1
00002AE4                          2241  
00002AE4  BABC 00000002           2242              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002AEA  6700 0082               2243              BEQ     SUB_B_SrcEA_M2
00002AEE                          2244  
00002AEE  BABC 00000003           2245              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002AF4  6700 00A6               2246              BEQ     SUB_B_SrcEA_M3
00002AF8                          2247  
00002AF8  BABC 00000004           2248              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002AFE  6700 00CA               2249              BEQ     SUB_B_SrcEA_M4
00002B02                          2250  
00002B02  BABC 00000007           2251              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002B08  6700 00EE               2252              BEQ     SUB_B_SrcEA_M7
00002B0C                          2253  
00002B0C  4EF9 0000484E           2254              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002B12                          2255  
00002B12                          2256  SUB_B_SrcEA_M0
00002B12  7803                    2257              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B14  4EB9 00004856           2258              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002B1A  4EB9 00004B70           2259              JSR     PrintSub
00002B20  4EB9 00004B7E           2260              JSR     LengthB
00002B26  4EB9 00004BB6           2261              JSR     PrintSpace
00002B2C  4EB9 000049D0           2262              JSR     PrintDataReg
00002B32                          2263  
00002B32  1A00                    2264              MOVE.B  D0,D5
00002B34  12EE 0025               2265              MOVE.B  37(A6),(A1)+             *,
00002B38  4EB9 000049D0           2266              JSR     PrintDataReg
00002B3E  4E75                    2267              RTS                     ; return to input to get more input
00002B40                          2268  
00002B40                          2269  SUB_B_SrcEA_M1
00002B40  7803                    2270              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B42  4EB9 00004856           2271              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002B48  4EB9 00004B70           2272              JSR     PrintSub
00002B4E  4EB9 00004B7E           2273              JSR     LengthB
00002B54  4EB9 00004BB6           2274              JSR     PrintSpace
00002B5A  4EB9 000049DC           2275              JSR     PrintAddrReg
00002B60                          2276  
00002B60  1A00                    2277              MOVE.B  D0,D5
00002B62  12EE 0025               2278              MOVE.B  37(A6),(A1)+             *,
00002B66  4EB9 000049D0           2279              JSR     PrintDataReg
00002B6C  4E75                    2280              RTS                     ; return to input to get more input
00002B6E                          2281  
00002B6E                          2282  SUB_B_SrcEA_M2
00002B6E  7803                    2283              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B70  4EB9 00004856           2284              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002B76  4EB9 00004B70           2285              JSR     PrintSub
00002B7C  4EB9 00004B7E           2286              JSR     LengthB
00002B82  4EB9 00004BB6           2287              JSR     PrintSpace
00002B88  4EB9 000049E8           2288              JSR     PrintIndirAddrReg
00002B8E                          2289  
00002B8E  1A00                    2290              MOVE.B  D0,D5
00002B90  12EE 0025               2291              MOVE.B  37(A6),(A1)+             *,
00002B94  4EB9 000049D0           2292              JSR     PrintDataReg
00002B9A  4E75                    2293              RTS                     ; return to input to get more input
00002B9C                          2294  
00002B9C                          2295  SUB_B_SrcEA_M3
00002B9C  7803                    2296              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B9E  4EB9 00004856           2297              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002BA4  4EB9 00004B70           2298              JSR     PrintSub
00002BAA  4EB9 00004B7E           2299              JSR     LengthB
00002BB0  4EB9 00004BB6           2300              JSR     PrintSpace
00002BB6  4EB9 000049F6           2301              JSR     PrintPostIncAddrReg
00002BBC                          2302  
00002BBC  1A00                    2303              MOVE.B  D0,D5
00002BBE  12EE 0025               2304              MOVE.B  37(A6),(A1)+             *,
00002BC2  4EB9 000049D0           2305              JSR     PrintDataReg
00002BC8  4E75                    2306              RTS                     ; return to input to get more input
00002BCA                          2307  
00002BCA                          2308  SUB_B_SrcEA_M4
00002BCA  7803                    2309              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002BCC  4EB9 00004856           2310              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002BD2  4EB9 00004B70           2311              JSR     PrintSub
00002BD8  4EB9 00004B7E           2312              JSR     LengthB
00002BDE  4EB9 00004BB6           2313              JSR     PrintSpace
00002BE4  4EB9 00004A00           2314              JSR     PrintPreDeincAddrReg
00002BEA                          2315  
00002BEA  1A00                    2316              MOVE.B  D0,D5
00002BEC  12EE 0025               2317              MOVE.B  37(A6),(A1)+             *,
00002BF0  4EB9 000049D0           2318              JSR     PrintDataReg
00002BF6  4E75                    2319              RTS                     ; return to input to get more input
00002BF8                          2320  
00002BF8                          2321  SUB_B_SrcEA_M7
00002BF8  7803                    2322              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002BFA  4EB9 00004856           2323              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002C00                          2324  
00002C00  BABC 00000000           2325              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002C06  6700 001C               2326              BEQ     SUB_B_SrcEA_xxxW
00002C0A                          2327  
00002C0A  BABC 00000001           2328              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002C10  6700 0038               2329              BEQ     SUB_B_SrcEA_xxxL
00002C14                          2330  
00002C14  BABC 00000004           2331              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002C1A  6700 0054               2332              BEQ     SUB_B_SrcEA_Data
00002C1E                          2333  
00002C1E  4EF9 0000484E           2334              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002C24                          2335  
00002C24                          2336  SUB_B_SrcEA_xxxW
00002C24  4EB9 00004B70           2337              JSR     PrintSub
00002C2A  4EB9 00004B7E           2338              JSR     LengthB
00002C30  4EB9 00004BB6           2339              JSR     PrintSpace
00002C36  4EB9 00004950           2340              JSR     PrintByteOrWord
00002C3C                          2341  
00002C3C  1A00                    2342              MOVE.B  D0,D5
00002C3E  12EE 0025               2343              MOVE.B  37(A6),(A1)+             *,
00002C42  4EB9 000049D0           2344              JSR     PrintDataReg
00002C48  4E75                    2345              RTS                     ; return to input to get more input
00002C4A                          2346  
00002C4A                          2347  SUB_B_SrcEA_xxxL
00002C4A  4EB9 00004B70           2348              JSR     PrintSub
00002C50  4EB9 00004B7E           2349              JSR     LengthB
00002C56  4EB9 00004BB6           2350              JSR     PrintSpace
00002C5C  4EB9 00004966           2351              JSR     PrintLong
00002C62                          2352  
00002C62  1A00                    2353              MOVE.B  D0,D5
00002C64  12EE 0025               2354              MOVE.B  37(A6),(A1)+             *,
00002C68  4EB9 000049D0           2355              JSR     PrintDataReg
00002C6E  4E75                    2356              RTS                     ; return to input to get more input
00002C70                          2357  
00002C70                          2358  SUB_B_SrcEA_Data
00002C70  4EB9 00004B70           2359              JSR     PrintSub
00002C76  4EB9 00004B7E           2360              JSR     LengthB
00002C7C  4EB9 00004BB6           2361              JSR     PrintSpace
00002C82  4EB9 00004944           2362              JSR     PrintImmediateData
00002C88                          2363  
00002C88  1A00                    2364              MOVE.B  D0,D5
00002C8A  12EE 0025               2365              MOVE.B  37(A6),(A1)+             *,
00002C8E  4EB9 000049D0           2366              JSR     PrintDataReg
00002C94  4E75                    2367              RTS                     ; return to input to get more input
00002C96                          2368  
00002C96                          2369  
00002C96  7803                    2370  SUB_W_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002C98  4EB9 00004856           2371              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002C9E                          2372  
00002C9E  BABC 00000000           2373              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002CA4  6700 003A               2374              BEQ     SUB_W_SrcEA_M0
00002CA8                          2375  
00002CA8  BABC 00000001           2376              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00002CAE  6700 005E               2377              BEQ     SUB_W_SrcEA_M1
00002CB2                          2378  
00002CB2  BABC 00000002           2379              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002CB8  6700 0082               2380              BEQ     SUB_W_SrcEA_M2
00002CBC                          2381  
00002CBC  BABC 00000003           2382              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002CC2  6700 00A6               2383              BEQ     SUB_W_SrcEA_M3
00002CC6                          2384  
00002CC6  BABC 00000004           2385              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002CCC  6700 00CA               2386              BEQ     SUB_W_SrcEA_M4
00002CD0                          2387  
00002CD0  BABC 00000007           2388              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002CD6  6700 00EE               2389              BEQ     SUB_W_SrcEA_M7
00002CDA                          2390  
00002CDA  4EF9 0000484E           2391              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002CE0                          2392  
00002CE0                          2393  SUB_W_SrcEA_M0
00002CE0  7803                    2394              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002CE2  4EB9 00004856           2395              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002CE8  4EB9 00004B70           2396              JSR     PrintSub
00002CEE  4EB9 00004B88           2397              JSR     LengthW
00002CF4  4EB9 00004BB6           2398              JSR     PrintSpace
00002CFA  4EB9 000049D0           2399              JSR     PrintDataReg
00002D00                          2400  
00002D00  1A00                    2401              MOVE.B  D0,D5
00002D02  12EE 0025               2402              MOVE.B  37(A6),(A1)+             *,
00002D06  4EB9 000049D0           2403              JSR     PrintDataReg
00002D0C  4E75                    2404              RTS                     ; return to input to get more input
00002D0E                          2405  
00002D0E                          2406  SUB_W_SrcEA_M1
00002D0E  7803                    2407              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D10  4EB9 00004856           2408              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002D16  4EB9 00004B70           2409              JSR     PrintSub
00002D1C  4EB9 00004B88           2410              JSR     LengthW
00002D22  4EB9 00004BB6           2411              JSR     PrintSpace
00002D28  4EB9 000049DC           2412              JSR     PrintAddrReg
00002D2E                          2413  
00002D2E  1A00                    2414              MOVE.B  D0,D5
00002D30  12EE 0025               2415              MOVE.B  37(A6),(A1)+             *,
00002D34  4EB9 000049D0           2416              JSR     PrintDataReg
00002D3A  4E75                    2417              RTS                     ; return to input to get more input
00002D3C                          2418  
00002D3C                          2419  SUB_W_SrcEA_M2
00002D3C  7803                    2420              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D3E  4EB9 00004856           2421              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002D44  4EB9 00004B70           2422              JSR     PrintSub
00002D4A  4EB9 00004B88           2423              JSR     LengthW
00002D50  4EB9 00004BB6           2424              JSR     PrintSpace
00002D56  4EB9 000049E8           2425              JSR     PrintIndirAddrReg
00002D5C                          2426  
00002D5C  1A00                    2427              MOVE.B  D0,D5
00002D5E  12EE 0025               2428              MOVE.B  37(A6),(A1)+             *,
00002D62  4EB9 000049D0           2429              JSR     PrintDataReg
00002D68  4E75                    2430              RTS                     ; return to input to get more input
00002D6A                          2431  
00002D6A                          2432  SUB_W_SrcEA_M3
00002D6A  7803                    2433              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D6C  4EB9 00004856           2434              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002D72  4EB9 00004B70           2435              JSR     PrintSub
00002D78  4EB9 00004B88           2436              JSR     LengthW
00002D7E  4EB9 00004BB6           2437              JSR     PrintSpace
00002D84  4EB9 000049F6           2438              JSR     PrintPostIncAddrReg
00002D8A                          2439  
00002D8A  1A00                    2440              MOVE.B  D0,D5
00002D8C  12EE 0025               2441              MOVE.B  37(A6),(A1)+             *,
00002D90  4EB9 000049D0           2442              JSR     PrintDataReg
00002D96  4E75                    2443              RTS                     ; return to input to get more input
00002D98                          2444  
00002D98                          2445  SUB_W_SrcEA_M4
00002D98  7803                    2446              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D9A  4EB9 00004856           2447              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002DA0  4EB9 00004B70           2448              JSR     PrintSub
00002DA6  4EB9 00004B88           2449              JSR     LengthW
00002DAC  4EB9 00004BB6           2450              JSR     PrintSpace
00002DB2  4EB9 00004A00           2451              JSR     PrintPreDeincAddrReg
00002DB8                          2452  
00002DB8  1A00                    2453              MOVE.B  D0,D5
00002DBA  12EE 0025               2454              MOVE.B  37(A6),(A1)+             *,
00002DBE  4EB9 000049D0           2455              JSR     PrintDataReg
00002DC4  4E75                    2456              RTS                     ; return to input to get more input
00002DC6                          2457  
00002DC6                          2458  SUB_W_SrcEA_M7
00002DC6  7803                    2459              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002DC8  4EB9 00004856           2460              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002DCE                          2461  
00002DCE  BABC 00000000           2462              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002DD4  6700 001C               2463              BEQ     SUB_W_SrcEA_xxxW
00002DD8                          2464  
00002DD8  BABC 00000001           2465              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002DDE  6700 0038               2466              BEQ     SUB_W_SrcEA_xxxL
00002DE2                          2467  
00002DE2  BABC 00000004           2468              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002DE8  6700 0054               2469              BEQ     SUB_W_SrcEA_Data
00002DEC                          2470  
00002DEC  4EF9 0000484E           2471              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002DF2                          2472  
00002DF2                          2473  SUB_W_SrcEA_xxxW
00002DF2  4EB9 00004B70           2474              JSR     PrintSub
00002DF8  4EB9 00004B88           2475              JSR     LengthW
00002DFE  4EB9 00004BB6           2476              JSR     PrintSpace
00002E04  4EB9 00004950           2477              JSR     PrintByteOrWord
00002E0A                          2478  
00002E0A  1A00                    2479              MOVE.B  D0,D5
00002E0C  12EE 0025               2480              MOVE.B  37(A6),(A1)+             *,
00002E10  4EB9 000049D0           2481              JSR     PrintDataReg
00002E16  4E75                    2482              RTS                     ; return to input to get more input
00002E18                          2483  
00002E18                          2484  SUB_W_SrcEA_xxxL
00002E18  4EB9 00004B70           2485              JSR     PrintSub
00002E1E  4EB9 00004B88           2486              JSR     LengthW
00002E24  4EB9 00004BB6           2487              JSR     PrintSpace
00002E2A  4EB9 00004966           2488              JSR     PrintLong
00002E30                          2489  
00002E30  1A00                    2490              MOVE.B  D0,D5
00002E32  12EE 0025               2491              MOVE.B  37(A6),(A1)+             *,
00002E36  4EB9 000049D0           2492              JSR     PrintDataReg
00002E3C  4E75                    2493              RTS                     ; return to input to get more input
00002E3E                          2494  
00002E3E                          2495  SUB_W_SrcEA_Data
00002E3E  4EB9 00004B70           2496              JSR     PrintSub
00002E44  4EB9 00004B88           2497              JSR     LengthW
00002E4A  4EB9 00004BB6           2498              JSR     PrintSpace
00002E50  4EB9 00004944           2499              JSR     PrintImmediateData
00002E56                          2500  
00002E56  1A00                    2501              MOVE.B  D0,D5
00002E58  12EE 0025               2502              MOVE.B  37(A6),(A1)+             *,
00002E5C  4EB9 000049D0           2503              JSR     PrintDataReg
00002E62  4E75                    2504              RTS                     ; return to input to get more input
00002E64                          2505  
00002E64  7803                    2506  SUB_L_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002E66  4EB9 00004856           2507              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002E6C                          2508  
00002E6C  BABC 00000000           2509              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002E72  6700 003A               2510              BEQ     SUB_L_SrcEA_M0
00002E76                          2511  
00002E76  BABC 00000001           2512              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00002E7C  6700 005E               2513              BEQ     SUB_L_SrcEA_M1
00002E80                          2514  
00002E80  BABC 00000002           2515              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002E86  6700 0082               2516              BEQ     SUB_L_SrcEA_M2
00002E8A                          2517  
00002E8A  BABC 00000003           2518              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002E90  6700 00A6               2519              BEQ     SUB_L_SrcEA_M3
00002E94                          2520  
00002E94  BABC 00000004           2521              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002E9A  6700 00CA               2522              BEQ     SUB_L_SrcEA_M4
00002E9E                          2523  
00002E9E  BABC 00000007           2524              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002EA4  6700 00EE               2525              BEQ     SUB_L_SrcEA_M7
00002EA8                          2526  
00002EA8  4EF9 0000484E           2527              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002EAE                          2528  
00002EAE                          2529  SUB_L_SrcEA_M0
00002EAE  7803                    2530              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002EB0  4EB9 00004856           2531              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002EB6  4EB9 00004B70           2532              JSR     PrintSub
00002EBC  4EB9 00004B92           2533              JSR     LengthL
00002EC2  4EB9 00004BB6           2534              JSR     PrintSpace
00002EC8  4EB9 000049D0           2535              JSR     PrintDataReg
00002ECE                          2536  
00002ECE  1A00                    2537              MOVE.B  D0,D5
00002ED0  12EE 0025               2538              MOVE.B  37(A6),(A1)+             *,
00002ED4  4EB9 000049D0           2539              JSR     PrintDataReg
00002EDA  4E75                    2540              RTS                     ; return to input to get more input
00002EDC                          2541  
00002EDC                          2542  SUB_L_SrcEA_M1
00002EDC  7803                    2543              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002EDE  4EB9 00004856           2544              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002EE4  4EB9 00004B70           2545              JSR     PrintSub
00002EEA  4EB9 00004B92           2546              JSR     LengthL
00002EF0  4EB9 00004BB6           2547              JSR     PrintSpace
00002EF6  4EB9 000049DC           2548              JSR     PrintAddrReg
00002EFC                          2549  
00002EFC  1A00                    2550              MOVE.B  D0,D5
00002EFE  12EE 0025               2551              MOVE.B  37(A6),(A1)+             *,
00002F02  4EB9 000049D0           2552              JSR     PrintDataReg
00002F08  4E75                    2553              RTS                     ; return to input to get more input
00002F0A                          2554  
00002F0A                          2555  SUB_L_SrcEA_M2
00002F0A  7803                    2556              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F0C  4EB9 00004856           2557              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F12  4EB9 00004B70           2558              JSR     PrintSub
00002F18  4EB9 00004B92           2559              JSR     LengthL
00002F1E  4EB9 00004BB6           2560              JSR     PrintSpace
00002F24  4EB9 000049E8           2561              JSR     PrintIndirAddrReg
00002F2A                          2562  
00002F2A  1A00                    2563              MOVE.B  D0,D5
00002F2C  12EE 0025               2564              MOVE.B  37(A6),(A1)+             *,
00002F30  4EB9 000049D0           2565              JSR     PrintDataReg
00002F36  4E75                    2566              RTS                     ; return to input to get more input
00002F38                          2567  
00002F38                          2568  SUB_L_SrcEA_M3
00002F38  7803                    2569              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F3A  4EB9 00004856           2570              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F40  4EB9 00004B70           2571              JSR     PrintSub
00002F46  4EB9 00004B92           2572              JSR     LengthL
00002F4C  4EB9 00004BB6           2573              JSR     PrintSpace
00002F52  4EB9 000049F6           2574              JSR     PrintPostIncAddrReg
00002F58                          2575  
00002F58  1A00                    2576              MOVE.B  D0,D5
00002F5A  12EE 0025               2577              MOVE.B  37(A6),(A1)+             *,
00002F5E  4EB9 000049D0           2578              JSR     PrintDataReg
00002F64  4E75                    2579              RTS                     ; return to input to get more input
00002F66                          2580  
00002F66                          2581  SUB_L_SrcEA_M4
00002F66  7803                    2582              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F68  4EB9 00004856           2583              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F6E  4EB9 00004B70           2584              JSR     PrintSub
00002F74  4EB9 00004B92           2585              JSR     LengthL
00002F7A  4EB9 00004BB6           2586              JSR     PrintSpace
00002F80  4EB9 00004A00           2587              JSR     PrintPreDeincAddrReg
00002F86                          2588  
00002F86  1A00                    2589              MOVE.B  D0,D5
00002F88  12EE 0025               2590              MOVE.B  37(A6),(A1)+             *,
00002F8C  4EB9 000049D0           2591              JSR     PrintDataReg
00002F92  4E75                    2592              RTS                     ; return to input to get more input
00002F94                          2593  
00002F94                          2594  SUB_L_SrcEA_M7
00002F94  7803                    2595              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F96  4EB9 00004856           2596              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F9C                          2597  
00002F9C  BABC 00000000           2598              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002FA2  6700 001C               2599              BEQ     SUB_L_SrcEA_xxxW
00002FA6                          2600  
00002FA6  BABC 00000001           2601              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002FAC  6700 0038               2602              BEQ     SUB_L_SrcEA_xxxL
00002FB0                          2603  
00002FB0  BABC 00000004           2604              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002FB6  6700 0054               2605              BEQ     SUB_L_SrcEA_Data
00002FBA                          2606  
00002FBA  4EF9 0000484E           2607              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002FC0                          2608  
00002FC0                          2609  SUB_L_SrcEA_xxxW
00002FC0  4EB9 00004B70           2610              JSR     PrintSub
00002FC6  4EB9 00004B92           2611              JSR     LengthL
00002FCC  4EB9 00004BB6           2612              JSR     PrintSpace
00002FD2  4EB9 00004950           2613              JSR     PrintByteOrWord
00002FD8                          2614  
00002FD8  1A00                    2615              MOVE.B  D0,D5
00002FDA  12EE 0025               2616              MOVE.B  37(A6),(A1)+             *,
00002FDE  4EB9 000049D0           2617              JSR     PrintDataReg
00002FE4  4E75                    2618              RTS                     ; return to input to get more input
00002FE6                          2619  
00002FE6                          2620  SUB_L_SrcEA_xxxL
00002FE6  4EB9 00004B70           2621              JSR     PrintSub
00002FEC  4EB9 00004B92           2622              JSR     LengthL
00002FF2  4EB9 00004BB6           2623              JSR     PrintSpace
00002FF8  4EB9 00004966           2624              JSR     PrintLong
00002FFE                          2625  
00002FFE  1A00                    2626              MOVE.B  D0,D5
00003000  12EE 0025               2627              MOVE.B  37(A6),(A1)+             *,
00003004  4EB9 000049D0           2628              JSR     PrintDataReg
0000300A  4E75                    2629              RTS                     ; return to input to get more input
0000300C                          2630  
0000300C                          2631  SUB_L_SrcEA_Data
0000300C  4EB9 00004B70           2632              JSR     PrintSub
00003012  4EB9 00004B92           2633              JSR     LengthL
00003018  4EB9 00004BB6           2634              JSR     PrintSpace
0000301E  4EB9 00004944           2635              JSR     PrintImmediateData
00003024                          2636  
00003024  1A00                    2637              MOVE.B  D0,D5
00003026  12EE 0025               2638              MOVE.B  37(A6),(A1)+             *,
0000302A  4EB9 000049D0           2639              JSR     PrintDataReg
00003030  4E75                    2640              RTS                     ; return to input to get more input
00003032                          2641  
00003032  7803                    2642  SUB_B_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00003034  4EB9 00004856           2643              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
0000303A                          2644  
0000303A  BABC 00000002           2645              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00003040  6700 0026               2646              BEQ     SUB_B_DesEA_M2
00003044                          2647  
00003044  BABC 00000003           2648              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
0000304A  6700 004E               2649              BEQ     SUB_B_DesEA_M3
0000304E                          2650  
0000304E  BABC 00000004           2651              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00003054  6700 0076               2652              BEQ     SUB_B_DesEA_M4
00003058                          2653  
00003058  BABC 00000007           2654              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
0000305E  6700 009E               2655              BEQ     SUB_B_DesEA_M7
00003062                          2656  
00003062  4EF9 0000484E           2657              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00003068                          2658  
00003068                          2659  SUB_B_DesEA_M2
00003068  7803                    2660              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000306A  4EB9 00004856           2661              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003070  4EB9 00004B70           2662              JSR     PrintSub
00003076  4EB9 00004B7E           2663              JSR     LengthB
0000307C  4EB9 00004BB6           2664              JSR     PrintSpace
00003082                          2665  
00003082  1E05                    2666              MOVE.B  D5,D7
00003084  1A00                    2667              MOVE.B  D0,D5
00003086  4EB9 000049D0           2668              JSR     PrintDataReg
0000308C                          2669  
0000308C  1A07                    2670              MOVE.B  D7,D5
0000308E  12EE 0025               2671              MOVE.B  37(A6),(A1)+             *,
00003092  4EB9 000049E8           2672              JSR     PrintIndirAddrReg
00003098  4E75                    2673              RTS                     ; return to input to get more input
0000309A                          2674  
0000309A                          2675  SUB_B_DesEA_M3
0000309A  7803                    2676              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000309C  4EB9 00004856           2677              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000030A2  4EB9 00004B70           2678              JSR     PrintSub
000030A8  4EB9 00004B7E           2679              JSR     LengthB
000030AE  4EB9 00004BB6           2680              JSR     PrintSpace
000030B4                          2681  
000030B4  1E05                    2682              MOVE.B  D5,D7
000030B6  1A00                    2683              MOVE.B  D0,D5
000030B8  4EB9 000049D0           2684              JSR     PrintDataReg
000030BE                          2685  
000030BE  1A07                    2686              MOVE.B  D7,D5
000030C0  12EE 0025               2687              MOVE.B  37(A6),(A1)+             *,
000030C4  4EB9 000049F6           2688              JSR     PrintPostIncAddrReg
000030CA  4E75                    2689              RTS                     ; return to input to get more input
000030CC                          2690  
000030CC                          2691  SUB_B_DesEA_M4
000030CC  7803                    2692              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000030CE  4EB9 00004856           2693              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000030D4  4EB9 00004B70           2694              JSR     PrintSub
000030DA  4EB9 00004B7E           2695              JSR     LengthB
000030E0  4EB9 00004BB6           2696              JSR     PrintSpace
000030E6                          2697  
000030E6  1E05                    2698              MOVE.B  D5,D7
000030E8  1A00                    2699              MOVE.B  D0,D5
000030EA  4EB9 000049D0           2700              JSR     PrintDataReg
000030F0                          2701  
000030F0  1A07                    2702              MOVE.B  D7,D5
000030F2  12EE 0025               2703              MOVE.B  37(A6),(A1)+             *,
000030F6  4EB9 00004A00           2704              JSR     PrintPreDeincAddrReg
000030FC  4E75                    2705              RTS                     ; return to input to get more input
000030FE                          2706  
000030FE                          2707  SUB_B_DesEA_M7
000030FE  7803                    2708              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003100  4EB9 00004856           2709              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003106                          2710  
00003106  BABC 00000000           2711              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
0000310C  6700 FB16               2712              BEQ     SUB_B_SrcEA_xxxW
00003110                          2713  
00003110  BABC 00000001           2714              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00003116  6700 FB32               2715              BEQ     SUB_B_SrcEA_xxxL
0000311A                          2716  
0000311A  BABC 00000004           2717              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00003120  6700 FB4E               2718              BEQ     SUB_B_SrcEA_Data
00003124                          2719  
00003124  4EF9 0000484E           2720              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000312A                          2721  
0000312A                          2722  SUB_B_DesEA_xxxW
0000312A  4EB9 00004B70           2723              JSR     PrintSub
00003130  4EB9 00004B7E           2724              JSR     LengthB
00003136  4EB9 00004BB6           2725              JSR     PrintSpace
0000313C                          2726  
0000313C  1E05                    2727              MOVE.B  D5,D7
0000313E  1A00                    2728              MOVE.B  D0,D5
00003140  4EB9 000049D0           2729              JSR     PrintDataReg
00003146                          2730  
00003146  1A07                    2731              MOVE.B  D7,D5
00003148  12EE 0025               2732              MOVE.B  37(A6),(A1)+             *,
0000314C  4EB9 00004950           2733              JSR     PrintByteOrWord
00003152  4E75                    2734              RTS                     ; return to input to get more input
00003154                          2735  
00003154                          2736  SUB_B_DesEA_xxxL
00003154  4EB9 00004B70           2737              JSR     PrintSub
0000315A  4EB9 00004B7E           2738              JSR     LengthB
00003160  4EB9 00004BB6           2739              JSR     PrintSpace
00003166                          2740  
00003166  1E05                    2741              MOVE.B  D5,D7
00003168  1A00                    2742              MOVE.B  D0,D5
0000316A  4EB9 000049D0           2743              JSR     PrintDataReg
00003170                          2744  
00003170  1A07                    2745              MOVE.B  D7,D5
00003172  12EE 0025               2746              MOVE.B  37(A6),(A1)+             *,
00003176  4EB9 00004966           2747              JSR     PrintLong
0000317C  4E75                    2748              RTS                     ; return to input to get more input
0000317E                          2749  
0000317E  7803                    2750  SUB_W_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00003180  4EB9 00004856           2751              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00003186                          2752  
00003186  BABC 00000002           2753              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
0000318C  6700 0026               2754              BEQ     SUB_W_DesEA_M2
00003190                          2755  
00003190  BABC 00000003           2756              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00003196  6700 004E               2757              BEQ     SUB_W_DesEA_M3
0000319A                          2758  
0000319A  BABC 00000004           2759              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000031A0  6700 0076               2760              BEQ     SUB_W_DesEA_M4
000031A4                          2761  
000031A4  BABC 00000007           2762              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000031AA  6700 009E               2763              BEQ     SUB_W_DesEA_M7
000031AE                          2764  
000031AE  4EF9 0000484E           2765              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000031B4                          2766  
000031B4                          2767  SUB_W_DesEA_M2
000031B4  7803                    2768              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000031B6  4EB9 00004856           2769              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000031BC  4EB9 00004B70           2770              JSR     PrintSub
000031C2  4EB9 00004B88           2771              JSR     LengthW
000031C8  4EB9 00004BB6           2772              JSR     PrintSpace
000031CE                          2773  
000031CE  1E05                    2774              MOVE.B  D5,D7
000031D0  1A00                    2775              MOVE.B  D0,D5
000031D2  4EB9 000049D0           2776              JSR     PrintDataReg
000031D8                          2777  
000031D8  1A07                    2778              MOVE.B  D7,D5
000031DA  12EE 0025               2779              MOVE.B  37(A6),(A1)+             *,
000031DE  4EB9 000049E8           2780              JSR     PrintIndirAddrReg
000031E4  4E75                    2781              RTS                     ; return to input to get more input
000031E6                          2782  
000031E6                          2783  SUB_W_DesEA_M3
000031E6  7803                    2784              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000031E8  4EB9 00004856           2785              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000031EE  4EB9 00004B70           2786              JSR     PrintSub
000031F4  4EB9 00004B88           2787              JSR     LengthW
000031FA  4EB9 00004BB6           2788              JSR     PrintSpace
00003200                          2789  
00003200  1E05                    2790              MOVE.B  D5,D7
00003202  1A00                    2791              MOVE.B  D0,D5
00003204  4EB9 000049D0           2792              JSR     PrintDataReg
0000320A                          2793  
0000320A  1A07                    2794              MOVE.B  D7,D5
0000320C  12EE 0025               2795              MOVE.B  37(A6),(A1)+             *,
00003210  4EB9 000049F6           2796              JSR     PrintPostIncAddrReg
00003216  4E75                    2797              RTS                     ; return to input to get more input
00003218                          2798  
00003218                          2799  SUB_W_DesEA_M4
00003218  7803                    2800              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000321A  4EB9 00004856           2801              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003220  4EB9 00004B70           2802              JSR     PrintSub
00003226  4EB9 00004B88           2803              JSR     LengthW
0000322C  4EB9 00004BB6           2804              JSR     PrintSpace
00003232                          2805  
00003232  1E05                    2806              MOVE.B  D5,D7
00003234  1A00                    2807              MOVE.B  D0,D5
00003236  4EB9 000049D0           2808              JSR     PrintDataReg
0000323C                          2809  
0000323C  1A07                    2810              MOVE.B  D7,D5
0000323E  12EE 0025               2811              MOVE.B  37(A6),(A1)+             *,
00003242  4EB9 00004A00           2812              JSR     PrintPreDeincAddrReg
00003248  4E75                    2813              RTS                     ; return to input to get more input
0000324A                          2814  
0000324A                          2815  SUB_W_DesEA_M7
0000324A  7803                    2816              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000324C  4EB9 00004856           2817              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003252                          2818  
00003252  BABC 00000000           2819              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00003258  6700 FB98               2820              BEQ     SUB_W_SrcEA_xxxW
0000325C                          2821  
0000325C  BABC 00000001           2822              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00003262  6700 FBB4               2823              BEQ     SUB_W_SrcEA_xxxL
00003266                          2824  
00003266  BABC 00000004           2825              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
0000326C  6700 FBD0               2826              BEQ     SUB_W_SrcEA_Data
00003270                          2827  
00003270  4EF9 0000484E           2828              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00003276                          2829  
00003276                          2830  SUB_W_DesEA_xxxW
00003276  4EB9 00004B70           2831              JSR     PrintSub
0000327C  4EB9 00004B88           2832              JSR     LengthW
00003282  4EB9 00004BB6           2833              JSR     PrintSpace
00003288                          2834  
00003288  1E05                    2835              MOVE.B  D5,D7
0000328A  1A00                    2836              MOVE.B  D0,D5
0000328C  4EB9 000049D0           2837              JSR     PrintDataReg
00003292                          2838  
00003292  1A07                    2839              MOVE.B  D7,D5
00003294  12EE 0025               2840              MOVE.B  37(A6),(A1)+             *,
00003298  4EB9 00004950           2841              JSR     PrintByteOrWord
0000329E  4E75                    2842              RTS                     ; return to input to get more input
000032A0                          2843  
000032A0                          2844  SUB_W_DesEA_xxxL
000032A0  4EB9 00004B70           2845              JSR     PrintSub
000032A6  4EB9 00004B88           2846              JSR     LengthW
000032AC  4EB9 00004BB6           2847              JSR     PrintSpace
000032B2                          2848  
000032B2  1E05                    2849              MOVE.B  D5,D7
000032B4  1A00                    2850              MOVE.B  D0,D5
000032B6  4EB9 000049D0           2851              JSR     PrintDataReg
000032BC                          2852  
000032BC  1A07                    2853              MOVE.B  D7,D5
000032BE  12EE 0025               2854              MOVE.B  37(A6),(A1)+             *,
000032C2  4EB9 00004966           2855              JSR     PrintLong
000032C8  4E75                    2856              RTS                     ; return to input to get more input
000032CA                          2857  
000032CA  7803                    2858  SUB_L_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000032CC  4EB9 00004856           2859              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000032D2                          2860  
000032D2  BABC 00000002           2861              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000032D8  6700 0026               2862              BEQ     SUB_L_DesEA_M2
000032DC                          2863  
000032DC  BABC 00000003           2864              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000032E2  6700 004E               2865              BEQ     SUB_L_DesEA_M3
000032E6                          2866  
000032E6  BABC 00000004           2867              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000032EC  6700 0076               2868              BEQ     SUB_L_DesEA_M4
000032F0                          2869  
000032F0  BABC 00000007           2870              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000032F6  6700 009E               2871              BEQ     SUB_L_DesEA_M7
000032FA                          2872  
000032FA  4EF9 0000484E           2873              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00003300                          2874  
00003300                          2875  SUB_L_DesEA_M2
00003300  7803                    2876              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003302  4EB9 00004856           2877              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003308  4EB9 00004B70           2878              JSR     PrintSub
0000330E  4EB9 00004B92           2879              JSR     LengthL
00003314  4EB9 00004BB6           2880              JSR     PrintSpace
0000331A                          2881  
0000331A  1E05                    2882              MOVE.B  D5,D7
0000331C  1A00                    2883              MOVE.B  D0,D5
0000331E  4EB9 000049D0           2884              JSR     PrintDataReg
00003324                          2885  
00003324  1A07                    2886              MOVE.B  D7,D5
00003326  12EE 0025               2887              MOVE.B  37(A6),(A1)+             *,
0000332A  4EB9 000049E8           2888              JSR     PrintIndirAddrReg
00003330  4E75                    2889              RTS                     ; return to input to get more input
00003332                          2890  
00003332                          2891  SUB_L_DesEA_M3
00003332  7803                    2892              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003334  4EB9 00004856           2893              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000333A  4EB9 00004B70           2894              JSR     PrintSub
00003340  4EB9 00004B92           2895              JSR     LengthL
00003346  4EB9 00004BB6           2896              JSR     PrintSpace
0000334C                          2897  
0000334C  1E05                    2898              MOVE.B  D5,D7
0000334E  1A00                    2899              MOVE.B  D0,D5
00003350  4EB9 000049D0           2900              JSR     PrintDataReg
00003356                          2901  
00003356  1A07                    2902              MOVE.B  D7,D5
00003358  12EE 0025               2903              MOVE.B  37(A6),(A1)+             *,
0000335C  4EB9 000049F6           2904              JSR     PrintPostIncAddrReg
00003362  4E75                    2905              RTS                     ; return to input to get more input
00003364                          2906  
00003364                          2907  SUB_L_DesEA_M4
00003364  7803                    2908              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003366  4EB9 00004856           2909              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000336C  4EB9 00004B70           2910              JSR     PrintSub
00003372  4EB9 00004B92           2911              JSR     LengthL
00003378  4EB9 00004BB6           2912              JSR     PrintSpace
0000337E                          2913  
0000337E  1E05                    2914              MOVE.B  D5,D7
00003380  1A00                    2915              MOVE.B  D0,D5
00003382  4EB9 000049D0           2916              JSR     PrintDataReg
00003388                          2917  
00003388  1A07                    2918              MOVE.B  D7,D5
0000338A  12EE 0025               2919              MOVE.B  37(A6),(A1)+             *,
0000338E  4EB9 00004A00           2920              JSR     PrintPreDeincAddrReg
00003394  4E75                    2921              RTS                     ; return to input to get more input
00003396                          2922  
00003396                          2923  SUB_L_DesEA_M7
00003396  7803                    2924              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003398  4EB9 00004856           2925              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000339E                          2926  
0000339E  BABC 00000000           2927              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000033A4  6700 FC1A               2928              BEQ     SUB_L_SrcEA_xxxW
000033A8                          2929  
000033A8  BABC 00000001           2930              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000033AE  6700 FC36               2931              BEQ     SUB_L_SrcEA_xxxL
000033B2                          2932  
000033B2  4EF9 0000484E           2933              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000033B8                          2934  
000033B8                          2935  SUB_L_DesEA_xxxW
000033B8  4EB9 00004B70           2936              JSR     PrintSub
000033BE  4EB9 00004B92           2937              JSR     LengthL
000033C4  4EB9 00004BB6           2938              JSR     PrintSpace
000033CA                          2939  
000033CA  1E05                    2940              MOVE.B  D5,D7
000033CC  1A00                    2941              MOVE.B  D0,D5
000033CE  4EB9 000049D0           2942              JSR     PrintDataReg
000033D4                          2943  
000033D4  1A07                    2944              MOVE.B  D7,D5
000033D6  12EE 0025               2945              MOVE.B  37(A6),(A1)+             *,
000033DA  4EB9 00004950           2946              JSR     PrintByteOrWord
000033E0  4E75                    2947              RTS                     ; return to input to get more input
000033E2                          2948  
000033E2                          2949  SUB_L_DesEA_xxxL
000033E2  4EB9 00004B70           2950              JSR     PrintSub
000033E8  4EB9 00004B92           2951              JSR     LengthL
000033EE  4EB9 00004BB6           2952              JSR     PrintSpace
000033F4                          2953  
000033F4  1E05                    2954              MOVE.B  D5,D7
000033F6  1A00                    2955              MOVE.B  D0,D5
000033F8  4EB9 000049D0           2956              JSR     PrintDataReg
000033FE                          2957  
000033FE  1A07                    2958              MOVE.B  D7,D5
00003400  12EE 0025               2959              MOVE.B  37(A6),(A1)+             *,
00003404  4EB9 00004966           2960              JSR     PrintLong
0000340A  4E75                    2961              RTS                     ; return to input to get more input
0000340C                          2962  
0000340C                          2963  *************************************************                DIVU_W_Opcode              *************************************************
0000340C                          2964  ; first four bit is (1000 #### #### ####)
0000340C                          2965  DIVU_W_Opcode
0000340C  7803                    2966              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
0000340E  4EB9 00004856           2967              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the register
00003414                          2968  
00003414  2005                    2969              MOVE.L  D5,D0               ; D0 will hold the register
00003416                          2970          ; D0 will hold the register (position 11-9)
00003416                          2971  
00003416  7803                    2972              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00003418  4EB9 00004856           2973              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the register
0000341E                          2974  
0000341E  BABC 00000003           2975              CMP.L   #3,D5               ; position 8-6 should be 011, else it is invalid
00003424  6600 1428               2976              BNE     InvalidOpcode
00003428                          2977  
00003428  7803                    2978              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000342A  4EB9 00004856           2979              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003430                          2980  
00003430  BABC 00000000           2981              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00003436  6700 0030               2982              BEQ     DIVU_W_M0
0000343A                          2983  
0000343A  BABC 00000002           2984              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00003440  6700 0054               2985              BEQ     DIVU_W_M2
00003444                          2986  
00003444  BABC 00000003           2987              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
0000344A  6700 0078               2988              BEQ     DIVU_W_M3
0000344E                          2989  
0000344E  BABC 00000004           2990              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00003454  6700 009C               2991              BEQ     DIVU_W_M4
00003458                          2992  
00003458  BABC 00000007           2993              CMP.L   #7,D5               ; if EA mode is 7 if D5 is 7
0000345E  6700 00C0               2994              BEQ     DIVU_W_M7
00003462                          2995  
00003462  4EF9 0000484E           2996              JMP     InvalidOpcode       ; not one of the valid EA mode
00003468                          2997  
00003468                          2998  
00003468  7803                    2999  DIVU_W_M0   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000346A  4EB9 00004856           3000              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
00003470  4EB9 00004A94           3001              JSR     PrintDivu
00003476  4EB9 00004B88           3002              JSR     LengthW
0000347C  4EB9 00004BB6           3003              JSR     PrintSpace
00003482  4EB9 000049D0           3004              JSR     PrintDataReg
00003488                          3005  
00003488  1A00                    3006              MOVE.B  D0,D5
0000348A  12EE 0025               3007              MOVE.B  37(A6),(A1)+             *,
0000348E  4EB9 000049D0           3008              JSR     PrintDataReg
00003494  4E75                    3009              RTS                     ; return to input to get more input
00003496                          3010  
00003496  7803                    3011  DIVU_W_M2   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003498  4EB9 00004856           3012              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
0000349E  4EB9 00004A94           3013              JSR     PrintDivu
000034A4  4EB9 00004B88           3014              JSR     LengthW
000034AA  4EB9 00004BB6           3015              JSR     PrintSpace
000034B0  4EB9 000049E8           3016              JSR     PrintIndirAddrReg
000034B6                          3017  
000034B6  1A00                    3018              MOVE.B  D0,D5
000034B8  12EE 0025               3019              MOVE.B  37(A6),(A1)+             *,
000034BC  4EB9 000049D0           3020              JSR     PrintDataReg
000034C2  4E75                    3021              RTS                     ; return to input to get more input
000034C4                          3022  
000034C4  7803                    3023  DIVU_W_M3   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000034C6  4EB9 00004856           3024              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
000034CC  4EB9 00004A94           3025              JSR     PrintDivu
000034D2  4EB9 00004B88           3026              JSR     LengthW
000034D8  4EB9 00004BB6           3027              JSR     PrintSpace
000034DE  4EB9 000049F6           3028              JSR     PrintPostIncAddrReg
000034E4                          3029  
000034E4  1A00                    3030              MOVE.B  D0,D5
000034E6  12EE 0025               3031              MOVE.B  37(A6),(A1)+             *,
000034EA  4EB9 000049D0           3032              JSR     PrintDataReg
000034F0  4E75                    3033              RTS                     ; return to input to get more input
000034F2                          3034  
000034F2  7803                    3035  DIVU_W_M4   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000034F4  4EB9 00004856           3036              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
000034FA  4EB9 00004A94           3037              JSR     PrintDivu
00003500  4EB9 00004B88           3038              JSR     LengthW
00003506  4EB9 00004BB6           3039              JSR     PrintSpace
0000350C  4EB9 00004A00           3040              JSR     PrintPreDeincAddrReg
00003512                          3041  
00003512  1A00                    3042              MOVE.B  D0,D5
00003514  12EE 0025               3043              MOVE.B  37(A6),(A1)+             *,
00003518  4EB9 000049D0           3044              JSR     PrintDataReg
0000351E  4E75                    3045              RTS                     ; return to input to get more input
00003520                          3046  
00003520  7803                    3047  DIVU_W_M7   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003522  4EB9 00004856           3048              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
00003528                          3049  
00003528  BABC 00000000           3050              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
0000352E  6700 001C               3051              BEQ     DIVU_W_xxxW
00003532                          3052  
00003532  BABC 00000001           3053              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003538  6700 0038               3054              BEQ     DIVU_W_xxxL
0000353C                          3055  
0000353C  BABC 00000004           3056              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00003542  6700 0054               3057              BEQ     DIVU_W_Data
00003546                          3058  
00003546  4EF9 0000484E           3059              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1 or 4, it is invaid
0000354C                          3060  
0000354C  4EB9 00004A94           3061  DIVU_W_xxxW JSR     PrintDivu
00003552  4EB9 00004B88           3062              JSR     LengthW
00003558  4EB9 00004BB6           3063              JSR     PrintSpace
0000355E  4EB9 00004950           3064              JSR     PrintByteOrWord
00003564                          3065  
00003564  1A00                    3066              MOVE.B  D0,D5
00003566  12EE 0025               3067              MOVE.B  37(A6),(A1)+             *,
0000356A  4EB9 000049D0           3068              JSR     PrintDataReg
00003570  4E75                    3069              RTS                     ; return to input to get more input
00003572                          3070  
00003572  4EB9 00004A94           3071  DIVU_W_xxxL JSR     PrintDivu
00003578  4EB9 00004B88           3072              JSR     LengthW
0000357E  4EB9 00004BB6           3073              JSR     PrintSpace
00003584  4EB9 00004966           3074              JSR     PrintLong
0000358A                          3075  
0000358A  1A00                    3076              MOVE.B  D0,D5
0000358C  12EE 0025               3077              MOVE.B  37(A6),(A1)+             *,
00003590  4EB9 000049D0           3078              JSR     PrintDataReg
00003596  4E75                    3079              RTS                     ; return to input to get more input
00003598                          3080  
00003598  4EB9 00004A94           3081  DIVU_W_Data JSR     PrintDivu
0000359E  4EB9 00004B88           3082              JSR     LengthW
000035A4  4EB9 00004BB6           3083              JSR     PrintSpace
000035AA  4EB9 00004944           3084              JSR     PrintImmediateData
000035B0                          3085  
000035B0  1A00                    3086              MOVE.B  D0,D5
000035B2  12EE 0025               3087              MOVE.B  37(A6),(A1)+             *,
000035B6  4EB9 000049D0           3088              JSR     PrintDataReg
000035BC  4E75                    3089              RTS                     ; return to input to get more input
000035BE                          3090  
000035BE                          3091  *************************************************                Bcc_Opcode                 *************************************************
000035BE                          3092  ; first four bit is (0110 #### #### ####)
000035BE                          3093  Bcc_Opcode
000035BE  7804                    3094              MOVE.L  #4,D4          ; get the next 4 bit from (A4)(position 11-8) in to D5
000035C0  4EB9 00004856           3095              JSR     GetNextD4bit   ; D5 hold the next 4 bit of (A4), which tell us which Bcc
000035C6                          3096         ; cmp to see whice Bcc opcode the the next 4 bit(position 11-8) match with
000035C6  BABC 0000000E           3097              CMP.L   #14,D5
000035CC  6700 0026               3098              BEQ     BGT_Opcode
000035D0                          3099  
000035D0  BABC 0000000F           3100              CMP.L   #15,D5
000035D6  6700 0028               3101              BEQ     BLE_Opcode
000035DA                          3102  
000035DA  BABC 00000000           3103              CMP.L   #0,D5
000035E0  6700 002A               3104              BEQ     BRA_Opcode
000035E4                          3105  
000035E4  BABC 00000007           3106              CMP.L   #7,D5
000035EA  6700 002C               3107              BEQ     BEQ_Opcode
000035EE                          3108  
000035EE  4EF9 0000484E           3109              JMP     InvalidOpcode   ; (position 11-8) did not match any of the Bcc opcode, so it is invalid
000035F4                          3110  
000035F4                          3111  
000035F4  4EB9 00004A6A           3112  BGT_Opcode  JSR PrintBGT
000035FA  4EF9 00003624           3113              JMP     Bcc_displacement ; take care of output the displacement bit
00003600                          3114  
00003600  4EB9 00004A78           3115  BLE_Opcode  JSR PrintBLE
00003606  4EF9 00003624           3116              JMP     Bcc_displacement ; take care of output the displacement bit
0000360C                          3117  
0000360C  4EB9 00004A86           3118  BRA_Opcode  JSR PrintBRA
00003612  4EF9 00003624           3119              JMP     Bcc_displacement ; take care of output the displacement bit
00003618                          3120  
00003618  4EB9 00004A5C           3121  BEQ_Opcode  JSR PrintBEQ
0000361E  4EF9 00003624           3122              JMP     Bcc_displacement ; take care of output the displacement bit
00003624                          3123  
00003624                          3124  Bcc_displacement    ;for gettin the next 8 bit for displacement and outputting it
00003624  7808                    3125              MOVE.L  #8,D4          ; get the next 8 bit from (A4)(position 7-0) in to D5
00003626  4EB9 00004856           3126              JSR     GetNextD4bit   ; D5 hold the next 4 bit of (A4), which tell us the displacement
0000362C                          3127  
0000362C  BABC 00000000           3128              CMP.L   #$00,D5          ; if displacement is $00 than it is a 16bit displacement
00003632  6700 000E               3129              BEQ     Bcc_16bit_Disp
00003636                          3130  
00003636  BABC 000000FF           3131              CMP.L   #$FF,D5
0000363C  6700 000E               3132              BEQ     Bcc_32bit_Disp   ; if displacement is $00 than it is a 32bit displacement
00003640                          3133  
00003640                          3134              ; print 8bit displacemnt address from D5
00003640  4E75                    3135              RTS                     ; return to input to get more input
00003642                          3136  
00003642                          3137  Bcc_16bit_Disp
00003642                          3138              ; print 16bit address
00003642  12EE 002C               3139              MOVE.B   44(A6),(A1)+        *(space)
00003646  12EE 0026               3140                  MOVE.B   38(A6),(A1)+        *$
0000364A  4E75                    3141              RTS                     ; return to input to get more input
0000364C                          3142  
0000364C                          3143  Bcc_32bit_Disp
0000364C                          3144              ; print 32bit address
0000364C  12EE 002C               3145              MOVE.B   44(A6),(A1)+        *(space)
00003650  12EE 0026               3146                  MOVE.B   38(A6),(A1)+        *$
00003654  4E75                    3147              RTS                     ; return to input to get more input
00003656                          3148  
00003656                          3149  
00003656                          3150  *************************************************                NeedMoreBit                *************************************************
00003656                          3151  ;Could be MOVEM, MULS.L, DIVU.L, JSR, NOT, LEA
00003656                          3152  ; first four bit is (0100 #### #### ####)
00003656                          3153  NeedMoreBit
00003656  7806                    3154              MOVE.L  #6,D4          ; get the next 6 bit from (A4)(position 11-6) in to D5
00003658  4EB9 00004856           3155              JSR     GetNextD4bit   ; D5 hold the next 6 bit of (A4), which will narrow down the opcode possibility
0000365E                          3156  
0000365E  BABC 00000022           3157              CMP.L   #34,D5         ; if position 11-6 equal to 34, it is MoveM register to memory size Word
00003664  6700 011C               3158              BEQ     MoveM_R2M_W
00003668                          3159  
00003668  BABC 00000023           3160              CMP.L   #35,D5         ; if position 11-6 equal to 35, it is MoveM register to memory size Long
0000366E  6700 01E8               3161              BEQ     MoveM_R2M_L
00003672                          3162  
00003672  BABC 00000032           3163              CMP.L   #50,D5         ; if position 11-6 equal to 50, it is MoveM memory to register size word
00003678  6700 02B4               3164              BEQ     MoveM_M2R_W
0000367C                          3165  
0000367C  BABC 00000033           3166              CMP.L   #51,D5         ; if position 11-6 equal to 51, it is MoveM memory to register size long
00003682  6700 0380               3167              BEQ     MoveM_M2R_L
00003686                          3168  
00003686  BABC 00000030           3169              CMP.L   #48,D5         ; if position 11-6 equal to 48, it is MULS.L
0000368C  6700 044C               3170              BEQ     Muls_L
00003690                          3171  
00003690  BABC 00000031           3172              CMP.L   #49,D5         ; if position 11-6 equal to 49, it is DIVU.L
00003696  6700 05D8               3173              BEQ     Divu_L
0000369A                          3174  
0000369A  BABC 0000003A           3175              CMP.L   #58,D5         ; if position 11-6 equal to 58, it is JSR
000036A0  6700 0764               3176              BEQ     JSR_Opcode
000036A4                          3177  
000036A4  BABC 00000018           3178              CMP.L   #24,D5         ; if position 11-6 equal to 24, it is NOT size byte
000036AA  6700 07E2               3179              BEQ     Not_B_Opcode
000036AE                          3180  
000036AE  BABC 00000019           3181              CMP.L   #25,D5         ; if position 11-6 equal to 25, it is NOT size word
000036B4  6700 08F6               3182              BEQ     Not_W_Opcode
000036B8                          3183  
000036B8  BABC 0000001A           3184              CMP.L   #26,D5         ; if position 11-6 equal to 26, it is NOT size long
000036BE  6700 0A0A               3185              BEQ     Not_L_Opcode
000036C2                          3186  
000036C2                          3187  
000036C2                          3188  *************************************************                Lea_Opcode                 *************************************************
000036C2                          3189  ; notice there is no line that say jupm to Lea_Opcode, it should be run automatically of after NeedMoreBit, if it doesn't match other opcode
000036C2                          3190  Lea_Opcode  ; the only posible opcode left is LEA, it is LEA if the bit from position 8-6 is all 1
000036C2  E28D                    3191              LSR.L   #1,D5          ; shift left to get carry bit of 6 place
000036C4  6400 1188               3192              BCC     InvalidOpcode  ; if the carry bit is is not 1, it is not a valid opcode
000036C8  E28D                    3193              LSR.L   #1,D5          ; shift left to get carry bit of 5 place
000036CA  6400 1182               3194              BCC     InvalidOpcode  ; if the carry bit is is not 1, it is not a valid opcode
000036CE  E28D                    3195              LSR.L   #1,D5          ; shift left to get carry bit of 4 place
000036D0  6400 117C               3196              BCC     InvalidOpcode  ; if the carry bit is is not 1, it is not a valid opcode
000036D4                          3197  
000036D4                          3198          ; D5 should hold the position 11-9, which is the register, since D5 originaly hold bit from position 11-6 and we shift right 3 times.
000036D4                          3199          ; D0 will hold the register number for LEA opcode
000036D4                          3200  
000036D4  2005                    3201              MOVE.L  D5,D0          ; D0 will hold the register number for LEA opcode
000036D6                          3202  
000036D6  7803                    3203              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
000036D8  4EB9 00004856           3204              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
000036DE                          3205  
000036DE  BABC 00000002           3206              CMP.L   #2,D5          ; if position 5-3 is two the EA for LEA is (An) mode 2
000036E4  6700 0012               3207              BEQ     Lea_M2_Opcode
000036E8                          3208  
000036E8  BABC 00000007           3209              CMP.L   #7,D5          ; if position 5-3 is 7 the EA for LEA is mode 7
000036EE  6700 0030               3210              BEQ     Lea_M7_Opcode
000036F2                          3211  
000036F2  4EF9 0000484E           3212              JMP     InvalidOpcode  ; if it is not mode 7 or mode 2, LEA is invaid
000036F8                          3213  
000036F8                          3214  Lea_M2_Opcode
000036F8  7803                    3215              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000036FA  4EB9 00004856           3216              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003700  4EB9 00004AB4           3217              JSR     PrintLEA
00003706  4EB9 00004BB6           3218              JSR     PrintSpace
0000370C  4EB9 000049E8           3219              JSR     PrintIndirAddrReg
00003712                          3220  
00003712  1A00                    3221              MOVE.B  D0,D5
00003714  12EE 0025               3222              MOVE.B  37(A6),(A1)+             *,
00003718  4EB9 000049DC           3223              JSR     PrintAddrReg
0000371E  4E75                    3224              RTS                     ; return to input to get more input
00003720                          3225  
00003720                          3226  Lea_M7_Opcode
00003720  7803                    3227              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003722  4EB9 00004856           3228              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003728                          3229  
00003728  BABC 00000000           3230              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for LEA is (xxx).W
0000372E  6700 0012               3231              BEQ     Lea_xxxW_Opcode
00003732                          3232  
00003732  BABC 00000001           3233              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for LEA is (xxx).L
00003738  6700 0028               3234              BEQ     Lea_xxxL_Opcode
0000373C                          3235  
0000373C  4EF9 0000484E           3236              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, LEA is invaid
00003742                          3237  
00003742                          3238  Lea_xxxW_Opcode
00003742  4EB9 00004AB4           3239              JSR     PrintLEA
00003748  4EB9 00004BB6           3240              JSR     PrintSpace
0000374E  4EB9 00004950           3241              JSR     PrintByteOrWord
00003754                          3242  
00003754  1A00                    3243              MOVE.B  D0,D5
00003756  12EE 0025               3244              MOVE.B  37(A6),(A1)+             *,
0000375A  4EB9 000049DC           3245              JSR     PrintAddrReg
00003760  4E75                    3246              RTS                     ; return to input to get more input
00003762                          3247  
00003762                          3248  Lea_xxxL_Opcode
00003762  4EB9 00004AB4           3249              JSR PrintLEA
00003768  4EB9 00004BB6           3250              JSR     PrintSpace
0000376E  4EB9 00004966           3251              JSR     PrintLong
00003774                          3252  
00003774  1A00                    3253              MOVE.B  D0,D5
00003776  12EE 0025               3254              MOVE.B  37(A6),(A1)+             *,
0000377A  4EB9 000049DC           3255              JSR     PrintAddrReg
00003780  4E75                    3256              RTS                     ; return to input to get more input
00003782                          3257  
00003782                          3258  
00003782                          3259  *************************************************                MoveM_R2M_W                *************************************************
00003782                          3260  ; MOVEM.W from register to memory
00003782                          3261  ; first 10 bit is (0100 1000 10## ####)
00003782                          3262  MoveM_R2M_W
00003782  7803                    3263              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003784  4EB9 00004856           3264              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
0000378A                          3265  
0000378A  BABC 00000002           3266              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
00003790  6700 001C               3267              BEQ     MoveM_R2M_W_M2
00003794                          3268  
00003794  BABC 00000004           3269              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
0000379A  6700 0038               3270              BEQ     MoveM_R2M_W_M4
0000379E                          3271  
0000379E  BABC 00000007           3272              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
000037A4  6700 0054               3273              BEQ     MoveM_R2M_W_M7
000037A8                          3274  
000037A8  4EF9 0000484E           3275              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
000037AE                          3276  
000037AE                          3277  MoveM_R2M_W_M2
000037AE  7803                    3278              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000037B0  4EB9 00004856           3279              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000037B6  4EB9 00004B04           3280              JSR     PrintMoveM
000037BC  4EB9 00004B88           3281              JSR     LengthW
000037C2  4EB9 00004BB6           3282              JSR     PrintSpace
000037C8                          3283              ;print <list>
000037C8  12EE 0025               3284              MOVE.B  37(A6),(A1)+             *,
000037CC  4EB9 000049E8           3285              JSR     PrintIndirAddrReg
000037D2  4E75                    3286              RTS                     ; return to input to get more input
000037D4                          3287  
000037D4                          3288  MoveM_R2M_W_M4
000037D4  7803                    3289              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000037D6  4EB9 00004856           3290              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000037DC  4EB9 00004B04           3291              JSR     PrintMoveM
000037E2  4EB9 00004B88           3292              JSR     LengthW
000037E8  4EB9 00004BB6           3293              JSR     PrintSpace
000037EE                          3294              ;print <list>
000037EE  12EE 0025               3295              MOVE.B  37(A6),(A1)+             *,
000037F2  4EB9 00004A00           3296              JSR     PrintPreDeincAddrReg
000037F8  4E75                    3297              RTS                     ; return to input to get more input
000037FA                          3298  
000037FA                          3299  MoveM_R2M_W_M7
000037FA  7803                    3300              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000037FC  4EB9 00004856           3301              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003802                          3302  
00003802  BABC 00000000           3303              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
00003808  6700 0012               3304              BEQ     MoveM_R2M_W_xxxW
0000380C                          3305  
0000380C  BABC 00000001           3306              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
00003812  6700 0026               3307              BEQ     MoveM_R2M_W_xxxL
00003816                          3308  
00003816  4EF9 0000484E           3309              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
0000381C                          3310  
0000381C                          3311  MoveM_R2M_W_xxxW
0000381C  4EB9 00004B04           3312              JSR PrintMoveM
00003822  4EB9 00004B88           3313              JSR LengthW
00003828  4EB9 00004BB6           3314              JSR     PrintSpace
0000382E                          3315              ;print <list>
0000382E  12EE 0025               3316              MOVE.B  37(A6),(A1)+             *,
00003832  4EB9 00004950           3317              JSR     PrintByteOrWord
00003838  4E75                    3318              RTS                     ; return to input to get more input
0000383A                          3319  
0000383A                          3320  MoveM_R2M_W_xxxL
0000383A  4EB9 00004B04           3321              JSR PrintMoveM
00003840  4EB9 00004B88           3322              JSR LengthW
00003846  4EB9 00004BB6           3323              JSR     PrintSpace
0000384C                          3324              ;print <list>
0000384C  12EE 0025               3325              MOVE.B  37(A6),(A1)+             *,
00003850  4EB9 00004966           3326              JSR     PrintLong
00003856  4E75                    3327              RTS                     ; return to input to get more input
00003858                          3328  
00003858                          3329  
00003858                          3330  *************************************************                MoveM_R2M_L                *************************************************
00003858                          3331  ; MOVEM.L from register to memory
00003858                          3332  ; first 10 bit is (0100 1000 11## ####)
00003858                          3333  MoveM_R2M_L
00003858  7803                    3334              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
0000385A  4EB9 00004856           3335              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003860                          3336  
00003860  BABC 00000002           3337              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
00003866  6700 001C               3338              BEQ     MoveM_R2M_L_M2
0000386A                          3339  
0000386A  BABC 00000004           3340              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
00003870  6700 0038               3341              BEQ     MoveM_R2M_L_M4
00003874                          3342  
00003874  BABC 00000007           3343              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
0000387A  6700 0054               3344              BEQ     MoveM_R2M_L_M7
0000387E                          3345  
0000387E  4EF9 0000484E           3346              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
00003884                          3347  
00003884                          3348  MoveM_R2M_L_M2
00003884  7803                    3349              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003886  4EB9 00004856           3350              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000388C  4EB9 00004B04           3351              JSR PrintMoveM
00003892  4EB9 00004B92           3352              JSR LengthL
00003898  4EB9 00004BB6           3353              JSR     PrintSpace
0000389E                          3354              ;print <list>
0000389E  12EE 0025               3355              MOVE.B  37(A6),(A1)+             *,
000038A2  4EB9 000049E8           3356              JSR     PrintIndirAddrReg
000038A8  4E75                    3357              RTS                     ; return to input to get more input
000038AA                          3358  
000038AA                          3359  MoveM_R2M_L_M4
000038AA  7803                    3360              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000038AC  4EB9 00004856           3361              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000038B2  4EB9 00004B04           3362              JSR PrintMoveM
000038B8  4EB9 00004B92           3363              JSR LengthL
000038BE  4EB9 00004BB6           3364              JSR     PrintSpace
000038C4                          3365              ;print <list>
000038C4  12EE 0025               3366              MOVE.B  37(A6),(A1)+             *,
000038C8  4EB9 00004A00           3367              JSR     PrintPreDeincAddrReg
000038CE  4E75                    3368              RTS                     ; return to input to get more input
000038D0                          3369  
000038D0                          3370  MoveM_R2M_L_M7
000038D0  7803                    3371              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000038D2  4EB9 00004856           3372              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000038D8                          3373  
000038D8  BABC 00000000           3374              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
000038DE  6700 0012               3375              BEQ     MoveM_R2M_L_xxxW
000038E2                          3376  
000038E2  BABC 00000001           3377              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
000038E8  6700 0026               3378              BEQ     MoveM_R2M_L_xxxL
000038EC                          3379  
000038EC  4EF9 0000484E           3380              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
000038F2                          3381  
000038F2                          3382  MoveM_R2M_L_xxxW
000038F2  4EB9 00004B04           3383              JSR PrintMoveM
000038F8  4EB9 00004B92           3384              JSR LengthL
000038FE  4EB9 00004BB6           3385              JSR     PrintSpace
00003904                          3386              ;print <list>
00003904  12EE 0025               3387              MOVE.B  37(A6),(A1)+             *,
00003908  4EB9 00004950           3388              JSR     PrintByteOrWord
0000390E  4E75                    3389              RTS                     ; return to input to get more input
00003910                          3390  
00003910                          3391  MoveM_R2M_L_xxxL
00003910  4EB9 00004B04           3392              JSR PrintMoveM
00003916  4EB9 00004B92           3393              JSR LengthL
0000391C  4EB9 00004BB6           3394              JSR     PrintSpace
00003922                          3395              ;print <list>
00003922  12EE 0025               3396              MOVE.B  37(A6),(A1)+             *,
00003926  4EB9 00004966           3397              JSR     PrintLong
0000392C  4E75                    3398              RTS                     ; return to input to get more input
0000392E                          3399  
0000392E                          3400  *************************************************                MoveM_M2R_W                *************************************************
0000392E                          3401  ; MOVEM.W from memory to register
0000392E                          3402  ; first 10 bit is (0100 1100 10## ####)
0000392E                          3403  MoveM_M2R_W
0000392E  7803                    3404              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003930  4EB9 00004856           3405              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003936                          3406  
00003936  BABC 00000002           3407              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
0000393C  6700 001C               3408              BEQ     MoveM_M2R_W_M2
00003940                          3409  
00003940  BABC 00000004           3410              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
00003946  6700 0038               3411              BEQ     MoveM_M2R_W_M4
0000394A                          3412  
0000394A  BABC 00000007           3413              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
00003950  6700 0054               3414              BEQ     MoveM_M2R_W_M7
00003954                          3415  
00003954  4EF9 0000484E           3416              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
0000395A                          3417  
0000395A                          3418  MoveM_M2R_W_M2
0000395A  7803                    3419              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000395C  4EB9 00004856           3420              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003962  4EB9 00004B04           3421              JSR     PrintMoveM
00003968  4EB9 00004B88           3422              JSR     LengthW
0000396E  4EB9 00004BB6           3423              JSR     PrintSpace
00003974  4EB9 000049E8           3424              JSR     PrintIndirAddrReg
0000397A                          3425  
0000397A  12EE 0025               3426              MOVE.B  37(A6),(A1)+             *,
0000397E                          3427              ;print <list>
0000397E  4E75                    3428              RTS                     ; return to input to get more input
00003980                          3429  
00003980                          3430  MoveM_M2R_W_M4
00003980  7803                    3431              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003982  4EB9 00004856           3432              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003988  4EB9 00004B04           3433              JSR     PrintMoveM
0000398E  4EB9 00004B88           3434              JSR     LengthW
00003994  4EB9 00004BB6           3435              JSR     PrintSpace
0000399A  4EB9 00004A00           3436              JSR     PrintPreDeincAddrReg
000039A0                          3437  
000039A0  12EE 0025               3438              MOVE.B  37(A6),(A1)+             *,
000039A4                          3439              ;print <list>
000039A4  4E75                    3440              RTS                     ; return to input to get more input
000039A6                          3441  
000039A6                          3442  MoveM_M2R_W_M7
000039A6  7803                    3443              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000039A8  4EB9 00004856           3444              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000039AE                          3445  
000039AE  BABC 00000000           3446              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
000039B4  6700 0012               3447              BEQ     MoveM_M2R_W_xxxW
000039B8                          3448  
000039B8  BABC 00000001           3449              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
000039BE  6700 0026               3450              BEQ     MoveM_M2R_W_xxxL
000039C2                          3451  
000039C2  4EF9 0000484E           3452              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
000039C8                          3453  
000039C8                          3454  MoveM_M2R_W_xxxW
000039C8  4EB9 00004B04           3455              JSR     PrintMoveM
000039CE  4EB9 00004B88           3456              JSR     LengthW
000039D4  4EB9 00004BB6           3457              JSR     PrintSpace
000039DA  4EB9 00004950           3458              JSR     PrintByteOrWord
000039E0                          3459  
000039E0  12EE 0025               3460              MOVE.B  37(A6),(A1)+             *,
000039E4                          3461              ;print <list>
000039E4  4E75                    3462              RTS                     ; return to input to get more input
000039E6                          3463  
000039E6                          3464  MoveM_M2R_W_xxxL
000039E6  4EB9 00004B04           3465              JSR     PrintMoveM
000039EC  4EB9 00004B88           3466              JSR     LengthW
000039F2  4EB9 00004BB6           3467              JSR     PrintSpace
000039F8  4EB9 00004966           3468              JSR     PrintLong
000039FE                          3469  
000039FE  12EE 0025               3470              MOVE.B  37(A6),(A1)+             *,
00003A02                          3471              ;print <list>
00003A02  4E75                    3472              RTS                     ; return to input to get more input
00003A04                          3473  
00003A04                          3474  *************************************************                MoveM_M2R_L                *************************************************
00003A04                          3475  ; MOVEM.L from memory to register
00003A04                          3476  ; first 10 bit is (0100 1100 11## ####)
00003A04                          3477  MoveM_M2R_L
00003A04  7803                    3478              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003A06  4EB9 00004856           3479              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003A0C                          3480  
00003A0C  BABC 00000002           3481              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
00003A12  6700 001C               3482              BEQ     MoveM_M2R_L_M2
00003A16                          3483  
00003A16  BABC 00000004           3484              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
00003A1C  6700 0038               3485              BEQ     MoveM_M2R_L_M4
00003A20                          3486  
00003A20  BABC 00000007           3487              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
00003A26  6700 0054               3488              BEQ     MoveM_M2R_L_M7
00003A2A                          3489  
00003A2A  4EF9 0000484E           3490              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
00003A30                          3491  
00003A30                          3492  MoveM_M2R_L_M2
00003A30  7803                    3493              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003A32  4EB9 00004856           3494              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003A38  4EB9 00004B04           3495              JSR     PrintMoveM
00003A3E  4EB9 00004B92           3496              JSR     LengthL
00003A44  4EB9 00004BB6           3497              JSR     PrintSpace
00003A4A  4EB9 000049E8           3498              JSR     PrintIndirAddrReg
00003A50                          3499  
00003A50  12EE 0025               3500              MOVE.B  37(A6),(A1)+             *,
00003A54                          3501              ;print <list>
00003A54  4E75                    3502              RTS                     ; return to input to get more input
00003A56                          3503  
00003A56                          3504  MoveM_M2R_L_M4
00003A56  7803                    3505              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003A58  4EB9 00004856           3506              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003A5E  4EB9 00004B04           3507              JSR     PrintMoveM
00003A64  4EB9 00004B92           3508              JSR     LengthL
00003A6A  4EB9 00004BB6           3509              JSR     PrintSpace
00003A70  4EB9 00004A00           3510              JSR     PrintPreDeincAddrReg
00003A76                          3511  
00003A76  12EE 0025               3512              MOVE.B  37(A6),(A1)+             *,
00003A7A                          3513              ;print <list>
00003A7A  4E75                    3514              RTS                     ; return to input to get more input
00003A7C                          3515  
00003A7C                          3516  MoveM_M2R_L_M7
00003A7C  7803                    3517              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003A7E  4EB9 00004856           3518              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003A84                          3519  
00003A84  BABC 00000000           3520              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
00003A8A  6700 0012               3521              BEQ     MoveM_M2R_L_xxxW
00003A8E                          3522  
00003A8E  BABC 00000001           3523              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
00003A94  6700 0026               3524              BEQ     MoveM_M2R_L_xxxL
00003A98                          3525  
00003A98  4EF9 0000484E           3526              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
00003A9E                          3527  
00003A9E                          3528  MoveM_M2R_L_xxxW
00003A9E  4EB9 00004B04           3529              JSR     PrintMoveM
00003AA4  4EB9 00004B92           3530              JSR     LengthL
00003AAA  4EB9 00004BB6           3531              JSR     PrintSpace
00003AB0  4EB9 00004950           3532              JSR     PrintByteOrWord
00003AB6                          3533  
00003AB6  12EE 0025               3534              MOVE.B  37(A6),(A1)+             *,
00003ABA                          3535              ;print <list>
00003ABA  4E75                    3536              RTS                     ; return to input to get more input
00003ABC                          3537  
00003ABC                          3538  MoveM_M2R_L_xxxL
00003ABC  4EB9 00004B04           3539              JSR     PrintMoveM
00003AC2  4EB9 00004B92           3540              JSR     LengthL
00003AC8  4EB9 00004BB6           3541              JSR     PrintSpace
00003ACE  4EB9 00004966           3542              JSR     PrintLong
00003AD4                          3543  
00003AD4  12EE 0025               3544              MOVE.B  37(A6),(A1)+             *,
00003AD8                          3545              ;print <list>
00003AD8  4E75                    3546              RTS                     ; return to input to get more input
00003ADA                          3547  
00003ADA                          3548  *************************************************                Muls_L                 *************************************************
00003ADA                          3549  ; first 10 bit is (0100 1100 00## ####)
00003ADA  7803                    3550  Muls_L      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003ADC  4EB9 00004856           3551              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003AE2                          3552  
00003AE2  BABC 00000000           3553              CMP.L   #0,D5          ; if position 5-3 is 0 the EA for MULS.L is Dn mode 0
00003AE8  6700 0030               3554              BEQ     Muls_L_M0
00003AEC                          3555  
00003AEC  BABC 00000002           3556              CMP.L   #2,D5          ; if position 5-3 is 2 the EA for MULS.L is (An) mode 2
00003AF2  6700 0054               3557              BEQ     Muls_L_M2
00003AF6                          3558  
00003AF6  BABC 00000003           3559              CMP.L   #3,D5          ; if position 5-3 is 3 the EA for MULS.L is (An)+ mode 3
00003AFC  6700 0078               3560              BEQ     Muls_L_M3
00003B00                          3561  
00003B00  BABC 00000004           3562              CMP.L   #4,D5          ; if position 5-3 is 4 the EA for MULS.L is -(An) mode 4
00003B06  6700 009C               3563              BEQ     Muls_L_M4
00003B0A                          3564  
00003B0A  BABC 00000007           3565              CMP.L   #7,D5          ; if position 5-3 is 7 the EA for MULS.L is mode 7
00003B10  6700 00C0               3566              BEQ     Muls_L_M7
00003B14                          3567  
00003B14  4EF9 0000484E           3568              JMP     InvalidOpcode  ; if it is not one of the moveM EA mode
00003B1A                          3569  
00003B1A  7803                    3570  Muls_L_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003B1C  4EB9 00004856           3571              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003B22  4EB9 00004B0E           3572              JSR     PrintMuls
00003B28  4EB9 00004B92           3573              JSR     LengthL
00003B2E  4EB9 00004BB6           3574              JSR     PrintSpace
00003B34  4EB9 000049D0           3575              JSR     PrintDataReg
00003B3A                          3576  
00003B3A  12EE 0025               3577              MOVE.B  37(A6),(A1)+             *,
00003B3E  385C                    3578              MOVE.W  (A4)+,A4
00003B40  4EB9 000048CE           3579              JSR     PrintAddr
00003B46  4E75                    3580              RTS                     ; return to input to get more input
00003B48                          3581  
00003B48  7803                    3582  Muls_L_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003B4A  4EB9 00004856           3583              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003B50  4EB9 00004B0E           3584              JSR     PrintMuls
00003B56  4EB9 00004B92           3585              JSR     LengthL
00003B5C  4EB9 00004BB6           3586              JSR     PrintSpace
00003B62  4EB9 000049E8           3587              JSR     PrintIndirAddrReg
00003B68                          3588  
00003B68  12EE 0025               3589              MOVE.B  37(A6),(A1)+             *,
00003B6C  385C                    3590              MOVE.W  (A4)+,A4
00003B6E  4EB9 000048CE           3591              JSR     PrintAddr
00003B74  4E75                    3592              RTS                     ; return to input to get more input
00003B76                          3593  
00003B76  7803                    3594  Muls_L_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003B78  4EB9 00004856           3595              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003B7E  4EB9 00004B0E           3596              JSR     PrintMuls
00003B84  4EB9 00004B92           3597              JSR     LengthL
00003B8A  4EB9 00004BB6           3598              JSR     PrintSpace
00003B90  4EB9 000049F6           3599              JSR     PrintPostIncAddrReg
00003B96                          3600  
00003B96  12EE 0025               3601              MOVE.B  37(A6),(A1)+             *,
00003B9A  385C                    3602              MOVE.W  (A4)+,A4
00003B9C  4EB9 000048CE           3603              JSR     PrintAddr
00003BA2  4E75                    3604              RTS                     ; return to input to get more input
00003BA4                          3605  
00003BA4  7803                    3606  Muls_L_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003BA6  4EB9 00004856           3607              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003BAC  4EB9 00004B0E           3608              JSR     PrintMuls
00003BB2  4EB9 00004B92           3609              JSR     LengthL
00003BB8  4EB9 00004BB6           3610              JSR     PrintSpace
00003BBE  4EB9 00004A00           3611              JSR     PrintPreDeincAddrReg
00003BC4                          3612  
00003BC4  12EE 0025               3613              MOVE.B  37(A6),(A1)+             *,
00003BC8  385C                    3614              MOVE.W  (A4)+,A4
00003BCA  4EB9 000048CE           3615              JSR     PrintAddr
00003BD0  4E75                    3616              RTS                     ; return to input to get more input
00003BD2                          3617  
00003BD2  7803                    3618  Muls_L_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003BD4  4EB9 00004856           3619              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003BDA                          3620  
00003BDA  BABC 00000000           3621              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003BE0  6700 001C               3622              BEQ     Muls_L_xxxW
00003BE4                          3623  
00003BE4  BABC 00000001           3624              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003BEA  6700 0038               3625              BEQ     Muls_L_xxxL
00003BEE                          3626  
00003BEE  BABC 00000004           3627              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00003BF4  6700 0054               3628              BEQ     Muls_L_Data
00003BF8                          3629  
00003BF8  4EF9 0000484E           3630              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1 or 4, MULS.L is invaid
00003BFE                          3631  
00003BFE  4EB9 00004B0E           3632  Muls_L_xxxW JSR     PrintMuls
00003C04  4EB9 00004B92           3633              JSR     LengthL
00003C0A  4EB9 00004BB6           3634              JSR     PrintSpace
00003C10  4EB9 00004950           3635              JSR     PrintByteOrWord
00003C16                          3636  
00003C16  12EE 0025               3637              MOVE.B  37(A6),(A1)+             *,
00003C1A                          3638  
00003C1A  385C                    3639              MOVE.W  (A4)+,A4
00003C1C  4EB9 000048CE           3640              JSR     PrintAddr
00003C22  4E75                    3641              RTS                     ; return to input to get more input
00003C24                          3642  
00003C24  4EB9 00004B0E           3643  Muls_L_xxxL JSR     PrintMuls
00003C2A  4EB9 00004B92           3644              JSR     LengthL
00003C30  4EB9 00004BB6           3645              JSR     PrintSpace
00003C36  4EB9 00004966           3646              JSR     PrintLong
00003C3C                          3647  
00003C3C  12EE 0025               3648              MOVE.B  37(A6),(A1)+             *,
00003C40  385C                    3649              MOVE.W  (A4)+,A4
00003C42  4EB9 000048CE           3650              JSR     PrintAddr
00003C48  4E75                    3651              RTS                     ; return to input to get more input
00003C4A                          3652  
00003C4A  4EB9 00004B0E           3653  Muls_L_Data JSR PrintMuls
00003C50  4EB9 00004B92           3654              JSR LengthL
00003C56  4EB9 00004BB6           3655              JSR     PrintSpace
00003C5C  4EB9 00004944           3656              JSR     PrintImmediateData
00003C62                          3657  
00003C62  12EE 0025               3658              MOVE.B  37(A6),(A1)+             *,
00003C66  385C                    3659              MOVE.W  (A4)+,A4
00003C68  4EB9 000048CE           3660              JSR     PrintAddr
00003C6E  4E75                    3661              RTS                     ; return to input to get more input
00003C70                          3662  
00003C70                          3663  *************************************************                Divu_L                 *************************************************
00003C70                          3664  ; first 10 bit is (0100 1100 01## ####)
00003C70  7803                    3665  Divu_L      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003C72  4EB9 00004856           3666              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003C78                          3667  
00003C78  BABC 00000000           3668              CMP.L   #0,D5          ; if position 5-3 is 0 the EA for MULS.L is Dn mode 0
00003C7E  6700 0030               3669              BEQ     Divu_L_M0
00003C82                          3670  
00003C82  BABC 00000002           3671              CMP.L   #2,D5          ; if position 5-3 is 2 the EA for MULS.L is (An) mode 2
00003C88  6700 0054               3672              BEQ     Divu_L_M2
00003C8C                          3673  
00003C8C  BABC 00000003           3674              CMP.L   #3,D5          ; if position 5-3 is 3 the EA for MULS.L is (An)+ mode 3
00003C92  6700 0078               3675              BEQ     Divu_L_M3
00003C96                          3676  
00003C96  BABC 00000004           3677              CMP.L   #4,D5          ; if position 5-3 is 4 the EA for MULS.L is -(An) mode 4
00003C9C  6700 009C               3678              BEQ     Divu_L_M4
00003CA0                          3679  
00003CA0  BABC 00000007           3680              CMP.L   #7,D5          ; if position 5-3 is 7 the EA for MULS.L is mode 7
00003CA6  6700 00C0               3681              BEQ     Divu_L_M7
00003CAA                          3682  
00003CAA  4EF9 0000484E           3683              JMP     InvalidOpcode  ; if it is not one of the moveM EA mode
00003CB0                          3684  
00003CB0  7803                    3685  Divu_L_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003CB2  4EB9 00004856           3686              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003CB8  4EB9 00004A94           3687              JSR     PrintDivu
00003CBE  4EB9 00004B92           3688              JSR     LengthL
00003CC4  4EB9 00004BB6           3689              JSR     PrintSpace
00003CCA  4EB9 000049D0           3690              JSR     PrintDataReg
00003CD0                          3691  
00003CD0  12EE 0025               3692              MOVE.B  37(A6),(A1)+             *,
00003CD4  385C                    3693              MOVE.W  (A4)+,A4
00003CD6  4EB9 000048CE           3694              JSR     PrintAddr
00003CDC  4E75                    3695              RTS                     ; return to input to get more input
00003CDE                          3696  
00003CDE  7803                    3697  Divu_L_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003CE0  4EB9 00004856           3698              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003CE6  4EB9 00004A94           3699              JSR     PrintDivu
00003CEC  4EB9 00004B92           3700              JSR     LengthL
00003CF2  4EB9 00004BB6           3701              JSR     PrintSpace
00003CF8  4EB9 000049E8           3702              JSR     PrintIndirAddrReg
00003CFE                          3703  
00003CFE  12EE 0025               3704              MOVE.B  37(A6),(A1)+             *,
00003D02  385C                    3705              MOVE.W  (A4)+,A4
00003D04  4EB9 000048CE           3706              JSR     PrintAddr
00003D0A  4E75                    3707              RTS                     ; return to input to get more input
00003D0C                          3708  
00003D0C  7803                    3709  Divu_L_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003D0E  4EB9 00004856           3710              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003D14  4EB9 00004A94           3711              JSR     PrintDivu
00003D1A  4EB9 00004B92           3712              JSR     LengthL
00003D20  4EB9 00004BB6           3713              JSR     PrintSpace
00003D26  4EB9 000049F6           3714              JSR     PrintPostIncAddrReg
00003D2C                          3715  
00003D2C  12EE 0025               3716              MOVE.B  37(A6),(A1)+             *,
00003D30  385C                    3717              MOVE.W  (A4)+,A4
00003D32  4EB9 000048CE           3718              JSR     PrintAddr
00003D38  4E75                    3719              RTS                     ; return to input to get more input
00003D3A                          3720  
00003D3A  7803                    3721  Divu_L_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003D3C  4EB9 00004856           3722              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003D42  4EB9 00004A94           3723              JSR     PrintDivu
00003D48  4EB9 00004B92           3724              JSR     LengthL
00003D4E  4EB9 00004BB6           3725              JSR     PrintSpace
00003D54  4EB9 00004A00           3726              JSR     PrintPreDeincAddrReg
00003D5A                          3727  
00003D5A  12EE 0025               3728              MOVE.B  37(A6),(A1)+             *,
00003D5E  385C                    3729              MOVE.W  (A4)+,A4
00003D60  4EB9 000048CE           3730              JSR     PrintAddr
00003D66  4E75                    3731              RTS                     ; return to input to get more input
00003D68                          3732  
00003D68  7803                    3733  Divu_L_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003D6A  4EB9 00004856           3734              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003D70                          3735  
00003D70  BABC 00000000           3736              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003D76  6700 001C               3737              BEQ     Divu_L_xxxW
00003D7A                          3738  
00003D7A  BABC 00000001           3739              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003D80  6700 0038               3740              BEQ     Divu_L_xxxL
00003D84                          3741  
00003D84  BABC 00000004           3742              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00003D8A  6700 0054               3743              BEQ     Divu_L_Data
00003D8E                          3744  
00003D8E  4EF9 0000484E           3745              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1 or 4, Divu.L is invaid
00003D94                          3746  
00003D94  4EB9 00004A94           3747  Divu_L_xxxW JSR     PrintDivu
00003D9A  4EB9 00004B92           3748              JSR     LengthL
00003DA0  4EB9 00004BB6           3749              JSR     PrintSpace
00003DA6  4EB9 00004950           3750              JSR     PrintByteOrWord
00003DAC                          3751  
00003DAC  12EE 0025               3752              MOVE.B  37(A6),(A1)+             *,
00003DB0  385C                    3753              MOVE.W  (A4)+,A4
00003DB2  4EB9 000048CE           3754              JSR     PrintAddr
00003DB8  4E75                    3755              RTS                     ; return to input to get more input
00003DBA                          3756  
00003DBA  4EB9 00004A94           3757  Divu_L_xxxL JSR     PrintDivu
00003DC0  4EB9 00004B92           3758              JSR     LengthL
00003DC6  4EB9 00004BB6           3759              JSR     PrintSpace
00003DCC  4EB9 00004966           3760              JSR     PrintLong
00003DD2                          3761  
00003DD2  12EE 0025               3762              MOVE.B  37(A6),(A1)+             *,
00003DD6  385C                    3763              MOVE.W  (A4)+,A4
00003DD8  4EB9 000048CE           3764              JSR     PrintAddr
00003DDE  4E75                    3765              RTS                     ; return to input to get more input
00003DE0                          3766  
00003DE0  4EB9 00004A94           3767  Divu_L_Data JSR     PrintDivu
00003DE6  4EB9 00004B92           3768              JSR     LengthL
00003DEC  4EB9 00004BB6           3769              JSR     PrintSpace
00003DF2  4EB9 00004944           3770              JSR     PrintImmediateData
00003DF8                          3771  
00003DF8  12EE 0025               3772              MOVE.B  37(A6),(A1)+             *,
00003DFC  385C                    3773              MOVE.W  (A4)+,A4
00003DFE  4EB9 000048CE           3774              JSR     PrintAddr
00003E04  4E75                    3775              RTS                     ; return to input to get more input
00003E06                          3776  
00003E06                          3777  
00003E06                          3778  *************************************************                JSR_Opcode             *************************************************
00003E06                          3779  ; first 10 bit is (0100 1110 10## ####)
00003E06  7803                    3780  JSR_Opcode  MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003E08  4EB9 00004856           3781              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003E0E                          3782  
00003E0E  BABC 00000002           3783              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An) mode 2
00003E14  6700 0012               3784              BEQ     JSR_M2
00003E18                          3785  
00003E18  BABC 00000007           3786              CMP.L   #7,D5          ; if position 5-3 is 2 the EA is (An) mode 2
00003E1E  6700 0024               3787              BEQ     JSR_M7
00003E22                          3788  
00003E22  4EF9 0000484E           3789              JMP     InvalidOpcode  ; if it is not a valid JSR EA mode if it is not 2 or 7
00003E28                          3790  
00003E28  7803                    3791  JSR_M2      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003E2A  4EB9 00004856           3792              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003E30  4EB9 00004AA6           3793              JSR     PrintJSR
00003E36  4EB9 00004BB6           3794              JSR     PrintSpace
00003E3C  4EB9 000049E8           3795              JSR     PrintIndirAddrReg
00003E42  4E75                    3796              RTS                     ; return to input to get more input
00003E44                          3797  
00003E44  7803                    3798  JSR_M7      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003E46  4EB9 00004856           3799              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003E4C                          3800  
00003E4C  BABC 00000000           3801              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003E52  6700 0012               3802              BEQ     JSR_xxxW
00003E56                          3803  
00003E56  BABC 00000001           3804              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003E5C  6700 001C               3805              BEQ     JSR_xxxL
00003E60                          3806  
00003E60  4EF9 0000484E           3807              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid JSR EA mode
00003E66                          3808  
00003E66  4EB9 00004AA6           3809  JSR_xxxW    JSR     PrintJSR
00003E6C  4EB9 00004BB6           3810              JSR     PrintSpace
00003E72  4EB9 00004950           3811              JSR     PrintByteOrWord
00003E78  4E75                    3812              RTS                     ; return to input to get more input
00003E7A                          3813  
00003E7A  4EB9 00004AA6           3814  JSR_xxxL    JSR     PrintJSR
00003E80  4EB9 00004BB6           3815              JSR     PrintSpace
00003E86  4EB9 00004966           3816              JSR     PrintLong
00003E8C  4E75                    3817              RTS                     ; return to input to get more input
00003E8E                          3818  
00003E8E                          3819  
00003E8E                          3820  *************************************************                Not_B_Opcode           *************************************************
00003E8E                          3821  ; first 10 bit is (0100 0110 00## ####)
00003E8E                          3822  Not_B_Opcode
00003E8E  7803                    3823              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003E90  4EB9 00004856           3824              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003E96                          3825  
00003E96  BABC 00000000           3826              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
00003E9C  6700 0030               3827              BEQ     Not_B_M0
00003EA0                          3828  
00003EA0  BABC 00000002           3829              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
00003EA6  6700 0048               3830              BEQ     Not_B_M2
00003EAA                          3831  
00003EAA  BABC 00000003           3832              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00003EB0  6700 0060               3833              BEQ     Not_B_M3
00003EB4                          3834  
00003EB4  BABC 00000004           3835              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
00003EBA  6700 0078               3836              BEQ     Not_B_M4
00003EBE                          3837  
00003EBE  BABC 00000007           3838              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode is 7
00003EC4  6700 0090               3839              BEQ     Not_B_M7
00003EC8                          3840  
00003EC8  4EF9 0000484E           3841              JMP     InvalidOpcode  ; if it is not a valid NOT EA mode if it is not 0 2 3 4 7
00003ECE                          3842  
00003ECE  7803                    3843  Not_B_M0    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003ED0  4EB9 00004856           3844              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003ED6  4EB9 00004B2E           3845              JSR     PrintNot
00003EDC  4EB9 00004B7E           3846              JSR     LengthB
00003EE2  4EB9 00004BB6           3847              JSR     PrintSpace
00003EE8  4EB9 000049D0           3848              JSR     PrintDataReg
00003EEE  4E75                    3849              RTS                     ; return to input to get more input
00003EF0                          3850  
00003EF0  7803                    3851  Not_B_M2    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003EF2  4EB9 00004856           3852              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003EF8  4EB9 00004B2E           3853              JSR     PrintNot
00003EFE  4EB9 00004B7E           3854              JSR     LengthB
00003F04  4EB9 00004BB6           3855              JSR     PrintSpace
00003F0A  4EB9 000049E8           3856              JSR     PrintIndirAddrReg
00003F10  4E75                    3857              RTS                     ; return to input to get more input
00003F12                          3858  
00003F12  7803                    3859  Not_B_M3    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003F14  4EB9 00004856           3860              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003F1A  4EB9 00004B2E           3861              JSR     PrintNot
00003F20  4EB9 00004B7E           3862              JSR     LengthB
00003F26  4EB9 00004BB6           3863              JSR     PrintSpace
00003F2C  4EB9 000049F6           3864              JSR     PrintPostIncAddrReg
00003F32  4E75                    3865              RTS                     ; return to input to get more input
00003F34                          3866  
00003F34  7803                    3867  Not_B_M4    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003F36  4EB9 00004856           3868              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003F3C  4EB9 00004B2E           3869              JSR     PrintNot
00003F42  4EB9 00004B7E           3870              JSR     LengthB
00003F48  4EB9 00004BB6           3871              JSR     PrintSpace
00003F4E  4EB9 00004A00           3872              JSR     PrintPreDeincAddrReg
00003F54  4E75                    3873              RTS                     ; return to input to get more input
00003F56                          3874  
00003F56  7803                    3875  Not_B_M7    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003F58  4EB9 00004856           3876              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003F5E                          3877  
00003F5E  BABC 00000000           3878              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003F64  6700 0012               3879              BEQ     Not_B_xxxW
00003F68                          3880  
00003F68  BABC 00000001           3881              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003F6E  6700 0022               3882              BEQ     Not_B_xxxL
00003F72                          3883  
00003F72  4EF9 0000484E           3884              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid NOT EA mode
00003F78                          3885  
00003F78  4EB9 00004B2E           3886  Not_B_xxxW  JSR     PrintNot
00003F7E  4EB9 00004B7E           3887              JSR     LengthB
00003F84  4EB9 00004BB6           3888              JSR     PrintSpace
00003F8A  4EB9 00004950           3889              JSR     PrintByteOrWord
00003F90  4E75                    3890              RTS                     ; return to input to get more input
00003F92                          3891  
00003F92  4EB9 00004B2E           3892  Not_B_xxxL  JSR     PrintNot
00003F98  4EB9 00004B7E           3893              JSR     LengthB
00003F9E  4EB9 00004BB6           3894              JSR     PrintSpace
00003FA4  4EB9 00004966           3895              JSR     PrintLong
00003FAA  4E75                    3896              RTS                     ; return to input to get more input
00003FAC                          3897  
00003FAC                          3898  
00003FAC                          3899  *************************************************                Not_W_Opcode           *************************************************
00003FAC                          3900  ; first 10 bit is (0100 0110 01## ####)
00003FAC                          3901  Not_W_Opcode
00003FAC  7803                    3902              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003FAE  4EB9 00004856           3903              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003FB4                          3904  
00003FB4  BABC 00000000           3905              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
00003FBA  6700 0030               3906              BEQ     Not_W_M0
00003FBE                          3907  
00003FBE  BABC 00000002           3908              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
00003FC4  6700 0048               3909              BEQ     Not_W_M2
00003FC8                          3910  
00003FC8  BABC 00000003           3911              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00003FCE  6700 0060               3912              BEQ     Not_W_M3
00003FD2                          3913  
00003FD2  BABC 00000004           3914              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
00003FD8  6700 0078               3915              BEQ     Not_W_M4
00003FDC                          3916  
00003FDC  BABC 00000007           3917              CMP.L   #7,D5          ; if position 5-3 is 7 the EA mode is 7
00003FE2  6700 0090               3918              BEQ     Not_W_M7
00003FE6                          3919  
00003FE6  4EF9 0000484E           3920              JMP     InvalidOpcode  ; if it is not a valid NOT EA mode if it is not 0 2 3 4 7
00003FEC                          3921  
00003FEC  7803                    3922  Not_W_M0    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003FEE  4EB9 00004856           3923              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003FF4  4EB9 00004B2E           3924              JSR     PrintNot
00003FFA  4EB9 00004B88           3925              JSR     LengthW
00004000  4EB9 00004BB6           3926              JSR     PrintSpace
00004006  4EB9 000049D0           3927              JSR     PrintDataReg
0000400C  4E75                    3928              RTS                     ; return to input to get more input
0000400E                          3929  
0000400E  7803                    3930  Not_W_M2    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004010  4EB9 00004856           3931              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004016  4EB9 00004B2E           3932              JSR     PrintNot
0000401C  4EB9 00004B88           3933              JSR     LengthW
00004022  4EB9 00004BB6           3934              JSR     PrintSpace
00004028  4EB9 000049E8           3935              JSR     PrintIndirAddrReg
0000402E  4E75                    3936              RTS                     ; return to input to get more input
00004030                          3937  
00004030  7803                    3938  Not_W_M3    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004032  4EB9 00004856           3939              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004038  4EB9 00004B2E           3940              JSR     PrintNot
0000403E  4EB9 00004B88           3941              JSR     LengthW
00004044  4EB9 00004BB6           3942              JSR     PrintSpace
0000404A  4EB9 000049F6           3943              JSR     PrintPostIncAddrReg
00004050  4E75                    3944              RTS                     ; return to input to get more input
00004052                          3945  
00004052  7803                    3946  Not_W_M4    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004054  4EB9 00004856           3947              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000405A  4EB9 00004B2E           3948              JSR     PrintNot
00004060  4EB9 00004B88           3949              JSR     LengthW
00004066  4EB9 00004BB6           3950              JSR     PrintSpace
0000406C  4EB9 00004A00           3951              JSR     PrintPreDeincAddrReg
00004072  4E75                    3952              RTS                     ; return to input to get more input
00004074                          3953  
00004074  7803                    3954  Not_W_M7    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004076  4EB9 00004856           3955              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000407C                          3956  
0000407C  BABC 00000000           3957              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00004082  6700 0012               3958              BEQ     Not_W_xxxW
00004086                          3959  
00004086  BABC 00000001           3960              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
0000408C  6700 0022               3961              BEQ     Not_W_xxxL
00004090                          3962  
00004090  4EF9 0000484E           3963              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid NOT EA mode
00004096                          3964  
00004096  4EB9 00004B2E           3965  Not_W_xxxW  JSR     PrintNot
0000409C  4EB9 00004B88           3966              JSR     LengthW
000040A2  4EB9 00004BB6           3967              JSR     PrintSpace
000040A8  4EB9 00004950           3968              JSR     PrintByteOrWord
000040AE  4E75                    3969              RTS                     ; return to input to get more input
000040B0                          3970  
000040B0  4EB9 00004B2E           3971  Not_W_xxxL  JSR     PrintNot
000040B6  4EB9 00004B88           3972              JSR     LengthW
000040BC  4EB9 00004BB6           3973              JSR     PrintSpace
000040C2  4EB9 00004966           3974              JSR     PrintLong
000040C8  4E75                    3975              RTS                     ; return to input to get more input
000040CA                          3976  
000040CA                          3977  
000040CA                          3978  *************************************************                Not_L_Opcode           *************************************************
000040CA                          3979  ; first 10 bit is (0100 0110 10## ####)
000040CA                          3980  Not_L_Opcode
000040CA  7803                    3981              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
000040CC  4EB9 00004856           3982              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
000040D2                          3983  
000040D2  BABC 00000000           3984              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
000040D8  6700 0030               3985              BEQ     Not_L_M0
000040DC                          3986  
000040DC  BABC 00000002           3987              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
000040E2  6700 0048               3988              BEQ     Not_L_M2
000040E6                          3989  
000040E6  BABC 00000003           3990              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
000040EC  6700 0060               3991              BEQ     Not_L_M3
000040F0                          3992  
000040F0  BABC 00000004           3993              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
000040F6  6700 0078               3994              BEQ     Not_L_M4
000040FA                          3995  
000040FA  BABC 00000007           3996              CMP.L   #7,D5          ; if position 5-3 is 7 the EA mode is 7
00004100  6700 0090               3997              BEQ     Not_L_M7
00004104                          3998  
00004104  4EF9 0000484E           3999              JMP     InvalidOpcode  ; if it is not a valid NOT EA mode if it is not 0 2 3 4 7
0000410A                          4000  
0000410A  7803                    4001  Not_L_M0    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000410C  4EB9 00004856           4002              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004112  4EB9 00004B2E           4003              JSR     PrintNot
00004118  4EB9 00004B92           4004              JSR     LengthL
0000411E  4EB9 00004BB6           4005              JSR     PrintSpace
00004124  4EB9 000049D0           4006              JSR     PrintDataReg
0000412A  4E75                    4007              RTS                     ; return to input to get more input
0000412C                          4008  
0000412C  7803                    4009  Not_L_M2    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000412E  4EB9 00004856           4010              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004134  4EB9 00004B2E           4011              JSR     PrintNot
0000413A  4EB9 00004B92           4012              JSR     LengthL
00004140  4EB9 00004BB6           4013              JSR     PrintSpace
00004146  4EB9 000049E8           4014              JSR     PrintIndirAddrReg
0000414C  4E75                    4015              RTS                     ; return to input to get more input
0000414E                          4016  
0000414E  7803                    4017  Not_L_M3    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004150  4EB9 00004856           4018              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004156  4EB9 00004B2E           4019              JSR     PrintNot
0000415C  4EB9 00004B92           4020              JSR     LengthL
00004162  4EB9 00004BB6           4021              JSR     PrintSpace
00004168  4EB9 000049F6           4022              JSR     PrintPostIncAddrReg
0000416E  4E75                    4023              RTS                     ; return to input to get more input
00004170                          4024  
00004170  7803                    4025  Not_L_M4    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004172  4EB9 00004856           4026              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004178  4EB9 00004B2E           4027              JSR     PrintNot
0000417E  4EB9 00004B92           4028              JSR     LengthL
00004184  4EB9 00004BB6           4029              JSR     PrintSpace
0000418A  4EB9 00004A00           4030              JSR     PrintPreDeincAddrReg
00004190  4E75                    4031              RTS                     ; return to input to get more input
00004192                          4032  
00004192  7803                    4033  Not_L_M7    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004194  4EB9 00004856           4034              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000419A                          4035  
0000419A  BABC 00000000           4036              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
000041A0  6700 0012               4037              BEQ     Not_L_xxxW
000041A4                          4038  
000041A4  BABC 00000001           4039              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
000041AA  6700 0022               4040              BEQ     Not_L_xxxL
000041AE                          4041  
000041AE  4EF9 0000484E           4042              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid NOT EA mode
000041B4                          4043  
000041B4  4EB9 00004B2E           4044  Not_L_xxxW  JSR     PrintNot
000041BA  4EB9 00004B92           4045              JSR     LengthL
000041C0  4EB9 00004BB6           4046              JSR     PrintSpace
000041C6  4EB9 00004950           4047              JSR     PrintByteOrWord
000041CC  4E75                    4048              RTS                     ; return to input to get more input
000041CE                          4049  
000041CE  4EB9 00004B2E           4050  Not_L_xxxL  JSR     PrintNot
000041D4  4EB9 00004B92           4051              JSR     LengthL
000041DA  4EB9 00004BB6           4052              JSR     PrintSpace
000041E0  4EB9 00004966           4053              JSR     PrintLong
000041E6  4E75                    4054              RTS                     ; return to input to get more input
000041E8                          4055  
000041E8                          4056  
000041E8                          4057  *************************************************                MOVE_W_Opcode          *************************************************
000041E8                          4058  ; first four bit is (0011 #### #### ####)
000041E8                          4059  MOVE_W_Opcode
000041E8  7803                    4060              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
000041EA  4EB9 00004856           4061              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination register
000041F0                          4062  
000041F0  2005                    4063              MOVE.L  D5,D0               ; D0 will hold the destination register
000041F2                          4064          ; D0 will hold the destination register (position 11-9)
000041F2                          4065  
000041F2  7803                    4066              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
000041F4  4EB9 00004856           4067              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination mode
000041FA                          4068  
000041FA  BABC 00000001           4069              CMP.L   #1,D5               ; destination mode can't be mode one
00004200  6700 064C               4070              BEQ     InvalidOpcode
00004204                          4071  
00004204  BABC 00000005           4072              CMP.L   #5,D5               ; destination mode can't be mode 5
0000420A  6700 0642               4073              BEQ     InvalidOpcode
0000420E                          4074  
0000420E  BABC 00000006           4075              CMP.L   #6,D5               ; destination mode can't be mode 6
00004214  6700 0638               4076              BEQ     InvalidOpcode
00004218                          4077  
00004218  BABC 00000007           4078              CMP.L   #7,D5               ; if destination mode is 7, we need to check the register. the lable is in
0000421E  6700 0048               4079              BEQ     MOVE_W_DesM7_Check
00004222                          4080  
00004222                          4081  Continue_MOVE_W
00004222  2205                    4082              MOVE.L  D5,D1               ; D1 will hold the destination mode
00004224                          4083          ; D1 will hold the destination mode (position 8-6)
00004224                          4084  
00004224  7803                    4085              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00004226  4EB9 00004856           4086              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the source mode
0000422C                          4087  
0000422C  BABC 00000000           4088              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
00004232  6700 0040               4089              BEQ     MOVE_W_M0
00004236                          4090  
00004236  BABC 00000001           4091              CMP.L   #1,D5          ; if position 5-3 is 1 the EA is An
0000423C  6700 0062               4092              BEQ     MOVE_W_M1
00004240                          4093  
00004240  BABC 00000002           4094              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
00004246  6700 0084               4095              BEQ     MOVE_W_M2
0000424A                          4096  
0000424A  BABC 00000003           4097              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00004250  6700 00A6               4098              BEQ     MOVE_W_M3
00004254                          4099  
00004254  BABC 00000004           4100              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
0000425A  6700 00C8               4101              BEQ     MOVE_W_M4
0000425E                          4102  
0000425E  BABC 00000007           4103              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode 7
00004264  6700 0176               4104              BEQ     MOVE_W_M7
00004268                          4105  
00004268                          4106  MOVE_W_DesM7_Check
00004268  B0BC 00000001           4107              CMP.L   #1,D0               ; if destination mode is 7, and register is bigger than 1 it is invalid
0000426E  6E00 05DE               4108              BGT     InvalidOpcode
00004272                          4109  
00004272  60AE                    4110              BRA     Continue_MOVE_W     ; if it is good then continue to decode move
00004274                          4111  
00004274  7803                    4112  MOVE_W_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004276  4EB9 00004856           4113              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000427C  4EB9 00004ADE           4114              JSR     PrintMove
00004282  4EB9 00004B88           4115              JSR     LengthW
00004288  4EB9 00004BB6           4116              JSR     PrintSpace
0000428E  4EB9 000049D0           4117              JSR     PrintDataReg
00004294                          4118  
00004294  12EE 0025               4119              MOVE.B  37(A6),(A1)+             *,
00004298  4EB9 00004350           4120              JSR CheckDest
0000429E  4E75                    4121              RTS                     ; return to input to get more input
000042A0                          4122  
000042A0  7803                    4123  MOVE_W_M1   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000042A2  4EB9 00004856           4124              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000042A8  4EB9 00004ADE           4125              JSR     PrintMove
000042AE  4EB9 00004B88           4126              JSR     LengthW
000042B4  4EB9 00004BB6           4127              JSR     PrintSpace
000042BA  4EB9 000049DC           4128              JSR     PrintAddrReg
000042C0                          4129  
000042C0  12EE 0025               4130              MOVE.B  37(A6),(A1)+             *,
000042C4  4EB9 00004350           4131              JSR CheckDest
000042CA  4E75                    4132              RTS                     ; return to input to get more input
000042CC                          4133  
000042CC  7803                    4134  MOVE_W_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000042CE  4EB9 00004856           4135              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000042D4  4EB9 00004ADE           4136              JSR     PrintMove
000042DA  4EB9 00004B88           4137              JSR     LengthW
000042E0  4EB9 00004BB6           4138              JSR     PrintSpace
000042E6  4EB9 000049E8           4139              JSR     PrintIndirAddrReg
000042EC                          4140  
000042EC  12EE 0025               4141              MOVE.B  37(A6),(A1)+             *,
000042F0  4EB9 00004350           4142              JSR CheckDest
000042F6  4E75                    4143              RTS                     ; return to input to get more input
000042F8                          4144  
000042F8  7803                    4145  MOVE_W_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000042FA  4EB9 00004856           4146              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004300  4EB9 00004ADE           4147              JSR     PrintMove
00004306  4EB9 00004B88           4148              JSR     LengthW
0000430C  4EB9 00004BB6           4149              JSR     PrintSpace
00004312  4EB9 000049F6           4150              JSR     PrintPostIncAddrReg
00004318                          4151  
00004318  12EE 0025               4152              MOVE.B  37(A6),(A1)+             *,
0000431C  4EB9 00004350           4153              JSR CheckDest
00004322  4E75                    4154              RTS                     ; return to input to get more input
00004324                          4155  
00004324  7803                    4156  MOVE_W_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004326  4EB9 00004856           4157              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000432C  4EB9 00004ADE           4158              JSR     PrintMove
00004332  4EB9 00004B88           4159              JSR     LengthW
00004338  4EB9 00004BB6           4160              JSR     PrintSpace
0000433E  4EB9 00004A00           4161              JSR     PrintPreDeincAddrReg
00004344                          4162  
00004344  12EE 0025               4163              MOVE.B  37(A6),(A1)+             *,
00004348  4EB9 00004350           4164              JSR CheckDest
0000434E  4E75                    4165              RTS                     ; return to input to get more input
00004350                          4166  
00004350                          4167  CheckDest
00004350  B2BC 00000000           4168              CMP.L   #0,D1          ; if position 5-3 is 0 the EA is Dn
00004356  6700 0036               4169              BEQ     DestDn
0000435A                          4170  
0000435A  B2BC 00000001           4171              CMP.L   #1,D1          ; if position 5-3 is 1 the EA is An
00004360  6700 04EC               4172              BEQ     InvalidOpcode
00004364                          4173  
00004364  B2BC 00000002           4174              CMP.L   #2,D1          ; if position 5-3 is 2 the EA is (An)
0000436A  6700 002C               4175              BEQ     DestIndirAn
0000436E                          4176  
0000436E  B2BC 00000003           4177              CMP.L   #3,D1          ; if position 5-3 is 3 the EA is (An)+
00004374  6700 002C               4178              BEQ     DestPostIncAn
00004378                          4179  
00004378  B2BC 00000004           4180              CMP.L   #4,D1          ; if position 5-3 is 4 the EA is -(An)
0000437E  6700 002C               4181              BEQ     DestPreDeincAn
00004382                          4182  
00004382  B2BC 00000007           4183              CMP.L   #7,D1          ; if position 5-3 is 7 the EA is mode 7
00004388  6700 002C               4184              BEQ     DestWL
0000438C  4E75                    4185              RTS
0000438E                          4186  
0000438E                          4187  DestDn
0000438E  1A00                    4188              MOVE.B  D0,D5
00004390  4EB9 000049D0           4189              JSR     PrintDataReg
00004396  4E75                    4190              RTS
00004398                          4191  
00004398                          4192  DestIndirAn
00004398  1A00                    4193              MOVE.B  D0,D5
0000439A  4EB9 000049E8           4194              JSR     PrintIndirAddrReg
000043A0  4E75                    4195              RTS
000043A2                          4196  
000043A2                          4197  DestPostIncAn
000043A2  1A00                    4198              MOVE.B  D0,D5
000043A4  4EB9 000049F6           4199              JSR     PrintPostIncAddrReg
000043AA  4E75                    4200              RTS
000043AC                          4201  
000043AC                          4202  DestPreDeincAn
000043AC  1A00                    4203              MOVE.B  D0,D5
000043AE  4EB9 00004A00           4204              JSR     PrintPreDeincAddrReg
000043B4  4E75                    4205              RTS
000043B6                          4206  
000043B6                          4207  DestWL
000043B6  B0BC 00000000           4208              CMP.L   #0,D0
000043BC  6700 000E               4209              BEQ     DestW
000043C0                          4210  
000043C0  B0BC 00000001           4211              CMP.L   #1,D0
000043C6  6700 000C               4212              BEQ     DestL
000043CA                          4213  
000043CA  4E75                    4214              RTS
000043CC                          4215  
000043CC                          4216  DestW
000043CC  4EB9 00004950           4217              JSR     PrintByteOrWord
000043D2  4E75                    4218              RTS
000043D4                          4219  
000043D4                          4220  DestL
000043D4  4EB9 00004966           4221              JSR     PrintLong
000043DA  4E75                    4222              RTS
000043DC                          4223  
000043DC  7803                    4224  MOVE_W_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000043DE  4EB9 00004856           4225              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000043E4                          4226  
000043E4  BABC 00000000           4227              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
000043EA  6700 001C               4228              BEQ     MOVE_W_xxxW
000043EE                          4229  
000043EE  BABC 00000001           4230              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
000043F4  6700 0034               4231              BEQ     MOVE_W_xxxL
000043F8                          4232  
000043F8  BABC 00000004           4233              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
000043FE  6700 004C               4234              BEQ     MOVE_W_data
00004402                          4235  
00004402  4EF9 0000484E           4236              JMP     InvalidOpcode  ; for mode 7 if Source register is not 0 or 1 or 4, it is not a vaid NOT EA mode
00004408                          4237  
00004408  4EB9 00004ADE           4238  MOVE_W_xxxW JSR     PrintMove
0000440E  4EB9 00004B88           4239              JSR     LengthW
00004414  4EB9 00004BB6           4240              JSR     PrintSpace
0000441A  4EB9 00004950           4241              JSR     PrintByteOrWord
00004420                          4242  
00004420  12EE 0025               4243              MOVE.B  37(A6),(A1)+             *,
00004424  4EB8 4350               4244              JSR CheckDest
00004428  4E75                    4245              RTS                     ; return to input to get more input
0000442A                          4246  
0000442A  4EB9 00004ADE           4247  MOVE_W_xxxL JSR     PrintMove
00004430  4EB9 00004B88           4248              JSR     LengthW
00004436  4EB9 00004BB6           4249              JSR     PrintSpace
0000443C  4EB9 00004966           4250              JSR     PrintLong
00004442                          4251  
00004442  12EE 0025               4252              MOVE.B  37(A6),(A1)+             *,
00004446  4EB8 4350               4253              JSR CheckDest
0000444A  4E75                    4254              RTS                     ; return to input to get more input
0000444C                          4255  
0000444C  4EB9 00004ADE           4256  MOVE_W_data JSR     PrintMove
00004452  4EB9 00004B88           4257              JSR     LengthW
00004458  4EB9 00004BB6           4258              JSR     PrintSpace
0000445E  4EB9 00004944           4259              JSR     PrintImmediateData
00004464                          4260  
00004464  12EE 0025               4261              MOVE.B  37(A6),(A1)+             *,
00004468  4EB8 4350               4262              JSR CheckDest
0000446C  4E75                    4263              RTS                     ; return to input to get more input
0000446E                          4264  
0000446E                          4265  *************************************************                MOVE_L_Opcode          *************************************************
0000446E                          4266  ; first four bit is (0010 #### #### ####)
0000446E                          4267  MOVE_L_Opcode
0000446E  7803                    4268              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00004470  4EB9 00004856           4269              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination register
00004476                          4270  
00004476  2005                    4271              MOVE.L  D5,D0               ; D0 will hold the destination register
00004478                          4272          ; D0 will hold the destination register (position 11-9)
00004478                          4273  
00004478  7803                    4274              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
0000447A  4EB9 00004856           4275              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination mode
00004480                          4276  
00004480  BABC 00000001           4277              CMP.L   #1,D5               ; destination mode can't be mode one
00004486  6700 03C6               4278              BEQ     InvalidOpcode
0000448A                          4279  
0000448A  BABC 00000005           4280              CMP.L   #5,D5               ; destination mode can't be mode 5
00004490  6700 03BC               4281              BEQ     InvalidOpcode
00004494                          4282  
00004494  BABC 00000006           4283              CMP.L   #6,D5               ; destination mode can't be mode 6
0000449A  6700 03B2               4284              BEQ     InvalidOpcode
0000449E                          4285  
0000449E  BABC 00000007           4286              CMP.L   #7,D5               ; if destination mode is 7, we need to check the register. the lable is in
000044A4  6700 0048               4287              BEQ     MOVE_L_DesM7_Check
000044A8                          4288  
000044A8                          4289  Continue_MOVE_L
000044A8  2205                    4290              MOVE.L  D5,D1               ; D1 will hold the destination mode
000044AA                          4291          ; D1 will hold the destination mode (position 8-6)
000044AA                          4292  
000044AA  7803                    4293              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000044AC  4EB9 00004856           4294              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the source mode
000044B2                          4295  
000044B2  BABC 00000000           4296              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
000044B8  6700 0040               4297              BEQ     MOVE_L_M0
000044BC                          4298  
000044BC  BABC 00000001           4299              CMP.L   #1,D5          ; if position 5-3 is 1 the EA is An
000044C2  6700 0060               4300              BEQ     MOVE_L_M1
000044C6                          4301  
000044C6  BABC 00000002           4302              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
000044CC  6700 0080               4303              BEQ     MOVE_L_M2
000044D0                          4304  
000044D0  BABC 00000003           4305              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
000044D6  6700 00A0               4306              BEQ     MOVE_L_M3
000044DA                          4307  
000044DA  BABC 00000004           4308              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
000044E0  6700 00C0               4309              BEQ     MOVE_L_M4
000044E4                          4310  
000044E4  BABC 00000007           4311              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode 7
000044EA  6700 00E0               4312              BEQ     MOVE_L_M7
000044EE                          4313  
000044EE                          4314  MOVE_L_DesM7_Check
000044EE  B0BC 00000001           4315              CMP.L   #1,D0               ; if destination mode is 7, and register is bigger than 1 it is invalid
000044F4  6E00 0358               4316              BGT     InvalidOpcode
000044F8                          4317  
000044F8  60AE                    4318              BRA     Continue_MOVE_L     ; if it is good then continue to decode move
000044FA                          4319  
000044FA  7803                    4320  MOVE_L_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000044FC  4EB9 00004856           4321              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004502  4EB9 00004ADE           4322              JSR     PrintMove
00004508  4EB9 00004B92           4323              JSR     LengthL
0000450E  4EB9 00004BB6           4324              JSR     PrintSpace
00004514  4EB9 000049D0           4325              JSR     PrintDataReg
0000451A                          4326  
0000451A  12EE 0025               4327              MOVE.B  37(A6),(A1)+             *,
0000451E  4EB8 4350               4328              JSR CheckDest
00004522  4E75                    4329              RTS                     ; return to input to get more input
00004524                          4330  
00004524  7803                    4331  MOVE_L_M1   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004526  4EB9 00004856           4332              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000452C  4EB9 00004ADE           4333              JSR     PrintMove
00004532  4EB9 00004B92           4334              JSR     LengthL
00004538  4EB9 00004BB6           4335              JSR     PrintSpace
0000453E  4EB9 000049DC           4336              JSR     PrintAddrReg
00004544                          4337  
00004544  12EE 0025               4338              MOVE.B  37(A6),(A1)+             *,
00004548  4EB8 4350               4339              JSR CheckDest
0000454C  4E75                    4340              RTS                     ; return to input to get more input
0000454E                          4341  
0000454E  7803                    4342  MOVE_L_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004550  4EB9 00004856           4343              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004556  4EB9 00004ADE           4344              JSR     PrintMove
0000455C  4EB9 00004B92           4345              JSR     LengthL
00004562  4EB9 00004BB6           4346              JSR     PrintSpace
00004568  4EB9 000049E8           4347              JSR     PrintIndirAddrReg
0000456E                          4348  
0000456E  12EE 0025               4349              MOVE.B  37(A6),(A1)+             *,
00004572  4EB8 4350               4350              JSR CheckDest
00004576  4E75                    4351              RTS                     ; return to input to get more input
00004578                          4352  
00004578  7803                    4353  MOVE_L_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000457A  4EB9 00004856           4354              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004580  4EB9 00004ADE           4355              JSR     PrintMove
00004586  4EB9 00004B92           4356              JSR     LengthL
0000458C  4EB9 00004BB6           4357              JSR     PrintSpace
00004592  4EB9 000049F6           4358              JSR     PrintPostIncAddrReg
00004598                          4359  
00004598  12EE 0025               4360              MOVE.B  37(A6),(A1)+             *,
0000459C  4EB8 4350               4361              JSR CheckDest
000045A0  4E75                    4362              RTS                     ; return to input to get more input
000045A2                          4363  
000045A2  7803                    4364  MOVE_L_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000045A4  4EB9 00004856           4365              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000045AA  4EB9 00004ADE           4366              JSR     PrintMove
000045B0  4EB9 00004B92           4367              JSR     LengthL
000045B6  4EB9 00004BB6           4368              JSR     PrintSpace
000045BC  4EB9 00004A00           4369              JSR     PrintPreDeincAddrReg
000045C2                          4370  
000045C2  12EE 0025               4371              MOVE.B  37(A6),(A1)+             *,
000045C6  4EB8 4350               4372              JSR CheckDest
000045CA  4E75                    4373              RTS                     ; return to input to get more input
000045CC                          4374  
000045CC  7803                    4375  MOVE_L_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000045CE  4EB9 00004856           4376              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000045D4                          4377  
000045D4  BABC 00000000           4378              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
000045DA  6700 001C               4379              BEQ     MOVE_L_xxxW
000045DE                          4380  
000045DE  BABC 00000001           4381              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
000045E4  6700 0034               4382              BEQ     MOVE_L_xxxL
000045E8                          4383  
000045E8  BABC 00000004           4384              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
000045EE  6700 004C               4385              BEQ     MOVE_L_data
000045F2                          4386  
000045F2  4EF9 0000484E           4387              JMP     InvalidOpcode  ; for mode 7 if Source register is not 0 or 1 or 4, it is not a vaid NOT EA mode
000045F8                          4388  
000045F8  4EB9 00004ADE           4389  MOVE_L_xxxW JSR PrintMove
000045FE  4EB9 00004B92           4390              JSR LengthL
00004604  4EB9 00004BB6           4391              JSR     PrintSpace
0000460A  4EB9 00004950           4392              JSR     PrintByteOrWord
00004610                          4393  
00004610  12EE 0025               4394              MOVE.B  37(A6),(A1)+             *,
00004614  4EB8 4350               4395              JSR CheckDest
00004618  4E75                    4396              RTS                     ; return to input to get more input
0000461A                          4397  
0000461A  4EB9 00004ADE           4398  MOVE_L_xxxL JSR     PrintMove
00004620  4EB9 00004B92           4399              JSR     LengthL
00004626  4EB9 00004BB6           4400              JSR     PrintSpace
0000462C  4EB9 00004966           4401              JSR     PrintLong
00004632                          4402  
00004632  12EE 0025               4403              MOVE.B  37(A6),(A1)+             *,
00004636  4EB8 4350               4404              JSR CheckDest
0000463A  4E75                    4405              RTS                     ; return to input to get more input
0000463C                          4406  
0000463C  4EB9 00004ADE           4407  MOVE_L_data JSR     PrintMove
00004642  4EB9 00004B92           4408              JSR     LengthL
00004648  4EB9 00004BB6           4409              JSR     PrintSpace
0000464E  4EB9 00004944           4410              JSR     PrintImmediateData
00004654                          4411  
00004654  12EE 0025               4412              MOVE.B  37(A6),(A1)+             *,
00004658  4EB8 4350               4413              JSR CheckDest
0000465C  4E75                    4414              RTS                     ; return to input to get more input
0000465E                          4415  
0000465E                          4416  
0000465E                          4417  *************************************************                MOVE_B_Opcode          *************************************************
0000465E                          4418  ; first four bit is (0001 #### #### ####)
0000465E                          4419  MOVE_B_Opcode
0000465E  7803                    4420              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00004660  4EB9 00004856           4421              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination register
00004666                          4422  
00004666  2005                    4423              MOVE.L  D5,D0               ; D0 will hold the destination register
00004668                          4424          ; D0 will hold the destination register (position 11-9)
00004668                          4425  
00004668  7803                    4426              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
0000466A  4EB9 00004856           4427              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination mode
00004670                          4428  
00004670  BABC 00000001           4429              CMP.L   #1,D5               ; destination mode can't be mode one
00004676  6700 01D6               4430              BEQ     InvalidOpcode
0000467A                          4431  
0000467A  BABC 00000005           4432              CMP.L   #5,D5               ; destination mode can't be mode 5
00004680  6700 01CC               4433              BEQ     InvalidOpcode
00004684                          4434  
00004684  BABC 00000006           4435              CMP.L   #6,D5               ; destination mode can't be mode 6
0000468A  6700 01C2               4436              BEQ     InvalidOpcode
0000468E                          4437  
0000468E  BABC 00000007           4438              CMP.L   #7,D5               ; if destination mode is 7, we need to check the register. the lable is in
00004694  6700 0048               4439              BEQ     MOVE_B_DesM7_Check
00004698                          4440  
00004698                          4441  Continue_MOVE_B
00004698  2205                    4442              MOVE.L  D5,D1               ; D1 will hold the destination mode
0000469A                          4443          ; D1 will hold the destination mode (position 8-6)
0000469A                          4444  
0000469A  7803                    4445              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000469C  4EB9 00004856           4446              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the source mode
000046A2                          4447  
000046A2  BABC 00000000           4448              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
000046A8  6700 0040               4449              BEQ     MOVE_B_M0
000046AC                          4450  
000046AC  BABC 00000001           4451              CMP.L   #1,D5          ; if position 5-3 is 1 the EA is An
000046B2  6700 0060               4452              BEQ     MOVE_B_M1
000046B6                          4453  
000046B6  BABC 00000002           4454              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
000046BC  6700 0080               4455              BEQ     MOVE_B_M2
000046C0                          4456  
000046C0  BABC 00000003           4457              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
000046C6  6700 00A0               4458              BEQ     MOVE_B_M3
000046CA                          4459  
000046CA  BABC 00000004           4460              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
000046D0  6700 00C0               4461              BEQ     MOVE_B_M4
000046D4                          4462  
000046D4  BABC 00000007           4463              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode 7
000046DA  6700 00E0               4464              BEQ     MOVE_B_M7
000046DE                          4465  
000046DE                          4466  MOVE_B_DesM7_Check
000046DE  B0BC 00000001           4467              CMP.L   #1,D0               ; if destination mode is 7, and register is bigger than 1 it is invalid
000046E4  6E00 0168               4468              BGT     InvalidOpcode
000046E8                          4469  
000046E8  60AE                    4470              BRA     Continue_MOVE_B     ; if it is good then continue to decode move
000046EA                          4471  
000046EA  7803                    4472  MOVE_B_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000046EC  4EB9 00004856           4473              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000046F2  4EB9 00004ADE           4474              JSR     PrintMove
000046F8  4EB9 00004B7E           4475              JSR     LengthB
000046FE  4EB9 00004BB6           4476              JSR     PrintSpace
00004704  4EB9 000049D0           4477              JSR     PrintDataReg
0000470A                          4478  
0000470A  12EE 0025               4479              MOVE.B  37(A6),(A1)+             *,
0000470E  4EB8 4350               4480              JSR CheckDest
00004712  4E75                    4481              RTS                     ; return to input to get more input
00004714                          4482  
00004714  7803                    4483  MOVE_B_M1   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004716  4EB9 00004856           4484              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000471C  4EB9 00004ADE           4485              JSR     PrintMove
00004722  4EB9 00004B7E           4486              JSR     LengthB
00004728  4EB9 00004BB6           4487              JSR     PrintSpace
0000472E  4EB9 000049DC           4488              JSR     PrintAddrReg
00004734                          4489  
00004734  12EE 0025               4490              MOVE.B  37(A6),(A1)+             *,
00004738  4EB8 4350               4491              JSR CheckDest
0000473C  4E75                    4492              RTS                     ; return to input to get more input
0000473E                          4493  
0000473E  7803                    4494  MOVE_B_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004740  4EB9 00004856           4495              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004746  4EB9 00004ADE           4496              JSR     PrintMove
0000474C  4EB9 00004B7E           4497              JSR     LengthB
00004752  4EB9 00004BB6           4498              JSR     PrintSpace
00004758  4EB9 000049E8           4499              JSR     PrintIndirAddrReg
0000475E                          4500  
0000475E  12EE 0025               4501              MOVE.B  37(A6),(A1)+             *,
00004762  4EB8 4350               4502              JSR CheckDest
00004766  4E75                    4503              RTS                     ; return to input to get more input
00004768                          4504  
00004768  7803                    4505  MOVE_B_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000476A  4EB9 00004856           4506              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004770  4EB9 00004ADE           4507              JSR     PrintMove
00004776  4EB9 00004B7E           4508              JSR     LengthB
0000477C  4EB9 00004BB6           4509              JSR     PrintSpace
00004782  4EB9 000049F6           4510              JSR     PrintPostIncAddrReg
00004788                          4511  
00004788  12EE 0025               4512              MOVE.B  37(A6),(A1)+             *,
0000478C  4EB8 4350               4513              JSR CheckDest
00004790  4E75                    4514              RTS                     ; return to input to get more input
00004792                          4515  
00004792  7803                    4516  MOVE_B_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004794  4EB9 00004856           4517              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000479A  4EB9 00004ADE           4518              JSR     PrintMove
000047A0  4EB9 00004B7E           4519              JSR     LengthB
000047A6  4EB9 00004BB6           4520              JSR     PrintSpace
000047AC  4EB9 00004A00           4521              JSR     PrintPreDeincAddrReg
000047B2                          4522  
000047B2  12EE 0025               4523              MOVE.B  37(A6),(A1)+             *,
000047B6  4EB8 4350               4524              JSR CheckDest
000047BA  4E75                    4525              RTS                     ; return to input to get more input
000047BC                          4526  
000047BC  7803                    4527  MOVE_B_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000047BE  4EB9 00004856           4528              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000047C4                          4529  
000047C4  BABC 00000000           4530              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
000047CA  6700 001C               4531              BEQ     MOVE_B_xxxW
000047CE                          4532  
000047CE  BABC 00000001           4533              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
000047D4  6700 0034               4534              BEQ     MOVE_B_xxxL
000047D8                          4535  
000047D8  BABC 00000004           4536              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
000047DE  6700 004C               4537              BEQ     MOVE_B_data
000047E2                          4538  
000047E2  4EF9 0000484E           4539              JMP     InvalidOpcode  ; for mode 7 if Source register is not 0 or 1 or 4, it is not a vaid NOT EA mode
000047E8                          4540  
000047E8  4EB9 00004ADE           4541  MOVE_B_xxxW JSR     PrintMove
000047EE  4EB9 00004B7E           4542              JSR     LengthB
000047F4  4EB9 00004BB6           4543              JSR     PrintSpace
000047FA  4EB9 00004950           4544              JSR     PrintByteOrWord
00004800                          4545  
00004800  12EE 0025               4546              MOVE.B  37(A6),(A1)+             *,
00004804  4EB8 4350               4547              JSR CheckDest
00004808  4E75                    4548              RTS                     ; return to input to get more input
0000480A                          4549  
0000480A  4EB9 00004ADE           4550  MOVE_B_xxxL JSR     PrintMove
00004810  4EB9 00004B7E           4551              JSR     LengthB
00004816  4EB9 00004BB6           4552              JSR     PrintSpace
0000481C  4EB9 00004950           4553              JSR     PrintByteOrWord
00004822                          4554  
00004822  12EE 0025               4555              MOVE.B  37(A6),(A1)+             *,
00004826  4EB8 4350               4556              JSR CheckDest
0000482A  4E75                    4557              RTS                     ; return to input to get more input
0000482C                          4558  
0000482C  4EB9 00004ADE           4559  MOVE_B_data JSR     PrintMove
00004832  4EB9 00004B7E           4560              JSR     LengthB
00004838  4EB9 00004BB6           4561              JSR     PrintSpace
0000483E  4EB9 00004944           4562              JSR     PrintImmediateData
00004844                          4563  
00004844  12EE 0025               4564              MOVE.B  37(A6),(A1)+             *,
00004848  4EB8 4350               4565              JSR CheckDest
0000484C  4E75                    4566              RTS                     ; return to input to get more input
0000484E                          4567  
0000484E                          4568  
0000484E                          4569  *************************************************                Invalid Handle          *************************************************
0000484E                          4570  
0000484E                          4571  InvalidOpcode  ; don't use JSR to get here. Use JMP. If use JSR, RTS will not go back to input
0000484E  4EB9 0000498E           4572              JSR     NotFound        ; Call Output NotFound subroutine to print, since it did not match with any posible opcode
00004854  4E75                    4573              RTS                     ; Return to input to get more input
00004856                          4574  
00004856                          4575  *************************************************                Subroutine             *************************************************
00004856                          4576  
00004856                          4577  GetNextD4bit ; Subroutine for get the next (D4) bit from (A4) into D5
00004856                          4578               ; D4 should contain the number of loop you want to do
00004856  7600                    4579              MOVE.L  #0,D3          ; initialize D3 to 0
00004858  7A00                    4580              MOVE.L  #0,D5          ; initialize D5 to 0, for storing result of bit from (A4)
0000485A                          4581  
0000485A  B803                    4582  LOOP        CMP.B   D3,D4          ; for number of iterations
0000485C  6700 0012               4583              BEQ     next_code      ; if equal to each other, move on to next
00004860  5283                    4584              ADDQ.L  #1,D3          ; D3++, increment D3
00004862                          4585  
00004862  E38D                    4586              LSL.L   #1,D5          ; Shift left one
00004864                          4587  
00004864  E34A                    4588              LSL.W   #1,D2          ; shift left one
00004866  6500 0004               4589              BCS     ADD1           ; If there is a carry bit add one to D5
0000486A  60EE                    4590              BRA     LOOP
0000486C                          4591  
0000486C  5285                    4592  ADD1        ADDQ.L  #1,D5          ; add 1 to D5
0000486E  60EA                    4593              BRA     LOOP           ; The goal is for D5 to hold the same bit as the first 4 bit of A4
00004870                          4594  
00004870  4E75                    4595  next_code   RTS         ; return from subroutine
00004872                          4596  
00004872                          4597  *-----------------------------------------------------------
00004872                          4598  * Title      : Output
00004872                          4599  * Written by :
00004872                          4600  * Date       :
00004872                          4601  * Description: output data
00004872                          4602  *-----------------------------------------------------------
00004872                          4603  *******     Using A6 for a list of alphabetical characters              ********
00004872                          4604  
00004872                          4605  Print
00004872  12BC 0000               4606      MOVE.B   #$00,(A1)               *Terminator for trap 14 - "hey! stop printing!"
00004876  2279 00004E46           4607      MOVE.L   PrintPointer,A1
0000487C  103C 000E               4608      MOVE.B   #14,D0
00004880  4E4F                    4609      TRAP     #15
00004882  4E75                    4610      RTS
00004884                          4611  
00004884                          4612  PrintLine
00004884  12BC 0000               4613      MOVE.B   #$00,(A1)               *Terminator for trap 13 - "hey! stop printing!"
00004888  5239 00004E4A           4614      ADD.B    #1,PrintLines
0000488E  1039 00004E4A           4615      MOVE.B   PrintLines,D0
00004894  6000 0002               4616      BRA      TestWaited
00004898                          4617  
00004898                          4618  TestWaited
00004898  0400 001E               4619      SUB.B    #30,D0
0000489C  B03C 0000               4620      CMP.B    #0,D0
000048A0  6700 0008               4621      BEQ      WaitMore
000048A4  6D00 001A               4622      BLT      GoAheadAndPrint
000048A8  6EEE                    4623      BGT      TestWaited
000048AA                          4624  
000048AA                          4625  WaitMore
000048AA  43F9 00004DD0           4626      LEA      WaitForMore,A1
000048B0  103C 000E               4627      MOVE.B   #14,D0
000048B4  4E4F                    4628      TRAP     #15
000048B6  103C 0005               4629      MOVE.B   #5,D0
000048BA  4E4F                    4630      TRAP     #15
000048BC  6000 0002               4631      BRA      GoAheadAndPrint
000048C0                          4632  
000048C0                          4633  GoAheadAndPrint
000048C0  2279 00004E46           4634      MOVE.L   PrintPointer,A1
000048C6  103C 000D               4635      MOVE.B   #13,D0
000048CA  4E4F                    4636      TRAP     #15
000048CC  4E75                    4637      RTS
000048CE                          4638  
000048CE                          4639  ** Address
000048CE                          4640  PrintAddr
000048CE  2C0C                    4641      MOVE.L   A4,D6
000048D0  12EE 0000               4642      MOVE.B   0(A6),(A1)+             *68K always has address of 00XXXXXX, so we print 2 zeros
000048D4  12EE 0000               4643      MOVE.B   0(A6),(A1)+
000048D8                          4644  
000048D8  4EB9 00004986           4645      JSR      RightTwenty             *3rd digit
000048DE  12F6 6000               4646      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
000048E2  2C0C                    4647      MOVE.L   A4,D6                   *Re-set the address
000048E4                          4648  
000048E4  E18E                    4649      LSL.L    #8,D6                   *4th digit
000048E6  E98E                    4650      LSL.L    #4,D6
000048E8  4EB9 0000497C           4651      JSR      RightTwentyEight
000048EE  12F6 6000               4652      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
000048F2  2C0C                    4653      MOVE.L   A4,D6                   *Re-set the address
000048F4                          4654  
000048F4  E18E                    4655      LSL.L    #8,D6                   *5th digit
000048F6  E18E                    4656      LSL.L    #8,D6
000048F8  4EB9 0000497C           4657      JSR      RightTwentyEight
000048FE  12F6 6000               4658      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
00004902  2C0C                    4659      MOVE.L   A4,D6                   *Re-set the address
00004904                          4660  
00004904  E18E                    4661      LSL.L    #8,D6                   *6th digit
00004906  E18E                    4662      LSL.L    #8,D6
00004908  E98E                    4663      LSL.L    #4,D6
0000490A  4EB9 0000497C           4664      JSR      RightTwentyEight
00004910  12F6 6000               4665      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
00004914  2C0C                    4666      MOVE.L   A4,D6                   *Re-set the address
00004916                          4667  
00004916  E18E                    4668      LSL.L    #8,D6                   *7th digit
00004918  E18E                    4669      LSL.L    #8,D6
0000491A  E18E                    4670      LSL.L    #8,D6
0000491C  4EB9 0000497C           4671      JSR      RightTwentyEight
00004922  12F6 6000               4672      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
00004926  2C0C                    4673      MOVE.L   A4,D6                   *Re-set the address
00004928                          4674  
00004928  E18E                    4675      LSL.L    #8,D6                   *8th digit
0000492A  E18E                    4676      LSL.L    #8,D6
0000492C  E18E                    4677      LSL.L    #8,D6
0000492E  E98E                    4678      LSL.L    #4,D6
00004930  4EB9 0000497C           4679      JSR      RightTwentyEight
00004936  12F6 6000               4680      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
0000493A                          4681  
0000493A  4EB9 00004B9C           4682      JSR      PrintTab                *Add tab
00004940  4286                    4683      CLR.L    D6
00004942  4E75                    4684      RTS
00004944                          4685  
00004944                          4686  PrintImmediateData
00004944  12EE 0029               4687              MOVE.B  41(A6),(A1)+             *#
00004948  4EB9 00004966           4688              JSR     PrintLong
0000494E  4E75                    4689              RTS
00004950                          4690  
00004950                          4691  PrintByteOrWord
00004950  12EE 0026               4692      MOVE.B   38(A6),(A1)+        *$
00004954  4EB8 4872               4693              JSR     Print
00004958                          4694  
00004958  321C                    4695              MOVE.W  (A4)+,D1
0000495A  143C 0010               4696              MOVE.B  #16,D2
0000495E  103C 000F               4697              MOVE.B  #15,D0
00004962  4E4F                    4698              TRAP    #15
00004964  4E75                    4699              RTS
00004966                          4700  
00004966                          4701  PrintLong
00004966  12EE 0026               4702      MOVE.B   38(A6),(A1)+        *$
0000496A  4EB8 4872               4703              JSR     Print
0000496E                          4704  
0000496E  321C                    4705              MOVE.W  (A4)+,D1
00004970  143C 0010               4706              MOVE.B  #16,D2
00004974  103C 000F               4707              MOVE.B  #15,D0
00004978  4E4F                    4708              TRAP    #15
0000497A  4E75                    4709              RTS
0000497C                          4710  
0000497C                          4711  RightTwentyEight
0000497C  E08E                    4712      LSR.L    #8,D6
0000497E  4EB9 00004986           4713      JSR      RightTwenty
00004984  4E75                    4714      RTS
00004986                          4715  
00004986                          4716  RightTwenty
00004986  E08E                    4717      LSR.L    #8,D6
00004988  E08E                    4718      LSR.L    #8,D6
0000498A  E88E                    4719      LSR.L    #4,D6
0000498C  4E75                    4720      RTS
0000498E                          4721  
0000498E                          4722  ** General
0000498E                          4723  NotFound
0000498E  12EE 000D               4724      MOVE.B   13(A6),(A1)+        *D
00004992  12EE 000A               4725      MOVE.B   10(A6),(A1)+        *A
00004996  12EE 001D               4726      MOVE.B   29(A6),(A1)+        *T
0000499A  12EE 000A               4727      MOVE.B   10(A6),(A1)+        *A
0000499E  4EB9 00004B9C           4728              JSR      PrintTab
000049A4  12EE 0026               4729      MOVE.B   38(A6),(A1)+        *$
000049A8  13E4 00004E4E           4730              MOVE.B   -(A4),CurDecode
000049AE  103C 0010               4731              MOVE.B   #16,D0
000049B2  6000 0002               4732              BRA      PrintBits
000049B6                          4733  
000049B6                          4734  PrintBits
000049B6  B03C 0000               4735              CMP.B   #0,D0
000049BA  6700 0010               4736              BEQ     PBDone
000049BE  7801                    4737              MOVE.L  #1,D4                    ;Get 1 bit from A4
000049C0  4EB8 4856               4738              JSR     GetNextD4bit             ;Store in D5
000049C4                          4739  
000049C4  12F6 5000               4740              MOVE.B  (A6,D5),(A1)+            ;Put into print queue
000049C8                          4741  
000049C8  5300                    4742              SUB.B   #1,D0                    ;Sub 1, do 8 times?
000049CA                          4743  
000049CA  60EA                    4744              BRA     PrintBits
000049CC                          4745  
000049CC                          4746  PBDone
000049CC  101C                    4747              MOVE.B  (A4)+,D0
000049CE  4E75                    4748              RTS
000049D0                          4749  
000049D0                          4750  PrintDataReg
000049D0  12EE 000D               4751      MOVE.B   13(A6),(A1)+        *D
000049D4  4EB9 00004A0A           4752      JSR      PrintRegNum
000049DA  4E75                    4753      RTS
000049DC                          4754  
000049DC                          4755  PrintAddrReg
000049DC  12EE 000A               4756      MOVE.B   10(A6),(A1)+        *A
000049E0  4EB9 00004A0A           4757      JSR      PrintRegNum
000049E6  4E75                    4758      RTS
000049E8                          4759  
000049E8                          4760  PrintIndirAddrReg
000049E8  12EE 0027               4761              MOVE.B  39(A6),(A1)+             *(
000049EC  4EB8 49DC               4762              JSR     PrintAddrReg             *Ax
000049F0  12EE 0028               4763              MOVE.B  40(A6),(A1)+             *)
000049F4  4E75                    4764              RTS
000049F6                          4765  
000049F6                          4766  PrintPostIncAddrReg
000049F6  4EB8 49E8               4767              JSR     PrintIndirAddrReg        *(Ax)
000049FA  12EE 002A               4768              MOVE.B  42(A6),(A1)+             *+
000049FE  4E75                    4769              RTS
00004A00                          4770  
00004A00                          4771  PrintPreDeincAddrReg
00004A00  12EE 002B               4772              MOVE.B  43(A6),(A1)+             *-
00004A04  4EB8 49E8               4773              JSR     PrintIndirAddrReg        *(Ax)
00004A08  4E75                    4774              RTS
00004A0A                          4775  
00004A0A                          4776  PrintRegNum
00004A0A  12F6 5000               4777      MOVE.B   (A6,D5),(A1)+
00004A0E  4E75                    4778      RTS
00004A10                          4779  
00004A10                          4780  ** OPCodes
00004A10                          4781  PrintAdd
00004A10  12EE 000A               4782      MOVE.B   10(A6),(A1)+        *A
00004A14  12EE 000D               4783      MOVE.B   13(A6),(A1)+        *D
00004A18  12EE 000D               4784      MOVE.B   13(A6),(A1)+        *D
00004A1C  4E75                    4785      RTS
00004A1E                          4786  
00004A1E                          4787  PrintAddA
00004A1E  4EB8 4A10               4788      JSR      PrintAdd            *ADD
00004A22  12EE 000A               4789      MOVE.B   10(A6),(A1)+        *A
00004A26  4E75                    4790      RTS
00004A28                          4791  
00004A28                          4792  PrintAddQ
00004A28  4EB8 4A10               4793      JSR      PrintAdd            *ADD
00004A2C  12EE 001A               4794      MOVE.B   26(A6),(A1)+        *Q
00004A30  4E75                    4795      RTS
00004A32                          4796  
00004A32                          4797  PrintAnd
00004A32  12EE 000A               4798      MOVE.B   10(A6),(A1)+        *A
00004A36  12EE 0017               4799      MOVE.B   23(A6),(A1)+        *N
00004A3A  12EE 000D               4800      MOVE.B   13(A6),(A1)+        *D
00004A3E  4E75                    4801      RTS
00004A40                          4802  
00004A40                          4803  PrintASL
00004A40  12EE 000A               4804      MOVE.B   10(A6),(A1)+        *A
00004A44  12EE 001C               4805      MOVE.B   28(A6),(A1)+        *S
00004A48  12EE 0015               4806      MOVE.B   21(A6),(A1)+        *L
00004A4C  4E75                    4807      RTS
00004A4E                          4808  
00004A4E                          4809  PrintASR
00004A4E  12EE 000A               4810      MOVE.B   10(A6),(A1)+        *A
00004A52  12EE 001C               4811      MOVE.B   28(A6),(A1)+        *S
00004A56  12EE 001B               4812      MOVE.B   27(A6),(A1)+        *R
00004A5A  4E75                    4813      RTS
00004A5C                          4814  
00004A5C                          4815  PrintBEQ
00004A5C  12EE 000B               4816      MOVE.B   11(A6),(A1)+        *B
00004A60  12EE 000E               4817      MOVE.B   14(A6),(A1)+        *E
00004A64  12EE 001A               4818      MOVE.B   26(A6),(A1)+        *Q
00004A68  4E75                    4819      RTS
00004A6A                          4820  
00004A6A                          4821  PrintBGT
00004A6A  12EE 000B               4822      MOVE.B   11(A6),(A1)+        *B
00004A6E  12EE 0010               4823      MOVE.B   16(A6),(A1)+        *G
00004A72  12EE 001D               4824      MOVE.B   29(A6),(A1)+        *T
00004A76  4E75                    4825      RTS
00004A78                          4826  
00004A78                          4827  PrintBLE
00004A78  12EE 000B               4828      MOVE.B   11(A6),(A1)+        *B
00004A7C  12EE 0015               4829      MOVE.B   21(A6),(A1)+        *L
00004A80  12EE 000E               4830      MOVE.B   14(A6),(A1)+        *E
00004A84  4E75                    4831      RTS
00004A86                          4832  
00004A86                          4833  PrintBRA
00004A86  12EE 000B               4834      MOVE.B   11(A6),(A1)+        *B
00004A8A  12EE 001B               4835      MOVE.B   27(A6),(A1)+        *R
00004A8E  12EE 000A               4836      MOVE.B   10(A6),(A1)+        *A
00004A92  4E75                    4837      RTS
00004A94                          4838  
00004A94                          4839  PrintDivu
00004A94  12EE 000D               4840              MOVE.B   13(A6),(A1)+            *D
00004A98  12EE 0012               4841              MOVE.B   18(A6),(A1)+            *I
00004A9C  12EE 001F               4842              MOVE.B   31(A6),(A1)+            *V
00004AA0  12EE 001E               4843              MOVE.B   30(A6),(A1)+            *U
00004AA4  4E75                    4844              RTS
00004AA6                          4845  
00004AA6                          4846  PrintJSR
00004AA6  12EE 0013               4847      MOVE.B   19(A6),(A1)+        *J
00004AAA  12EE 001C               4848      MOVE.B   28(A6),(A1)+        *S
00004AAE  12EE 001B               4849      MOVE.B   27(A6),(A1)+        *R
00004AB2  4E75                    4850      RTS
00004AB4                          4851  
00004AB4                          4852  PrintLEA
00004AB4  12EE 0015               4853      MOVE.B   21(A6),(A1)+        *L
00004AB8  12EE 000E               4854      MOVE.B   14(A6),(A1)+        *E
00004ABC  12EE 000A               4855      MOVE.B   10(A6),(A1)+        *A
00004AC0  4E75                    4856      RTS
00004AC2                          4857  
00004AC2                          4858  PrintLSL
00004AC2  12EE 0015               4859      MOVE.B   21(A6),(A1)+        *L
00004AC6  12EE 001C               4860      MOVE.B   28(A6),(A1)+        *S
00004ACA  12EE 0015               4861      MOVE.B   21(A6),(A1)+        *L
00004ACE  4E75                    4862      RTS
00004AD0                          4863  
00004AD0                          4864  PrintLSR
00004AD0  12EE 0015               4865      MOVE.B   21(A6),(A1)+        *L
00004AD4  12EE 001C               4866      MOVE.B   28(A6),(A1)+        *S
00004AD8  12EE 001B               4867      MOVE.B   27(A6),(A1)+        *R
00004ADC  4E75                    4868      RTS
00004ADE                          4869  
00004ADE                          4870  PrintMove
00004ADE  12EE 0016               4871      MOVE.B   22(A6),(A1)+        *M
00004AE2  12EE 0018               4872      MOVE.B   24(A6),(A1)+        *O
00004AE6  12EE 001F               4873      MOVE.B   31(A6),(A1)+        *V
00004AEA  12EE 000E               4874      MOVE.B   14(A6),(A1)+        *E
00004AEE  4E75                    4875      RTS
00004AF0                          4876  
00004AF0                          4877  PrintMoveA
00004AF0  4EB8 4ADE               4878      JSR      PrintMove           *MOVE
00004AF4  12EE 000A               4879      MOVE.B   10(A6),(A1)+        *A
00004AF8  4E75                    4880      RTS
00004AFA                          4881  
00004AFA                          4882  PrintMoveQ
00004AFA  4EB8 4ADE               4883      JSR      PrintMove           *MOVE
00004AFE  12EE 001A               4884      MOVE.B   26(A6),(A1)+        *Q
00004B02  4E75                    4885      RTS
00004B04                          4886  
00004B04                          4887  PrintMoveM
00004B04  4EB8 4ADE               4888      JSR      PrintMove           *MOVE
00004B08  12EE 0016               4889      MOVE.B   22(A6),(A1)+        *M
00004B0C  4E75                    4890      RTS
00004B0E                          4891  
00004B0E                          4892  PrintMuls
00004B0E  12EE 0016               4893              MOVE.B  22(A6),(A1)+             *M
00004B12  12EE 001E               4894              MOVE.B  30(A6),(A1)+             *U
00004B16  12EE 0015               4895              MOVE.B  21(A6),(A1)+             *L
00004B1A  12EE 001C               4896              MOVE.B  28(A6),(A1)+             *S
00004B1E  4E75                    4897              RTS
00004B20                          4898  
00004B20                          4899  PrintNOP
00004B20  12EE 0017               4900      MOVE.B   23(A6),(A1)+        *N
00004B24  12EE 0018               4901      MOVE.B   24(A6),(A1)+        *O
00004B28  12EE 0019               4902      MOVE.B   25(A6),(A1)+        *P
00004B2C  4E75                    4903      RTS
00004B2E                          4904  
00004B2E                          4905  PrintNot
00004B2E  12EE 0017               4906      MOVE.B   23(A6),(A1)+         *N
00004B32  12EE 0018               4907      MOVE.B   24(A6),(A1)+         *O
00004B36  12EE 001D               4908      MOVE.B   29(A6),(A1)+         *T
00004B3A  4E75                    4909      RTS
00004B3C                          4910  
00004B3C                          4911  PrintOr
00004B3C  12EE 0018               4912      MOVE.B   24(A6),(A1)+        *O
00004B40  12EE 001B               4913      MOVE.B   27(A6),(A1)+        *R
00004B44  4E75                    4914      RTS
00004B46                          4915  
00004B46                          4916  PrintROL
00004B46  12EE 001B               4917      MOVE.B   27(A6),(A1)+        *R
00004B4A  12EE 0018               4918      MOVE.B   24(A6),(A1)+        *O
00004B4E  12EE 0015               4919      MOVE.B   21(A6),(A1)+        *L
00004B52  4E75                    4920      RTS
00004B54                          4921  
00004B54                          4922  PrintROR
00004B54  12EE 001B               4923      MOVE.B   27(A6),(A1)+        *R
00004B58  12EE 0018               4924      MOVE.B   24(A6),(A1)+        *O
00004B5C  12EE 001B               4925      MOVE.B   27(A6),(A1)+        *R
00004B60  4E75                    4926      RTS
00004B62                          4927  
00004B62                          4928  PrintRTS
00004B62  12EE 001B               4929      MOVE.B   27(A6),(A1)+        *R
00004B66  12EE 001D               4930      MOVE.B   29(A6),(A1)+        *T
00004B6A  12EE 001C               4931      MOVE.B   28(A6),(A1)+        *S
00004B6E  4E75                    4932      RTS
00004B70                          4933  
00004B70                          4934  PrintSub
00004B70  12EE 001C               4935      MOVE.B   28(A6),(A1)+        *S
00004B74  12EE 001E               4936      MOVE.B   30(A6),(A1)+        *U
00004B78  12EE 000B               4937      MOVE.B   11(A6),(A1)+        *B
00004B7C  4E75                    4938      RTS
00004B7E                          4939  
00004B7E                          4940  ** Sizes
00004B7E                          4941  LengthB                          *Prints .B
00004B7E  12EE 0024               4942      MOVE.B   36(A6),(A1)+        *.
00004B82  12EE 000B               4943      MOVE.B   11(A6),(A1)+        *B
00004B86  4E75                    4944      RTS
00004B88                          4945  
00004B88                          4946  LengthW                          *Prints .W
00004B88  12EE 0024               4947      MOVE.B   36(A6),(A1)+        *.
00004B8C  12EE 0020               4948      MOVE.B   32(A6),(A1)+        *W
00004B90  4E75                    4949      RTS
00004B92                          4950  
00004B92                          4951  LengthL                          *Prints .L
00004B92  12EE 0024               4952      MOVE.B   36(A6),(A1)+        *.
00004B96  12EE 0015               4953      MOVE.B   21(A6),(A1)+        *L
00004B9A  4E75                    4954      RTS
00004B9C                          4955  
00004B9C                          4956  ** Other
00004B9C                          4957  PrintTab
00004B9C  4EB9 00004BB6           4958      JSR      PrintSpace
00004BA2  4EB9 00004BB6           4959      JSR      PrintSpace
00004BA8  4EB9 00004BB6           4960      JSR      PrintSpace
00004BAE  4EB9 00004BB6           4961      JSR      PrintSpace
00004BB4  4E75                    4962      RTS
00004BB6                          4963  
00004BB6                          4964  PrintSpace
00004BB6  12EE 002C               4965      MOVE.B   44(A6),(A1)+
00004BBA  4E75                    4966      RTS
00004BBC                          4967  
00004BBC  FFFF FFFF               4968      SIMHALT             ; halt simulator
00004BC0                          4969  
00004BC0                          4970  * Put variables and constants here
00004BC0  =0000000D               4971  CR           EQU     $0D
00004BC0  =0000000A               4972  LF           EQU     $0A
00004BC0                          4973  
00004BC0                          4974  ;EmptyChar    DC.W    '', 0
00004BC0                          4975  ;SpaceChar    DC.W ' ', 0
00004BC0                          4976  
00004BC0  =00000500               4977  EndAddr      EQU     $500                        ; store end address, avoid overwriting
00004BC0  =00000600               4978  StartAddr    EQU     $600                        ; store start address, avoid overwriting
00004BC0  =00000400               4979  Cur4bits     EQU     $400                        ; store first four bits
00004BC0                          4980  
00004BC0                          4981  * introduction message
00004BC0= 2A 2A 2A 2A 2A 2A ...   4982  IntroMsg     DC.B    '**************************************************************',CR,LF
00004C00= 2A 20 20 54 45 41 ...   4983               DC.B    '*  TEAM 9 DISASSEMBLER',CR,LF,CR,LF
00004C1A= 2A 20 20 4D 65 6D ...   4984               DC.B    '*  Members: MARIANA HUYNH, HANNY LONG, ALEX VAN MATRE',CR,LF,CR,LF
00004C53= 2A 2A 2A 2A 2A 2A ...   4985               DC.B    '*************************************************************',CR,LF,CR,LF,0
00004C95                          4986  
00004C95= 45 6E 74 65 72 20 ...   4987  AskStartAddr DC.B 'Enter starting address in hexadecimal:', CR, LF, 0
00004CBE                          4988  
00004CBE= 45 6E 74 65 72 20 ...   4989  AskEndAddr   DC.B 'Enter ending address in hexadecimal:', CR, LF, 0
00004CE5                          4990  
00004CE5= 45 6E 74 65 72 20 ...   4991  AskRestartOrExitMsg DC.B 'Enter 0 to exit program or 1 to restart the program: ', 0
00004D1B                          4992  
00004D1B                          4993  * Error message
00004D1B= 49 6E 76 61 6C 69 ...   4994  InvalidStartMessage  DC.B 'Invalid Start Address: input not valid hex value', CR, LF, 0
00004D4E= 49 6E 76 61 6C 69 ...   4995  InvalidEndMessage  DC.B 'Invalid End Address: input not valid hex value or End <= Start', CR, LF, 0
00004D8F                          4996  
00004D8F                          4997  
00004D8F                          4998  * Hex Srting Numbers
00004D90= 3000 0000               4999  Str0                       DC.W '0', 0
00004D94= 3100 0000               5000  Str1                       DC.W '1', 0
00004D98= 3200 0000               5001  Str2                       DC.W '2', 0
00004D9C= 3300 0000               5002  Str3                       DC.W '3', 0
00004DA0= 3400 0000               5003  Str4                       DC.W '4', 0
00004DA4= 3500 0000               5004  Str5                       DC.W '5', 0
00004DA8= 3600 0000               5005  Str6                       DC.W '6', 0
00004DAC= 3700 0000               5006  Str7                       DC.W '7', 0
00004DB0= 3800 0000               5007  Str8                       DC.W '8', 0
00004DB4= 3900 0000               5008  Str9                       DC.W '9', 0
00004DB8                          5009  
00004DB8                          5010  * Hex String Letters
00004DB8= 4100 0000               5011  StrA                       DC.W 'A', 0
00004DBC= 4200 0000               5012  StrB                       DC.W 'B', 0
00004DC0= 4300 0000               5013  StrC                       DC.W 'C', 0
00004DC4= 4400 0000               5014  StrD                       DC.W 'D', 0
00004DC8= 4500 0000               5015  StrE                       DC.W 'E', 0
00004DCC= 4600 0000               5016  StrF                       DC.W 'F', 0
00004DD0                          5017  
00004DD0                          5018  
00004DD0= 4D 61 78 20 6E 75 ...   5019  WaitForMore     DC.B   'Max number of lines on screen. Press enter to continue dissassembling', CR, LF, 0
00004E18= 30 31 32 33 34 35 ...   5020  Values          DC.B   '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','.',',','$','(',')','#','+','-',' '
00004E45                          5021  *                       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44
00004E46= 00003500                5022  PrintPointer    DC.L   $3500
00004E4A= 00004500                5023  PrintLines      DC.L   $4500
00004E4E= 00005500                5024  CurDecode   DC.L   $5500
00004E52                          5025  
00004E52                          5026                END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD1                486C
ADD_B_DESEA         1C3E
ADD_B_DESEA_M2      1C74
ADD_B_DESEA_M3      1CA6
ADD_B_DESEA_M4      1CD4
ADD_B_DESEA_M7      1D06
ADD_B_DESEA_XXXL    1D52
ADD_B_DESEA_XXXW    1D28
ADD_B_SRCEA         16D4
ADD_B_SRCEA_DATA    187C
ADD_B_SRCEA_M0      171E
ADD_B_SRCEA_M1      174C
ADD_B_SRCEA_M2      177A
ADD_B_SRCEA_M3      17A8
ADD_B_SRCEA_M4      17D6
ADD_B_SRCEA_M7      1804
ADD_B_SRCEA_XXXL    1856
ADD_B_SRCEA_XXXW    1830
ADD_L_DESEA         1EBA
ADD_L_DESEA_M2      1EF0
ADD_L_DESEA_M3      1F22
ADD_L_DESEA_M4      1F50
ADD_L_DESEA_M7      1F82
ADD_L_DESEA_XXXL    1FCE
ADD_L_DESEA_XXXW    1FA4
ADD_L_SRCEA         1A70
ADD_L_SRCEA_DATA    1C18
ADD_L_SRCEA_M0      1ABA
ADD_L_SRCEA_M1      1AE8
ADD_L_SRCEA_M2      1B16
ADD_L_SRCEA_M3      1B44
ADD_L_SRCEA_M4      1B72
ADD_L_SRCEA_M7      1BA0
ADD_L_SRCEA_XXXL    1BF2
ADD_L_SRCEA_XXXW    1BCC
ADD_OPCODE          1680
ADD_W_DESEA         1D7C
ADD_W_DESEA_M2      1DB2
ADD_W_DESEA_M3      1DE4
ADD_W_DESEA_M4      1E12
ADD_W_DESEA_M7      1E44
ADD_W_DESEA_XXXL    1E90
ADD_W_DESEA_XXXW    1E66
ADD_W_SRCEA         18A2
ADD_W_SRCEA_DATA    1A4A
ADD_W_SRCEA_M0      18EC
ADD_W_SRCEA_M1      191A
ADD_W_SRCEA_M2      1948
ADD_W_SRCEA_M3      1976
ADD_W_SRCEA_M4      19A4
ADD_W_SRCEA_M7      19D2
ADD_W_SRCEA_XXXL    1A24
ADD_W_SRCEA_XXXW    19FE
AND_B_DESEA         2518
AND_B_DESEA_M2      254E
AND_B_DESEA_M3      2580
AND_B_DESEA_M4      25B2
AND_B_DESEA_M7      25E4
AND_B_DESEA_XXXL    2630
AND_B_DESEA_XXXW    2606
AND_B_SRCEA         2056
AND_B_SRCEA_DATA    21C6
AND_B_SRCEA_M0      2096
AND_B_SRCEA_M2      20C4
AND_B_SRCEA_M3      20F2
AND_B_SRCEA_M4      2120
AND_B_SRCEA_M7      214E
AND_B_SRCEA_XXXL    21A0
AND_B_SRCEA_XXXW    217A
AND_L_DESEA         279C
AND_L_DESEA_M2      27D2
AND_L_DESEA_M3      2804
AND_L_DESEA_M4      2836
AND_L_DESEA_M7      2868
AND_L_DESEA_XXXL    28B4
AND_L_DESEA_XXXW    288A
AND_L_SRCEA         2382
AND_L_SRCEA_DATA    24F2
AND_L_SRCEA_M0      23C2
AND_L_SRCEA_M2      23F0
AND_L_SRCEA_M3      241E
AND_L_SRCEA_M4      244C
AND_L_SRCEA_M7      247A
AND_L_SRCEA_XXXL    24CC
AND_L_SRCEA_XXXW    24A6
AND_W_DESEA         265A
AND_W_DESEA_M2      2690
AND_W_DESEA_M3      26C2
AND_W_DESEA_M4      26F4
AND_W_DESEA_M7      2726
AND_W_DESEA_XXXL    2772
AND_W_DESEA_XXXW    2748
AND_W_SRCEA         21EC
AND_W_SRCEA_DATA    235C
AND_W_SRCEA_M0      222C
AND_W_SRCEA_M2      225A
AND_W_SRCEA_M3      2288
AND_W_SRCEA_M4      22B6
AND_W_SRCEA_M7      22E4
AND_W_SRCEA_XXXL    2336
AND_W_SRCEA_XXXW    2310
ASCIITOHEX          1088
ASKENDADDR          4CBE
ASKEXITORRESTART    11A4
ASKRESTARTOREXITMSG  4CE5
ASKSTARTADDR        4C95
ASL_COUNT_OPCODE    130C
ASL_MEMSHIFT        158E
ASL_MEMSHIFT_MODE_2  15C4
ASL_MEMSHIFT_MODE_3  15E6
ASL_MEMSHIFT_MODE_4  1608
ASL_MEMSHIFT_MODE_7  162A
ASL_MEMSHIFT_XXXL   1666
ASL_MEMSHIFT_XXXW   164C
ASL_OUTPUT_BYTE     1360
ASL_OUTPUT_LONG     1388
ASL_OUTPUT_SIZE     133C
ASL_OUTPUT_WORD     1374
ASL_REGISTER_OPCODE  143C
BCC_16BIT_DISP      3642
BCC_32BIT_DISP      364C
BCC_DISPLACEMENT    3624
BCC_OPCODE          35BE
BEQ_OPCODE          3618
BGT_OPCODE          35F4
BLE_OPCODE          3600
BRA_OPCODE          360C
CHECKCOUNT          142C
CHECKDEST           4350
CLEAREVERYTHING     11C8
CONTINUE_MOVE_B     4698
CONTINUE_MOVE_L     44A8
CONTINUE_MOVE_W     4222
CONVERTFORLOOP      108E
CONVERTLOWERCASE    10D4
CONVERTNUM          10CA
CONVERTUPPERCASE    10DE
CR                  D
CUR4BITS            400
CURDECODE           4E4E
D0_TO_8             1438
DECODINGMACHINECODE  121E
DESTDN              438E
DESTINDIRAN         4398
DESTL               43D4
DESTPOSTINCAN       43A2
DESTPREDEINCAN      43AC
DESTW               43CC
DESTWL              43B6
DISPINVALIDENDERROR  1178
DISPINVALIDSTARTERROR  116A
DIVU_L              3C70
DIVU_L_DATA         3DE0
DIVU_L_M0           3CB0
DIVU_L_M2           3CDE
DIVU_L_M3           3D0C
DIVU_L_M4           3D3A
DIVU_L_M7           3D68
DIVU_L_XXXL         3DBA
DIVU_L_XXXW         3D94
DIVU_W_DATA         3598
DIVU_W_M0           3468
DIVU_W_M2           3496
DIVU_W_M3           34C4
DIVU_W_M4           34F2
DIVU_W_M7           3520
DIVU_W_OPCODE       340C
DIVU_W_XXXL         3572
DIVU_W_XXXW         354C
ENDADDR             500
GETENDADDR          105E
GETNEXTD4BIT        4856
GETSTARTADDR        1032
GOAHEADANDPRINT     48C0
INTROMSG            4BC0
INVALIDADDRHANDLER  113A
INVALIDENDHANDLER   1158
INVALIDENDMESSAGE   4D4E
INVALIDOPCODE       484E
INVALIDSTARTHANDLER  1146
INVALIDSTARTMESSAGE  4D1B
JSR_M2              3E28
JSR_M7              3E44
JSR_OPCODE          3E06
JSR_XXXL            3E7A
JSR_XXXW            3E66
LEA_M2_OPCODE       36F8
LEA_M7_OPCODE       3720
LEA_OPCODE          36C2
LEA_XXXL_OPCODE     3762
LEA_XXXW_OPCODE     3742
LENGTHB             4B7E
LENGTHL             4B92
LENGTHW             4B88
LF                  A
LOADADDR            1126
LOOP                485A
LSL_ASL_OPCODE      12A4
LSL_COUNT_OPCODE    139C
LSL_MEMSHIFT        1496
LSL_MEMSHIFT_MODE_2  14CC
LSL_MEMSHIFT_MODE_3  14EE
LSL_MEMSHIFT_MODE_4  1510
LSL_MEMSHIFT_MODE_7  1532
LSL_MEMSHIFT_XXXL   1574
LSL_MEMSHIFT_XXXW   1554
LSL_OUTPUT_BYTE     13F0
LSL_OUTPUT_LONG     1418
LSL_OUTPUT_SIZE     13CC
LSL_OUTPUT_WORD     1404
LSL_REGISTER_OPCODE  145C
MEMSHIFT            147C
MOVEM_M2R_L         3A04
MOVEM_M2R_L_M2      3A30
MOVEM_M2R_L_M4      3A56
MOVEM_M2R_L_M7      3A7C
MOVEM_M2R_L_XXXL    3ABC
MOVEM_M2R_L_XXXW    3A9E
MOVEM_M2R_W         392E
MOVEM_M2R_W_M2      395A
MOVEM_M2R_W_M4      3980
MOVEM_M2R_W_M7      39A6
MOVEM_M2R_W_XXXL    39E6
MOVEM_M2R_W_XXXW    39C8
MOVEM_R2M_L         3858
MOVEM_R2M_L_M2      3884
MOVEM_R2M_L_M4      38AA
MOVEM_R2M_L_M7      38D0
MOVEM_R2M_L_XXXL    3910
MOVEM_R2M_L_XXXW    38F2
MOVEM_R2M_W         3782
MOVEM_R2M_W_M2      37AE
MOVEM_R2M_W_M4      37D4
MOVEM_R2M_W_M7      37FA
MOVEM_R2M_W_XXXL    383A
MOVEM_R2M_W_XXXW    381C
MOVE_B_DATA         482C
MOVE_B_DESM7_CHECK  46DE
MOVE_B_M0           46EA
MOVE_B_M1           4714
MOVE_B_M2           473E
MOVE_B_M3           4768
MOVE_B_M4           4792
MOVE_B_M7           47BC
MOVE_B_OPCODE       465E
MOVE_B_XXXL         480A
MOVE_B_XXXW         47E8
MOVE_L_DATA         463C
MOVE_L_DESM7_CHECK  44EE
MOVE_L_M0           44FA
MOVE_L_M1           4524
MOVE_L_M2           454E
MOVE_L_M3           4578
MOVE_L_M4           45A2
MOVE_L_M7           45CC
MOVE_L_OPCODE       446E
MOVE_L_XXXL         461A
MOVE_L_XXXW         45F8
MOVE_W_DATA         444C
MOVE_W_DESM7_CHECK  4268
MOVE_W_M0           4274
MOVE_W_M1           42A0
MOVE_W_M2           42CC
MOVE_W_M3           42F8
MOVE_W_M4           4324
MOVE_W_M7           43DC
MOVE_W_OPCODE       41E8
MOVE_W_XXXL         442A
MOVE_W_XXXW         4408
MULS_L              3ADA
MULS_L_DATA         3C4A
MULS_L_M0           3B1A
MULS_L_M2           3B48
MULS_L_M3           3B76
MULS_L_M4           3BA4
MULS_L_M7           3BD2
MULS_L_XXXL         3C24
MULS_L_XXXW         3BFE
MULS_W              28DE
MULS_W_AND_OPCODE   1FF8
MULS_W_DATA         2A4E
MULS_W_M0           291E
MULS_W_M2           294C
MULS_W_M3           297A
MULS_W_M4           29A8
MULS_W_M7           29D6
MULS_W_XXXL         2A28
MULS_W_XXXW         2A02
NEEDMOREBIT         3656
NEXT_CODE           4870
NOTFOUND            498E
NOT_B_M0            3ECE
NOT_B_M2            3EF0
NOT_B_M3            3F12
NOT_B_M4            3F34
NOT_B_M7            3F56
NOT_B_OPCODE        3E8E
NOT_B_XXXL          3F92
NOT_B_XXXW          3F78
NOT_L_M0            410A
NOT_L_M2            412C
NOT_L_M3            414E
NOT_L_M4            4170
NOT_L_M7            4192
NOT_L_OPCODE        40CA
NOT_L_XXXL          41CE
NOT_L_XXXW          41B4
NOT_W_M0            3FEC
NOT_W_M2            400E
NOT_W_M3            4030
NOT_W_M4            4052
NOT_W_M7            4074
NOT_W_OPCODE        3FAC
NOT_W_XXXL          40B0
NOT_W_XXXW          4096
PBDONE              49CC
PRINT               4872
PRINTADD            4A10
PRINTADDA           4A1E
PRINTADDQ           4A28
PRINTADDR           48CE
PRINTADDRREG        49DC
PRINTAND            4A32
PRINTASL            4A40
PRINTASR            4A4E
PRINTBEQ            4A5C
PRINTBGT            4A6A
PRINTBITS           49B6
PRINTBLE            4A78
PRINTBRA            4A86
PRINTBYTEORWORD     4950
PRINTDATAREG        49D0
PRINTDIVU           4A94
PRINTIMMEDIATEDATA  4944
PRINTINDIRADDRREG   49E8
PRINTJSR            4AA6
PRINTLEA            4AB4
PRINTLINE           4884
PRINTLINES          4E4A
PRINTLONG           4966
PRINTLSL            4AC2
PRINTLSR            4AD0
PRINTMOVE           4ADE
PRINTMOVEA          4AF0
PRINTMOVEM          4B04
PRINTMOVEQ          4AFA
PRINTMULS           4B0E
PRINTNOP            4B20
PRINTNOT            4B2E
PRINTOR             4B3C
PRINTPOINTER        4E46
PRINTPOSTINCADDRREG  49F6
PRINTPREDEINCADDRREG  4A00
PRINTREGNUM         4A0A
PRINTROL            4B46
PRINTROR            4B54
PRINTRTS            4B62
PRINTSPACE          4BB6
PRINTSUB            4B70
PRINTTAB            4B9C
PUTENDTOMEMORY      111E
PUTSTARTTOMEMORY    1116
QUIT                1218
READNEXTLOOP        1188
READNEXTLOOPSTART   1186
RIGHTTWENTY         4986
RIGHTTWENTYEIGHT    497C
SAVESTART           10E8
START               1000
STARTADDR           600
STR0                4D90
STR1                4D94
STR2                4D98
STR3                4D9C
STR4                4DA0
STR5                4DA4
STR6                4DA8
STR7                4DAC
STR8                4DB0
STR9                4DB4
STRA                4DB8
STRB                4DBC
STRC                4DC0
STRD                4DC4
STRE                4DC8
STRF                4DCC
SUB_B_DESEA         3032
SUB_B_DESEA_M2      3068
SUB_B_DESEA_M3      309A
SUB_B_DESEA_M4      30CC
SUB_B_DESEA_M7      30FE
SUB_B_DESEA_XXXL    3154
SUB_B_DESEA_XXXW    312A
SUB_B_SRCEA         2AC8
SUB_B_SRCEA_DATA    2C70
SUB_B_SRCEA_M0      2B12
SUB_B_SRCEA_M1      2B40
SUB_B_SRCEA_M2      2B6E
SUB_B_SRCEA_M3      2B9C
SUB_B_SRCEA_M4      2BCA
SUB_B_SRCEA_M7      2BF8
SUB_B_SRCEA_XXXL    2C4A
SUB_B_SRCEA_XXXW    2C24
SUB_L_DESEA         32CA
SUB_L_DESEA_M2      3300
SUB_L_DESEA_M3      3332
SUB_L_DESEA_M4      3364
SUB_L_DESEA_M7      3396
SUB_L_DESEA_XXXL    33E2
SUB_L_DESEA_XXXW    33B8
SUB_L_SRCEA         2E64
SUB_L_SRCEA_DATA    300C
SUB_L_SRCEA_M0      2EAE
SUB_L_SRCEA_M1      2EDC
SUB_L_SRCEA_M2      2F0A
SUB_L_SRCEA_M3      2F38
SUB_L_SRCEA_M4      2F66
SUB_L_SRCEA_M7      2F94
SUB_L_SRCEA_XXXL    2FE6
SUB_L_SRCEA_XXXW    2FC0
SUB_OPCODE          2A74
SUB_W_DESEA         317E
SUB_W_DESEA_M2      31B4
SUB_W_DESEA_M3      31E6
SUB_W_DESEA_M4      3218
SUB_W_DESEA_M7      324A
SUB_W_DESEA_XXXL    32A0
SUB_W_DESEA_XXXW    3276
SUB_W_SRCEA         2C96
SUB_W_SRCEA_DATA    2E3E
SUB_W_SRCEA_M0      2CE0
SUB_W_SRCEA_M1      2D0E
SUB_W_SRCEA_M2      2D3C
SUB_W_SRCEA_M3      2D6A
SUB_W_SRCEA_M4      2D98
SUB_W_SRCEA_M7      2DC6
SUB_W_SRCEA_XXXL    2E18
SUB_W_SRCEA_XXXW    2DF2
TESTWAITED          4898
VALIDATEEND         10FE
VALUES              4E18
WAITFORMORE         4DD0
WAITMORE            48AA
