00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 8/18/2020 8:36:27 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Team 9 Disassembler
00000000                             3  * Written by : Mariana Huynh, Hanny Long, Alex Van Matre
00000000                             4  * Date       : 07/20/20
00000000                             5  * Description: Disassmbles a program that is loaded into
00000000                             6  *              memory
00000000                             7  *-----------------------------------------------------------
00001000                             8                ORG    $1000
00001000                             9  START:                                           ; first instruction of program
00001000  4DF9 00004DEA             10      LEA      Values,A6
00001006  4EB9 0000486A             11      JSR      Print
0000100C  2279 00004E18             12      MOVE.L   PrintPointer,A1
00001012  13FC 0000 00004E1C        13      MOVE.B   #0,PrintLines
0000101A  4EB9 00004B88             14      JSR      PrintSpace
00001020                            15  
00001020                            16  * Put program code here
00001020                            17  
00001020                            18  * I/O
00001020  227C 00000000             19               MOVEA.L #0, A1                      ; Clear A1
00001026  43F9 00004B92             20               LEA IntroMsg, A1
0000102C  103C 000E                 21               MOVE.B #14, D0                      ; print contents of A1
00001030  4E4F                      22               TRAP #15
00001032                            23  
00001032                            24  * Get start address
00001032                            25  GetStartAddr
00001032  43F9 00004C67             26               LEA     AskStartAddr,A1             ; load asking for start address message
00001038  103C 000E                 27               MOVE.B  #14,D0
0000103C  4E4F                      28               TRAP    #15                         ; print to screen
0000103E                            29  
0000103E  227C 00000000             30               MOVEA.L #0,A1                       ; Clear A1
00001044  43F9 00000600             31               LEA     StartAddr,A1                ; Move variable StartAddr for storing
0000104A                            32  
0000104A  103C 0002                 33               MOVE.B  #2,D0                       ; trap task 2: takes in input from keyboard and stores into A1
0000104E  4E4F                      34               TRAP    #15
00001050                            35  
00001050  B27C 0008                 36               CMP     #8,D1                       ; check if input is 8 chars long
00001054  6600 00E4                 37               BNE     InvalidAddrHandler
00001058                            38  
00001058  4242                      39               CLR     D2                          ; clear toggle for if validated start/end address
0000105A                            40  
0000105A  6000 002C                 41               BRA     AsciiToHex                  ; convert input to hex
0000105E                            42  
0000105E                            43  * Get end address
0000105E                            44  GetEndAddr
0000105E  43F9 00004C90             45               LEA     AskEndAddr,A1               ; load asking for end address message
00001064  103C 000E                 46               MOVE.B  #14,D0
00001068  4E4F                      47               TRAP    #15
0000106A                            48  
0000106A  227C 00000000             49               MOVEA.L #0,A1                       ; Clear A1
00001070  43F9 00000500             50               LEA     EndAddr,A1                  ; move variable EndAddr for storing
00001076                            51  
00001076  103C 0002                 52               MOVE.B  #2,D0                       ; trap task 2: takes in input from keyboard and stores into A1
0000107A  4E4F                      53               TRAP    #15
0000107C                            54  
0000107C  B27C 0008                 55               CMP     #8,D1                       ; Check if the given value was 8 characters long, if not it needs to be given again
00001080  6600 00B8                 56               BNE     InvalidAddrHandler
00001084                            57  
00001084  6000 0002                 58               BRA     AsciiToHex                  ; convert input to hex
00001088                            59  
00001088                            60  * Convert from ASCII to hex
00001088                            61  AsciiToHex
00001088  7600                      62               MOVE.L  #0,D3                       ; initialize D3 to 0
0000108A  7808                      63               MOVE.L  #8,D4                       ; initialize D4 to 8, for number of iterations in for_loop1
0000108C  7A00                      64               MOVE.L  #0,D5                       ; initialize D5 to 0, for storing result of converted input to hex
0000108E                            65  
0000108E                            66  ConvertForLoop
0000108E  B803                      67               CMP.B   D3,D4                       ; for number of iterations
00001090  6700 0056                 68               BEQ     SaveStart                   ; if equal to each other, move on to validate start address
00001094  5283                      69               ADDQ.L  #1,D3                       ; D3++
00001096                            70  
00001096  E985                      71               ASL.L    #4,D5                      ; shift to the left 4 bits (1 hex character)
00001098  1219                      72               MOVE.B  (A1)+,D1                    ; read one char into D1
0000109A                            73  
0000109A  B23C 0030                 74               CMP.B   #$30,D1                     ; check the char, "A-F", "0-9", "a-f"
0000109E  6D00 009A                 75               BLT     InvalidAddrHandler          ; D1 < 0x30
000010A2  B23C 0039                 76               CMP.B   #$39,D1
000010A6  6F00 0022                 77               BLE     ConvertNum                  ; 0x30 (0) <= D1 <= 0x39 (9)  <-- see ASCII chart
000010AA  B23C 0041                 78               CMP.B   #$41,D1
000010AE  6D00 008A                 79               BLT     InvalidAddrHandler          ; 0x39 < D1 < 0x41
000010B2                            80  
000010B2  B23C 0046                 81               CMP.B   #$46,D1
000010B6  6F00 0026                 82               BLE     ConvertUppercase            ; 0x41 (A) <= D1 <= 0x46 (F)
000010BA  B23C 0061                 83               CMP.B   #$61,D1
000010BE  6D00 007A                 84               BLT     InvalidAddrHandler          ; 0x47 < D1 < 0x61
000010C2  B23C 0066                 85               CMP.B   #$66,D1
000010C6  6F00 000C                 86               BLE     ConvertLowercase            ; 0x66 (f) < D1
000010CA                            87  
000010CA                            88  ConvertNum
000010CA  0481 00000030             89               SUB.L   #$30,D1                     ; convert char (0-9) to number
000010D0  DA81                      90               ADD.L   D1,D5
000010D2  60BA                      91               BRA     ConvertForLoop              ; go back and do next character
000010D4                            92  
000010D4                            93  ConvertLowercase
000010D4  0481 00000057             94               SUB.L   #$57,D1                     ; convert char (a-f) to number
000010DA  DA81                      95               ADD.L   D1,D5
000010DC  60B0                      96               BRA     ConvertForLoop              ; go back and do next character
000010DE                            97  
000010DE                            98  ConvertUppercase
000010DE  0481 00000037             99               SUB.L   #$37,D1                     ; convert char (A-F) to number
000010E4  DA81                     100               ADD.L   D1,D5
000010E6  60A6                     101               BRA     ConvertForLoop              ; go back and do next character
000010E8                           102  
000010E8                           103  * Save start and end (and validate end) addresses
000010E8                           104  SaveStart
000010E8  B47C 0001                105               CMP         #1,D2
000010EC  6700 0010                106               BEQ         ValidateEnd             ; if D2 = 1, already validated start address
000010F0  5242                     107               ADDI        #1,D2                   ; if initially 0, add 1 to toggle to ValidateEnd
000010F2                           108  
000010F2  4EB9 00001116            109               JSR         PutStartToMemory        ; move converted starting address from D3 to defined memory location
000010F8  4245                     110               CLR         D5
000010FA  6000 FF62                111               BRA         GetEndAddr              ; ask user for new end address
000010FE                           112  
000010FE                           113  ValidateEnd
000010FE  BAB9 00000600            114               CMP.L       StartAddr,D5            ; check if starting address is less than or equal to ending address
00001104  6F00 0052                115               BLE         InvalidEndHandler       ; if yes, = error (start must be less than end)
00001108                           116  
00001108  4242                     117               CLR.W       D2
0000110A  4EB9 0000111E            118               JSR         PutEndToMemory          ; move ending address in D3 to defined memory location
00001110  4245                     119               CLR.W       D5
00001112                           120  
00001112  6000 0012                121               BRA         LoadAddr
00001116                           122  
00001116                           123  PutStartToMemory
00001116  23C5 00000600            124               MOVE.L      D5,StartAddr
0000111C  4E75                     125               RTS
0000111E                           126  
0000111E                           127  PutEndToMemory
0000111E  23C5 00000500            128               MOVE.L      D5,EndAddr
00001124  4E75                     129               RTS
00001126                           130  
00001126                           131  LoadAddr
00001126  4282                     132               CLR.L       D2
00001128  2479 00000600            133               MOVE.L      StartAddr,A2
0000112E  2679 00000500            134               MOVE.L      EndAddr,A3
00001134  4EB9 00001186            135               JSR         ReadNextLoopStart
0000113A                           136  
0000113A                           137  * Invalid input handlers
0000113A                           138  InvalidAddrHandler
0000113A  B47C 0001                139               CMP         #1,D2                   ; if toggle at D2 = 1 then end address error
0000113E  6700 0018                140               BEQ         InvalidEndHandler
00001142  6000 0002                141               BRA         InvalidStartHandler ; else starting address error
00001146                           142  
00001146                           143  InvalidStartHandler
00001146  227C 00000000            144               MOVEA.L     #0,A1                   ; clear A1
0000114C  4EB9 0000116A            145               JSR         DispInvalidStartError
00001152  4245                     146               CLR         D5
00001154  6000 FEDC                147               BRA         GetStartAddr            ; ask for starting address again
00001158                           148  
00001158                           149  InvalidEndHandler
00001158  227C 00000000            150               MOVEA.L     #0,A1                   ; clear A1
0000115E  4EB9 00001178            151               JSR         DispInvalidEndError
00001164  4245                     152               CLR         D5
00001166  6000 FEF6                153               BRA         GetEndAddr
0000116A                           154  
0000116A                           155  DispInvalidStartError
0000116A  43F9 00004CED            156               LEA         InvalidStartMessage,A1  ; load error message
00001170  103C 000D                157               MOVE.B      #13,D0                  ; print contents of A1
00001174  4E4F                     158               TRAP        #15
00001176  4E75                     159               RTS
00001178                           160  
00001178                           161  DispInvalidEndError
00001178  43F9 00004D20            162               LEA         InvalidEndMessage,A1    ; load error message
0000117E  103C 000D                163               MOVE.B      #13,D0                  ; print contents of A1
00001182  4E4F                     164               TRAP        #15
00001184  4E75                     165               RTS
00001186                           166  
00001186                           167  * Opcode Parsing
00001186                           168  ReadNextLoopStart
00001186  284A                     169               MOVE.L      A2,A4
00001188                           170  
00001188                           171  ReadNextLoop
00001188  B9CB                     172               CMPA.L      A3,A4
0000118A  6C00 0018                173               BGE         AskExitOrRestart
0000118E                           174  
0000118E                           175               ;MOVE.B     -(A4),A4
0000118E                           176  
0000118E  4EB9 0000487C            177               JSR         PrintLine
00001194                           178  
00001194  4EB9 000048C6            179               JSR         PrintAddr
0000119A                           180  
0000119A  4EB9 0000121E            181               JSR         DecodingMachineCode
000011A0                           182               ;MOVE.W      (A4)+,D7                   ; read one word at a time and store in D7
000011A0  4EF8 1188                183               JMP         ReadNextLoop
000011A4                           184  
000011A4                           185  AskExitOrRestart
000011A4  43F9 00004CB7            186               LEA         AskRestartOrExitMsg,A1 ; ask user to restart or exit program
000011AA  103C 000E                187               MOVE.B      #14,D0
000011AE  4E4F                     188               TRAP        #15
000011B0                           189  
000011B0  103C 0004                190               MOVE.B      #4,D0                  ; trap task #4: get user input (digit)
000011B4  4E4F                     191               TRAP        #15
000011B6                           192  
000011B6  B23C 0001                193               CMP.B       #1,D1                  ; if user inputs 1, restart program
000011BA  6700 000C                194               BEQ         ClearEverything
000011BE  B23C 0000                195               CMP.B       #0,D1                  ; if 0, terminate program
000011C2  66E0                     196               BNE         AskExitOrRestart       ; if not 0 nor 1, prompt again
000011C4  6000 0052                197               BRA         quit
000011C8                           198  
000011C8                           199  ClearEverything
000011C8                           200  * Clear data registers
000011C8  4280                     201               CLR.L       D0
000011CA  4281                     202               CLR.L       D1
000011CC  4282                     203               CLR.L       D2
000011CE  4283                     204               CLR.L       D3
000011D0  4284                     205               CLR.L       D4
000011D2  4285                     206               CLR.L       D5
000011D4  4286                     207               CLR.L       D6
000011D6  4287                     208               CLR.L       D7
000011D8                           209  
000011D8                           210  * Clear address registers
000011D8  207C 00000000            211               MOVEA.L     #0, A0
000011DE  227C 00000000            212               MOVEA.L     #0, A1
000011E4  247C 00000000            213               MOVEA.L     #0, A2
000011EA  267C 00000000            214               MOVEA.L     #0, A3
000011F0  287C 00000000            215               MOVEA.L     #0, A4
000011F6  2A7C 00000000            216               MOVEA.L     #0, A5
000011FC  2C7C 00000000            217               MOVEA.L     #0, A6
00001202  2E7C 00000000            218               MOVEA.L     #0, A7
00001208                           219  
00001208                           220  * Clear memory locations that variables used
00001208  42B9 00000600            221               CLR.L       StartAddr
0000120E  42B9 00000500            222               CLR.L       EndAddr
00001214                           223  
00001214  6000 FDEA                224               BRA         START
00001218                           225  
00001218                           226  quit
00001218  103C 0009                227               MOVE.B      #9, D0
0000121C  4E4F                     228               TRAP        #15
0000121E                           229  
0000121E                           230  *-----------------------------------------------------------
0000121E                           231  * Title      : Opcode decoding
0000121E                           232  * Written by :
0000121E                           233  * Date       :
0000121E                           234  * Description: decoding opcode from machine code by looking at the bit and narrowing down the possibility
0000121E                           235  *-----------------------------------------------------------
0000121E                           236  *******     ASSUME (A4) IS ALREADY is the MACHINE CODE                  ********
0000121E                           237  *******     NOTE: MACHINE CODE ARE WORD SIZE                            ********
0000121E                           238  *******     The code narrow down the opcode posibility by               ********
0000121E                           239  *******     looking at the bit and branch                               ********
0000121E                           240  *******     Using D3,D4 for loop and,D5 result                          ********
0000121E                           241  *******     Using D0, D1 to hold temperary data                         ********
0000121E                           242  *******     POSTCONDITION: (A4) will hold 0 after RTS from this SR      ********
0000121E                           243  *******                    except for if the opcode is NOP or RTS       ********
0000121E                           244  ;Ctrl+F "Print" to see where all the print is
0000121E                           245  ;If nothing work BUG is in GetNextD4bit subroutine or InvalidOpcode subroutine, both is at the bottom of the file
0000121E                           246  
0000121E                           247  DecodingMachineCode
0000121E  4242                     248              CLR     D2
00001220  341C                     249              MOVE.W  (A4)+,D2        ; create copy of data in A4 to fix restart
00001222                           250  
00001222  0C42 4E71                251              CMPI.W  #20081,D2    ; NOP if equal
00001226  6700 38CA                252              BEQ     PrintNOP       ; Call Output PrintNOP subroutine
0000122A                           253              ;RTS                    ; Return to get more input
0000122A                           254  
0000122A  0C42 4E75                255              CMPI.W  #20085,D2    ; RTS if equal
0000122E  6700 3904                256              BEQ     PrintRTS       ; Call Output PrintRTS subroutine
00001232                           257              ;RTS                    ; Return to get more input
00001232                           258  
00001232  7804                     259              MOVE.L  #4,D4          ; get the next 4 bit from (A4) in to D5
00001234  4EB9 0000484E            260              JSR     GetNextD4bit   ; D5 hold the first 4 bit of (A4)
0000123A                           261  
0000123A                           262      ; cmp to see whice opcode the frist 4 bit match with
0000123A  BABC 0000000E            263              CMP.L   #14,D5
00001240  6700 0062                264              BEQ     LSL_ASL_Opcode
00001244                           265  
00001244  BABC 0000000D            266              CMP.L   #13,D5
0000124A  6700 0434                267              BEQ     ADD_Opcode
0000124E                           268  
0000124E  BABC 0000000C            269              CMP.L   #12,D5
00001254  6700 0DA2                270              BEQ     MULS_W_AND_Opcode
00001258                           271  
00001258  BABC 00000009            272              CMP.L   #9,D5
0000125E  6700 1814                273              BEQ     SUB_Opcode
00001262                           274  
00001262  BABC 00000008            275              CMP.L   #8,D5
00001268  6700 21A2                276              BEQ     DIVU_W_Opcode
0000126C                           277  
0000126C  BABC 00000006            278              CMP.L   #6,D5
00001272  6700 234A                279              BEQ     Bcc_Opcode
00001276                           280  
00001276  BABC 00000004            281              CMP.L   #4,D5
0000127C  6700 23D0                282              BEQ     NeedMoreBit
00001280                           283  
00001280  BABC 00000003            284              CMP.L   #3,D5
00001286  6700 2F58                285              BEQ     MOVE_W_Opcode
0000128A                           286  
0000128A  BABC 00000002            287              CMP.L   #2,D5
00001290  6700 31D4                288              BEQ     MOVE_L_Opcode
00001294                           289  
00001294  BABC 00000001            290              CMP.L   #1,D5
0000129A  6700 33BA                291              BEQ     MOVE_B_Opcode
0000129E                           292  
0000129E  4EF9 00004846            293              JMP     InvalidOpcode  ; Call Output NotFound subroutine, since it did not match with any first 4 bit of the opcode
000012A4                           294  
000012A4                           295  
000012A4                           296  *************************************************                LSL_ASL_Opcode                  *************************************************
000012A4                           297  ; first four bit is (1110 #### #### ####)
000012A4                           298  LSL_ASL_Opcode
000012A4  7803                     299              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 11-9) in to D5
000012A6  4EB9 0000484E            300              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which is count or register it is
000012AC                           301  
000012AC  2005                     302              MOVE.L  D5,D0          ; D0 will hold the count or register
000012AE                           303         ; D0 will hold the count or register (position 11-9)
000012AE                           304  
000012AE  7801                     305              MOVE.L  #1,D4          ; get the next 1 bit from (A4)(position 8) in to D5
000012B0  4EB9 0000484E            306              JSR     GetNextD4bit   ; D5 hold the next 1 bit of (A4), which tell us the direction
000012B6                           307  
000012B6  BABC 00000001            308              CMP.L   #1,D5          ; D5 should be 1 since we are shifting left
000012BC  6600 3588                309              BNE     InvalidOpcode  ; if D5 doesn't equal 1 it is not a valid machine code
000012C0                           310  
000012C0  7802                     311              MOVE.L  #2,D4          ; get the next 2 bit from (A4)(position 7-6) in to D5
000012C2  4EB9 0000484E            312              JSR     GetNextD4bit   ; D5 hold the next 2 bit of (A4), which tell us the size
000012C8                           313  
000012C8  BABC 00000003            314              CMP.L   #3,D5          ; if size is 3 then it is a memory shift
000012CE  4EF9 0000147C            315              JMP     MemShift
000012D4                           316  
000012D4  2205                     317              MOVE.L  D5,D1          ; D1 will hold the size
000012D6                           318         ; D1 will hold the size (position 7-6)
000012D6                           319  
000012D6  7803                     320              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
000012D8  4EB9 0000484E            321              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us immediate shift count or register shift count
000012DE                           322  
000012DE  BABC 00000000            323              CMP.L   #0,D5          ; D5 is 3 bit from (A4)(position 5-3), if 0 mean it is a ASL by count
000012E4  6700 0026                324              BEQ     ASL_Count_Opcode
000012E8                           325  
000012E8  BABC 00000001            326              CMP.L   #1,D5           ; D5 is 3 bit from (A4)(position 5-3), if 1 mean it is a LSL by count
000012EE  6700 00AC                327              BEQ     LSL_Count_Opcode
000012F2                           328  
000012F2  BABC 00000004            329              CMP.L   #4,D5           ; D5 is 3 bit from (A4)(position 5-3), if 4 mean it is a ASL by Register
000012F8  6700 0142                330              BEQ     ASL_Register_Opcode
000012FC                           331  
000012FC  BABC 00000005            332              CMP.L   #5,D5           ; D5 is 3 bit from (A4)(position 5-3), if 5 mean it is a LSL by Register
00001302  6700 0158                333              BEQ     LSL_Register_Opcode
00001306                           334  
00001306  4EF9 00004846            335              JMP     InvalidOpcode       ; if it is not invalid because position 5-3 did not match any posibility
0000130C                           336  
0000130C                           337  ASL_Count_Opcode
0000130C  7803                     338              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000130E  4EB9 0000484E            339              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
00001314                           340  
00001314  4EB9 0000133C            341              JSR     ASL_Output_Size    ;output ASL and size from D1
0000131A                           342  
0000131A  4EB9 0000142C            343              JSR     CheckCount     ; change D0 to 8 if D0 equal to 0
00001320                           344  
00001320  1E05                     345              MOVE.B  D5,D7
00001322  1A00                     346              MOVE.B  D0,D5
00001324                           347  
00001324  12EE 0029                348              MOVE.B  41(A6),(A1)+             *#
00001328  4EB9 000049DC            349              JSR     PrintRegNum
0000132E                           350  
0000132E  1A07                     351              MOVE.B  D7,D5
00001330  12EE 0025                352              MOVE.B  37(A6),(A1)+             *,
00001334  4EB9 000049A2            353              JSR     PrintDataReg
0000133A                           354  
0000133A  4E75                     355              RTS                    ; Return to get more input
0000133C                           356  
0000133C                           357  ASL_Output_Size    ; subroutine for outputting size from D1
0000133C  B2BC 00000000            358              CMP.L   #0,D1           ; if D1 is 0 it is byte size
00001342  6700 001C                359              BEQ     ASL_Output_Byte
00001346                           360  
00001346  B2BC 00000001            361              CMP.L   #1,D1           ; if D1 is 1 it is word size
0000134C  6700 0026                362              BEQ     ASL_Output_Word
00001350                           363  
00001350  B2BC 00000002            364              CMP.L   #2,D1           ; if D1 is 2 it is long size
00001356  6700 0030                365              BEQ     ASL_Output_Long
0000135A                           366  
0000135A  4EF9 00004846            367              JMP     InvalidOpcode    ; if it is not 0,1,2 it is not a valid size
00001360                           368  
00001360                           369  ASL_Output_Byte
00001360  4EB9 00004A12            370              JSR     PrintASL
00001366  4EB9 00004B50            371              JSR     LengthB
0000136C  4EB9 00004B88            372              JSR     PrintSpace
00001372  4E75                     373              RTS                     ; return from subroutine
00001374                           374  
00001374                           375  ASL_Output_Word
00001374  4EB9 00004A12            376              JSR     PrintASL
0000137A  4EB9 00004B5A            377              JSR     LengthW
00001380  4EB9 00004B88            378              JSR     PrintSpace
00001386  4E75                     379              RTS                     ; return from subroutine
00001388                           380  
00001388                           381  ASL_Output_Long
00001388  4EB9 00004A12            382              JSR     PrintASL
0000138E  4EB9 00004B64            383              JSR     LengthL
00001394  4EB9 00004B88            384              JSR     PrintSpace
0000139A  4E75                     385              RTS                     ; return from subroutine
0000139C                           386  
0000139C                           387  
0000139C                           388  LSL_Count_Opcode
0000139C  7803                     389              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000139E  4EB9 0000484E            390              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
000013A4                           391  
000013A4  4EB9 000013CC            392              JSR     LSL_Output_Size    ;output LSL and size from D1
000013AA                           393  
000013AA  4EB9 0000142C            394              JSR     CheckCount     ; change D0 to 8 if D0 equal to 0
000013B0                           395  
000013B0  1E05                     396              MOVE.B  D5,D7
000013B2  1A00                     397              MOVE.B  D0,D5
000013B4                           398  
000013B4  12EE 0029                399              MOVE.B  41(A6),(A1)+             *#
000013B8  4EB9 000049DC            400              JSR     PrintRegNum
000013BE                           401  
000013BE  1A07                     402              MOVE.B  D7,D5
000013C0  12EE 0025                403              MOVE.B  37(A6),(A1)+             *,
000013C4  4EB9 000049A2            404              JSR     PrintDataReg
000013CA                           405  
000013CA  4E75                     406              RTS                    ; Return to get more input
000013CC                           407  
000013CC                           408  LSL_Output_Size    ; subroutine for outputting size from D1
000013CC  B2BC 00000000            409              CMP.L   #0,D1           ; if D1 is 0 it is byte size
000013D2  6700 001C                410              BEQ     LSL_Output_Byte
000013D6                           411  
000013D6  B2BC 00000001            412              CMP.L   #1,D1           ; if D1 is 1 it is word size
000013DC  6700 0026                413              BEQ     LSL_Output_Word
000013E0                           414  
000013E0  B2BC 00000002            415              CMP.L   #2,D1           ; if D1 is 2 it is long size
000013E6  6700 0030                416              BEQ     LSL_Output_Long
000013EA                           417  
000013EA  4EF9 00004846            418              JMP     InvalidOpcode    ; if it is not 0,1,2 it is not a valid size
000013F0                           419  
000013F0                           420  LSL_Output_Byte
000013F0  4EB9 00004A94            421              JSR     PrintLSL
000013F6  4EB9 00004B50            422              JSR     LengthB
000013FC  4EB9 00004B88            423              JSR     PrintSpace
00001402  4E75                     424              RTS                     ; return from subroutine
00001404                           425  
00001404                           426  LSL_Output_Word
00001404  4EB9 00004A94            427              JSR     PrintLSL
0000140A  4EB9 00004B5A            428              JSR     LengthW
00001410  4EB9 00004B88            429              JSR     PrintSpace
00001416  4E75                     430              RTS                     ; return from subroutine
00001418                           431  
00001418                           432  LSL_Output_Long
00001418  4EB9 00004A94            433              JSR     PrintLSL
0000141E  4EB9 00004B64            434              JSR     LengthL
00001424  4EB9 00004B88            435              JSR     PrintSpace
0000142A  4E75                     436              RTS                     ; return from subroutine
0000142C                           437  
0000142C                           438  CheckCount  ; Subroutine for change D0 to 8 if D0 equal to 0
0000142C  B0BC 00000000            439              CMP.L   #0,D0
00001432  6700 0004                440              BEQ     D0_to_8
00001436  4E75                     441              RTS                     ; return from subroutine
00001438                           442  
00001438  7008                     443  D0_to_8     MOVE.L  #8,D0
0000143A  4E75                     444              RTS                     ; return from subroutine
0000143C                           445  
0000143C                           446  ASL_Register_Opcode
0000143C  7803                     447              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000143E  4EB9 0000484E            448              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
00001444                           449  
00001444  4EB8 133C                450              JSR     ASL_Output_Size    ;output ASL and size from D1
00001448                           451  
00001448  1E05                     452              MOVE.B  D5,D7
0000144A  1A00                     453              MOVE.B  D0,D5
0000144C  4EB9 000049A2            454              JSR     PrintDataReg
00001452                           455  
00001452  1A07                     456              MOVE.B  D7,D5
00001454  4EB9 000049A2            457              JSR     PrintDataReg
0000145A                           458  
0000145A  4E75                     459              RTS                    ; Return to get more input
0000145C                           460  
0000145C                           461  
0000145C                           462  LSL_Register_Opcode
0000145C  7803                     463              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000145E  4EB9 0000484E            464              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
00001464                           465  
00001464  4EB8 13CC                466              JSR     LSL_Output_Size    ;output ASL and size from D1
00001468                           467  
00001468  1E05                     468              MOVE.B  D5,D7
0000146A  1A00                     469              MOVE.B  D0,D5
0000146C  4EB9 000049A2            470              JSR     PrintDataReg
00001472                           471  
00001472  1A07                     472              MOVE.B  D7,D5
00001474  4EB9 000049A2            473              JSR     PrintDataReg
0000147A                           474  
0000147A  4E75                     475              RTS                    ; Return to get more input
0000147C                           476  
0000147C                           477  MemShift    ; D0 will hold the count or register (position 11-9)
0000147C  B0BC 00000001            478              CMP.L   #1,D0
00001482  6700 0012                479              BEQ     LSL_MemShift
00001486  B0BC 00000000            480              CMP.L   #0,D0
0000148C  6700 0100                481              BEQ     ASL_MemShift
00001490  4EF9 00004846            482              JMP     InvalidOpcode  ; for memory shift (position 11-9)need to be 0 or 1
00001496                           483  
00001496                           484  LSL_MemShift     ; D5 should hold the value of position 5-3
00001496  7803                     485              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00001498  4EB9 0000484E            486              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us mode
0000149E                           487  
0000149E  BABC 00000002            488              CMP.L   #2,D5               ; if position 5-3 is 2 then it is mode 2
000014A4  6700 0026                489              BEQ     LSL_MemShift_Mode_2
000014A8                           490  
000014A8  BABC 00000003            491              CMP.L   #3,D5               ; if position 5-3 is 3 then it is mode 3
000014AE  6700 003E                492              BEQ     LSL_MemShift_Mode_3
000014B2                           493  
000014B2  BABC 00000004            494              CMP.L   #4,D5               ; if position 5-3 is 4 then it is mode 4
000014B8  6700 0056                495              BEQ     LSL_MemShift_Mode_4
000014BC                           496  
000014BC  BABC 00000007            497              CMP.L   #7,D5               ; if position 5-3 is 7 then it is mode 7
000014C2  6700 006E                498              BEQ     LSL_MemShift_Mode_7
000014C6                           499  
000014C6  4EF9 00004846            500              JMP     InvalidOpcode       ; if it is not Addressing mode 2,3,4,7 it is invalid
000014CC                           501  
000014CC                           502  LSL_MemShift_Mode_2
000014CC  7803                     503              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000014CE  4EB9 0000484E            504              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000014D4  4EB9 00004A94            505              JSR     PrintLSL
000014DA  4EB9 00004B5A            506              JSR     LengthW
000014E0  4EB9 00004B88            507              JSR     PrintSpace
000014E6  4EB9 000049BA            508              JSR     PrintIndirAddrReg
000014EC  4E75                     509              RTS                    ; Return to get more input
000014EE                           510  
000014EE                           511  LSL_MemShift_Mode_3
000014EE  7803                     512              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000014F0  4EB9 0000484E            513              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000014F6  4EB9 00004A94            514              JSR     PrintLSL
000014FC  4EB9 00004B5A            515              JSR     LengthW
00001502  4EB9 00004B88            516              JSR     PrintSpace
00001508  4EB9 000049C8            517              JSR     PrintPostIncAddrReg
0000150E  4E75                     518              RTS                    ; Return to get more input
00001510                           519  
00001510                           520  LSL_MemShift_Mode_4
00001510  7803                     521              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001512  4EB9 0000484E            522              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001518  4EB9 00004A94            523              JSR     PrintLSL
0000151E  4EB9 00004B5A            524              JSR     LengthW
00001524  4EB9 00004B88            525              JSR     PrintSpace
0000152A  4EB9 000049D2            526              JSR     PrintPreDeincAddrReg
00001530  4E75                     527              RTS                    ; Return to get more input
00001532                           528  
00001532                           529  LSL_MemShift_Mode_7
00001532  7803                     530              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001534  4EB9 0000484E            531              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
0000153A                           532  
0000153A  BABC 00000001            533              CMP.L   #1,D5               ; check if the register is 1
00001540  6700 0032                534              BEQ     LSL_MemShift_xxxL   ; if mode is 7 and register is 1, it is <xxx>.L
00001544                           535  
00001544  BABC 00000000            536              CMP.L   #0,D5               ; check if the register is 0
0000154A  6700 0008                537              BEQ     LSL_MemShift_xxxW   ; if mode is 7 and register is 1, it is <xxx>.W
0000154E                           538  
0000154E  4EF9 00004846            539              JMP     InvalidOpcode       ; if it is not <xxx>.W or <xxx>.L
00001554                           540  
00001554                           541  LSL_MemShift_xxxW
00001554  4EB9 00004A94            542              JSR     PrintLSL
0000155A  4EB9 00004B5A            543              JSR     LengthW
00001560  4EB9 00004B88            544              JSR     PrintSpace
00001566  4EB9 00004948            545              JSR     PrintByteOrWord
0000156C  4EB9 00004B5A            546              JSR     LengthW
00001572  4E75                     547              RTS                    ; Return to get more input
00001574                           548  
00001574                           549  LSL_MemShift_xxxL
00001574  4EB9 00004A94            550              JSR     PrintLSL
0000157A  4EB9 00004B5A            551              JSR     LengthW
00001580  4EB9 00004B88            552              JSR     PrintSpace
00001586  4EB9 0000495E            553              JSR     PrintLong
0000158C  4E75                     554              RTS                    ; Return to get more input
0000158E                           555  
0000158E                           556  ASL_MemShift    ; D5 should hold the value of position 5-3
0000158E  7803                     557              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001590  4EB9 0000484E            558              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us mode
00001596                           559  
00001596  BABC 00000002            560              CMP.L   #2,D5               ; if position 5-3 is 2 then it is mode 2
0000159C  6700 0026                561              BEQ     ASL_MemShift_Mode_2
000015A0                           562  
000015A0  BABC 00000003            563              CMP.L   #3,D5               ; if position 5-3 is 3 then it is mode 3
000015A6  6700 003E                564              BEQ     ASL_MemShift_Mode_3
000015AA                           565  
000015AA  BABC 00000004            566              CMP.L   #4,D5               ; if position 5-3 is 4 then it is mode 4
000015B0  6700 0056                567              BEQ     ASL_MemShift_Mode_4
000015B4                           568  
000015B4  BABC 00000007            569              CMP.L   #7,D5               ; if position 5-3 is 7 then it is mode 7
000015BA  6700 006E                570              BEQ     ASL_MemShift_Mode_7
000015BE                           571  
000015BE  4EF9 00004846            572              JMP     InvalidOpcode       ; if it is not Addressing mode 2,3,4,7 it is invalid
000015C4                           573  
000015C4                           574  ASL_MemShift_Mode_2
000015C4  7803                     575              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000015C6  4EB9 0000484E            576              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000015CC  4EB9 00004A12            577              JSR     PrintASL
000015D2  4EB9 00004B5A            578              JSR     LengthW
000015D8  4EB9 00004B88            579              JSR     PrintSpace
000015DE  4EB9 000049BA            580              JSR     PrintIndirAddrReg
000015E4  4E75                     581              RTS                    ; Return to get more input
000015E6                           582  
000015E6                           583  ASL_MemShift_Mode_3
000015E6  7803                     584              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000015E8  4EB9 0000484E            585              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000015EE  4EB9 00004A12            586              JSR     PrintASL
000015F4  4EB9 00004B5A            587              JSR     LengthW
000015FA  4EB9 00004B88            588              JSR     PrintSpace
00001600  4EB9 000049C8            589              JSR     PrintPostIncAddrReg
00001606  4E75                     590              RTS                    ; Return to get more input
00001608                           591  
00001608                           592  ASL_MemShift_Mode_4
00001608  7803                     593              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000160A  4EB9 0000484E            594              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001610  4EB9 00004A12            595              JSR     PrintASL
00001616  4EB9 00004B5A            596              JSR     LengthW
0000161C  4EB9 00004B88            597              JSR     PrintSpace
00001622  4EB9 000049D2            598              JSR     PrintPreDeincAddrReg
00001628  4E75                     599              RTS                    ; Return to get more input
0000162A                           600  
0000162A                           601  ASL_MemShift_Mode_7
0000162A  7803                     602              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000162C  4EB9 0000484E            603              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001632                           604  
00001632  BABC 00000001            605              CMP.L   #1,D5               ; check if the register is 1
00001638  6700 002C                606              BEQ     ASL_MemShift_xxxL   ; if mode is 7 and register is 1, it is <xxx>.L
0000163C                           607  
0000163C  BABC 00000000            608              CMP.L   #0,D5               ; check if the register is 0
00001642  6700 0008                609              BEQ     ASL_MemShift_xxxW   ; if mode is 7 and register is 1, it is <xxx>.W
00001646                           610  
00001646  4EF9 00004846            611              JMP     InvalidOpcode  ; if it is not <xxx>.W or <xxx>.L
0000164C                           612  
0000164C                           613  ASL_MemShift_xxxW
0000164C  4EB9 00004A12            614              JSR     PrintASL
00001652  4EB9 00004B5A            615              JSR     LengthW
00001658  4EB9 00004B88            616              JSR     PrintSpace
0000165E  4EB9 00004948            617              JSR     PrintByteOrWord
00001664  4E75                     618              RTS                    ; Return to get more input
00001666                           619  
00001666                           620  ASL_MemShift_xxxL
00001666  4EB9 00004A12            621              JSR     PrintASL
0000166C  4EB9 00004B5A            622              JSR     LengthW
00001672  4EB9 00004B88            623              JSR     PrintSpace
00001678  4EB9 0000495E            624              JSR     PrintLong
0000167E  4E75                     625              RTS                    ; Return to get more input
00001680                           626  
00001680                           627  
00001680                           628  *************************************************                ADD_Opcode                 *************************************************
00001680                           629  ; first four bit is (1101 #### #### ####)
00001680  7803                     630  ADD_Opcode  MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00001682  4EB9 0000484E            631              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001688                           632  
00001688  2005                     633              MOVE.L  D5,D0               ; D0 will hold the register
0000168A                           634          ; D0 will hold the register (position 11-9)
0000168A                           635  
0000168A  7803                     636              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
0000168C  4EB9 0000484E            637              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the opmode
00001692                           638  
00001692  BABC 00000000            639              CMP.L   #0,D5               ; if opmode is 0, it is a byte with location specified is a source  (<ea> + Dn -> Dn)
00001698  6700 003A                640              BEQ     ADD_B_SrcEA
0000169C                           641  
0000169C  BABC 00000001            642              CMP.L   #1,D5               ; if opmode is 1, it is a word with location specified is a source  (<ea> + Dn -> Dn)
000016A2  6700 01FE                643              BEQ     ADD_W_SrcEA
000016A6                           644  
000016A6  BABC 00000002            645              CMP.L   #2,D5               ; if opmode is 2, it is a long with location specified is a source  (<ea> + Dn -> Dn)
000016AC  6700 03C2                646              BEQ     ADD_L_SrcEA
000016B0                           647  
000016B0  BABC 00000004            648              CMP.L   #4,D5               ; if opmode is 4, it is a byte with location specified is a Destination (Dn + <ea> -> <ea>)
000016B6  6700 0586                649              BEQ     ADD_B_DesEA
000016BA                           650  
000016BA  BABC 00000005            651              CMP.L   #5,D5               ; if opmode is 5, it is a word with location specified is a Destination (Dn + <ea> -> <ea>)
000016C0  6700 06BA                652              BEQ     ADD_W_DesEA
000016C4                           653  
000016C4  BABC 00000006            654              CMP.L   #6,D5               ; if opmode is 6, it is a long with location specified is a Destination (Dn + <ea> -> <ea>)
000016CA  6700 07EE                655              BEQ     ADD_L_DesEA
000016CE                           656  
000016CE  4EF9 00004846            657              JMP     InvalidOpcode       ; if it is not one of the opmode the opcode is invalid
000016D4                           658  
000016D4  7803                     659  ADD_B_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000016D6  4EB9 0000484E            660              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000016DC                           661  
000016DC  BABC 00000000            662              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000016E2  6700 003A                663              BEQ     ADD_B_SrcEA_M0
000016E6                           664  
000016E6  BABC 00000001            665              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
000016EC  6700 005E                666              BEQ     ADD_B_SrcEA_M1
000016F0                           667  
000016F0  BABC 00000002            668              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000016F6  6700 0082                669              BEQ     ADD_B_SrcEA_M2
000016FA                           670  
000016FA  BABC 00000003            671              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001700  6700 00A6                672              BEQ     ADD_B_SrcEA_M3
00001704                           673  
00001704  BABC 00000004            674              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000170A  6700 00CA                675              BEQ     ADD_B_SrcEA_M4
0000170E                           676  
0000170E  BABC 00000007            677              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001714  6700 00EE                678              BEQ     ADD_B_SrcEA_M7
00001718                           679  
00001718  4EF9 00004846            680              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000171E                           681  
0000171E                           682  ADD_B_SrcEA_M0
0000171E  7803                     683              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001720  4EB9 0000484E            684              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001726  4EB9 000049E2            685              JSR     PrintAdd
0000172C  4EB9 00004B50            686              JSR     LengthB
00001732  4EB9 00004B88            687              JSR     PrintSpace
00001738  4EB9 000049A2            688              JSR     PrintDataReg
0000173E                           689  
0000173E  1A00                     690              MOVE.B  D0,D5
00001740  12EE 0025                691              MOVE.B  37(A6),(A1)+             *,
00001744  4EB9 000049A2            692              JSR     PrintDataReg
0000174A                           693  
0000174A  4E75                     694              RTS                     ; return to input to get more input
0000174C                           695  
0000174C                           696  ADD_B_SrcEA_M1
0000174C  7803                     697              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000174E  4EB9 0000484E            698              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001754  4EB9 000049E2            699              JSR     PrintAdd
0000175A  4EB9 00004B50            700              JSR     LengthB
00001760  4EB9 00004B88            701              JSR     PrintSpace
00001766  4EB9 000049AE            702              JSR     PrintAddrReg
0000176C                           703  
0000176C  1A00                     704              MOVE.B  D0,D5
0000176E  12EE 0025                705              MOVE.B  37(A6),(A1)+             *,
00001772  4EB9 000049A2            706              JSR     PrintDataReg
00001778  4E75                     707              RTS                     ; return to input to get more input
0000177A                           708  
0000177A                           709  ADD_B_SrcEA_M2
0000177A  7803                     710              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000177C  4EB9 0000484E            711              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001782  4EB9 000049E2            712              JSR     PrintAdd
00001788  4EB9 00004B50            713              JSR     LengthB
0000178E  4EB9 00004B88            714              JSR     PrintSpace
00001794  4EB9 000049BA            715              JSR     PrintIndirAddrReg
0000179A                           716  
0000179A  1A00                     717              MOVE.B  D0,D5
0000179C  12EE 0025                718              MOVE.B  37(A6),(A1)+             *,
000017A0  4EB9 000049A2            719              JSR     PrintDataReg
000017A6                           720  
000017A6  4E75                     721              RTS                     ; return to input to get more input
000017A8                           722  
000017A8                           723  ADD_B_SrcEA_M3
000017A8  7803                     724              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000017AA  4EB9 0000484E            725              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000017B0  4EB9 000049E2            726              JSR     PrintAdd
000017B6  4EB9 00004B50            727              JSR     LengthB
000017BC  4EB9 00004B88            728              JSR     PrintSpace
000017C2  4EB9 000049C8            729              JSR     PrintPostIncAddrReg
000017C8                           730  
000017C8  1A00                     731              MOVE.B  D0,D5
000017CA  12EE 0025                732              MOVE.B  37(A6),(A1)+             *,
000017CE  4EB9 000049A2            733              JSR     PrintDataReg
000017D4  4E75                     734              RTS                     ; return to input to get more input
000017D6                           735  
000017D6                           736  ADD_B_SrcEA_M4
000017D6  7803                     737              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000017D8  4EB9 0000484E            738              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000017DE  4EB9 000049E2            739              JSR     PrintAdd
000017E4  4EB9 00004B50            740              JSR     LengthB
000017EA  4EB9 00004B88            741              JSR     PrintSpace
000017F0  4EB9 000049D2            742              JSR     PrintPreDeincAddrReg
000017F6                           743  
000017F6  1A00                     744              MOVE.B  D0,D5
000017F8  12EE 0025                745              MOVE.B  37(A6),(A1)+             *,
000017FC  4EB9 000049A2            746              JSR     PrintDataReg
00001802  4E75                     747              RTS                     ; return to input to get more input
00001804                           748  
00001804                           749  ADD_B_SrcEA_M7
00001804  7803                     750              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001806  4EB9 0000484E            751              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000180C                           752  
0000180C  BABC 00000000            753              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001812  6700 001C                754              BEQ     ADD_B_SrcEA_xxxW
00001816                           755  
00001816  BABC 00000001            756              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
0000181C  6700 0038                757              BEQ     ADD_B_SrcEA_xxxL
00001820                           758  
00001820  BABC 00000004            759              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00001826  6700 0054                760              BEQ     ADD_B_SrcEA_Data
0000182A                           761  
0000182A  4EF9 00004846            762              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001830                           763  
00001830                           764  ADD_B_SrcEA_xxxW
00001830  4EB9 000049E2            765              JSR     PrintAdd
00001836  4EB9 00004B50            766              JSR     LengthB
0000183C  4EB9 00004B88            767              JSR     PrintSpace
00001842  4EB9 00004948            768              JSR     PrintByteOrWord
00001848                           769  
00001848  1A00                     770              MOVE.B  D0,D5
0000184A  12EE 0025                771              MOVE.B  37(A6),(A1)+             *,
0000184E  4EB9 000049A2            772              JSR     PrintDataReg
00001854  4E75                     773              RTS                     ; return to input to get more input
00001856                           774  
00001856                           775  ADD_B_SrcEA_xxxL
00001856  4EB9 000049E2            776              JSR     PrintAdd
0000185C  4EB9 00004B50            777              JSR     LengthB
00001862  4EB9 00004B88            778              JSR     PrintSpace
00001868  4EB9 0000495E            779              JSR     PrintLong
0000186E                           780  
0000186E  1A00                     781              MOVE.B  D0,D5
00001870  12EE 0025                782              MOVE.B  37(A6),(A1)+             *,
00001874  4EB9 000049A2            783              JSR     PrintDataReg
0000187A  4E75                     784              RTS                     ; return to input to get more input
0000187C                           785  
0000187C                           786  ADD_B_SrcEA_Data
0000187C  4EB9 000049E2            787              JSR     PrintAdd
00001882  4EB9 00004B50            788              JSR     LengthB
00001888  4EB9 00004B88            789              JSR     PrintSpace
0000188E  4EB9 0000493C            790              JSR     PrintImmediateData
00001894                           791  
00001894  1A00                     792              MOVE.B  D0,D5
00001896  12EE 0025                793              MOVE.B  37(A6),(A1)+             *,
0000189A  4EB9 000049A2            794              JSR     PrintDataReg
000018A0  4E75                     795              RTS                     ; return to input to get more input
000018A2                           796  
000018A2  7803                     797  ADD_W_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000018A4  4EB9 0000484E            798              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000018AA                           799  
000018AA  BABC 00000000            800              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000018B0  6700 003A                801              BEQ     ADD_W_SrcEA_M0
000018B4                           802  
000018B4  BABC 00000001            803              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
000018BA  6700 005E                804              BEQ     ADD_W_SrcEA_M1
000018BE                           805  
000018BE  BABC 00000002            806              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000018C4  6700 0082                807              BEQ     ADD_W_SrcEA_M2
000018C8                           808  
000018C8  BABC 00000003            809              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000018CE  6700 00A6                810              BEQ     ADD_W_SrcEA_M3
000018D2                           811  
000018D2  BABC 00000004            812              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000018D8  6700 00CA                813              BEQ     ADD_W_SrcEA_M4
000018DC                           814  
000018DC  BABC 00000007            815              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000018E2  6700 00EE                816              BEQ     ADD_W_SrcEA_M7
000018E6                           817  
000018E6  4EF9 00004846            818              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000018EC                           819  
000018EC                           820  ADD_W_SrcEA_M0
000018EC  7803                     821              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000018EE  4EB9 0000484E            822              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000018F4  4EB9 000049E2            823              JSR     PrintAdd
000018FA  4EB9 00004B5A            824              JSR     LengthW
00001900  4EB9 00004B88            825              JSR     PrintSpace
00001906  4EB9 000049A2            826              JSR     PrintDataReg
0000190C                           827  
0000190C  1A00                     828              MOVE.B  D0,D5
0000190E  12EE 0025                829              MOVE.B  37(A6),(A1)+             *,
00001912  4EB9 000049A2            830              JSR     PrintDataReg
00001918  4E75                     831              RTS                     ; return to input to get more input
0000191A                           832  
0000191A                           833  ADD_W_SrcEA_M1
0000191A  7803                     834              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000191C  4EB9 0000484E            835              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001922  4EB9 000049E2            836              JSR     PrintAdd
00001928  4EB9 00004B5A            837              JSR     LengthW
0000192E  4EB9 00004B88            838              JSR     PrintSpace
00001934  4EB9 000049AE            839              JSR     PrintAddrReg
0000193A                           840  
0000193A  1A00                     841              MOVE.B  D0,D5
0000193C  12EE 0025                842              MOVE.B  37(A6),(A1)+             *,
00001940  4EB9 000049A2            843              JSR     PrintDataReg
00001946  4E75                     844              RTS                     ; return to input to get more input
00001948                           845  
00001948                           846  ADD_W_SrcEA_M2
00001948  7803                     847              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000194A  4EB9 0000484E            848              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001950  4EB9 000049E2            849              JSR     PrintAdd
00001956  4EB9 00004B5A            850              JSR     LengthW
0000195C  4EB9 00004B88            851              JSR     PrintSpace
00001962  4EB9 000049BA            852              JSR     PrintIndirAddrReg
00001968                           853  
00001968  1A00                     854              MOVE.B  D0,D5
0000196A  12EE 0025                855              MOVE.B  37(A6),(A1)+             *,
0000196E  4EB9 000049A2            856              JSR     PrintDataReg
00001974  4E75                     857              RTS                     ; return to input to get more input
00001976                           858  
00001976                           859  ADD_W_SrcEA_M3
00001976  7803                     860              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001978  4EB9 0000484E            861              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000197E  4EB9 000049E2            862              JSR     PrintAdd
00001984  4EB9 00004B5A            863              JSR     LengthW
0000198A  4EB9 00004B88            864              JSR     PrintSpace
00001990  4EB9 000049C8            865              JSR     PrintPostIncAddrReg
00001996                           866  
00001996  1A00                     867              MOVE.B  D0,D5
00001998  12EE 0025                868              MOVE.B  37(A6),(A1)+             *,
0000199C  4EB9 000049A2            869              JSR     PrintDataReg
000019A2  4E75                     870              RTS                     ; return to input to get more input
000019A4                           871  
000019A4                           872  ADD_W_SrcEA_M4
000019A4  7803                     873              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000019A6  4EB9 0000484E            874              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000019AC  4EB9 000049E2            875              JSR     PrintAdd
000019B2  4EB9 00004B5A            876              JSR     LengthW
000019B8  4EB9 00004B88            877              JSR     PrintSpace
000019BE  4EB9 000049D2            878              JSR     PrintPreDeincAddrReg
000019C4                           879  
000019C4  1A00                     880              MOVE.B  D0,D5
000019C6  12EE 0025                881              MOVE.B  37(A6),(A1)+             *,
000019CA  4EB9 000049A2            882              JSR     PrintDataReg
000019D0  4E75                     883              RTS                     ; return to input to get more input
000019D2                           884  
000019D2                           885  ADD_W_SrcEA_M7
000019D2  7803                     886              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000019D4  4EB9 0000484E            887              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000019DA                           888  
000019DA  BABC 00000000            889              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000019E0  6700 001C                890              BEQ     ADD_W_SrcEA_xxxW
000019E4                           891  
000019E4  BABC 00000001            892              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000019EA  6700 0038                893              BEQ     ADD_W_SrcEA_xxxL
000019EE                           894  
000019EE  BABC 00000004            895              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
000019F4  6700 0054                896              BEQ     ADD_W_SrcEA_Data
000019F8                           897  
000019F8  4EF9 00004846            898              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000019FE                           899  
000019FE                           900  ADD_W_SrcEA_xxxW
000019FE  4EB9 000049E2            901              JSR     PrintAdd
00001A04  4EB9 00004B5A            902              JSR     LengthW
00001A0A  4EB9 00004B88            903              JSR     PrintSpace
00001A10  4EB9 00004948            904              JSR     PrintByteOrWord
00001A16                           905  
00001A16  1A00                     906              MOVE.B  D0,D5
00001A18  12EE 0025                907              MOVE.B  37(A6),(A1)+             *,
00001A1C  4EB9 000049A2            908              JSR     PrintDataReg
00001A22  4E75                     909              RTS                     ; return to input to get more input
00001A24                           910  
00001A24                           911  ADD_W_SrcEA_xxxL
00001A24  4EB9 000049E2            912              JSR     PrintAdd
00001A2A  4EB9 00004B5A            913              JSR     LengthW
00001A30  4EB9 00004B88            914              JSR     PrintSpace
00001A36  4EB9 0000495E            915              JSR     PrintLong
00001A3C                           916  
00001A3C  1A00                     917              MOVE.B  D0,D5
00001A3E  12EE 0025                918              MOVE.B  37(A6),(A1)+             *,
00001A42  4EB9 000049A2            919              JSR     PrintDataReg
00001A48  4E75                     920              RTS                     ; return to input to get more input
00001A4A                           921  
00001A4A                           922  ADD_W_SrcEA_Data
00001A4A  4EB9 000049E2            923              JSR     PrintAdd
00001A50  4EB9 00004B5A            924              JSR     LengthW
00001A56  4EB9 00004B88            925              JSR     PrintSpace
00001A5C  4EB9 0000493C            926              JSR     PrintImmediateData
00001A62                           927  
00001A62  1A00                     928              MOVE.B  D0,D5
00001A64  12EE 0025                929              MOVE.B  37(A6),(A1)+             *,
00001A68  4EB9 000049A2            930              JSR     PrintDataReg
00001A6E  4E75                     931              RTS                     ; return to input to get more input
00001A70                           932  
00001A70  7803                     933  ADD_L_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001A72  4EB9 0000484E            934              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001A78                           935  
00001A78  BABC 00000000            936              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00001A7E  6700 003A                937              BEQ     ADD_L_SrcEA_M0
00001A82                           938  
00001A82  BABC 00000001            939              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00001A88  6700 005E                940              BEQ     ADD_L_SrcEA_M1
00001A8C                           941  
00001A8C  BABC 00000002            942              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001A92  6700 0082                943              BEQ     ADD_L_SrcEA_M2
00001A96                           944  
00001A96  BABC 00000003            945              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001A9C  6700 00A6                946              BEQ     ADD_L_SrcEA_M3
00001AA0                           947  
00001AA0  BABC 00000004            948              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001AA6  6700 00CA                949              BEQ     ADD_L_SrcEA_M4
00001AAA                           950  
00001AAA  BABC 00000007            951              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001AB0  6700 00EE                952              BEQ     ADD_L_SrcEA_M7
00001AB4                           953  
00001AB4  4EF9 00004846            954              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001ABA                           955  
00001ABA                           956  ADD_L_SrcEA_M0
00001ABA  7803                     957              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001ABC  4EB9 0000484E            958              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001AC2  4EB9 000049E2            959              JSR     PrintAdd
00001AC8  4EB9 00004B64            960              JSR     LengthL
00001ACE  4EB9 00004B88            961              JSR     PrintSpace
00001AD4  4EB9 000049A2            962              JSR     PrintDataReg
00001ADA                           963  
00001ADA  1A00                     964              MOVE.B  D0,D5
00001ADC  12EE 0025                965              MOVE.B  37(A6),(A1)+             *,
00001AE0  4EB9 000049A2            966              JSR     PrintDataReg
00001AE6  4E75                     967              RTS                     ; return to input to get more input
00001AE8                           968  
00001AE8                           969  ADD_L_SrcEA_M1
00001AE8  7803                     970              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001AEA  4EB9 0000484E            971              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001AF0  4EB9 000049E2            972              JSR     PrintAdd
00001AF6  4EB9 00004B64            973              JSR     LengthL
00001AFC  4EB9 00004B88            974              JSR     PrintSpace
00001B02  4EB9 000049AE            975              JSR     PrintAddrReg
00001B08                           976  
00001B08  1A00                     977              MOVE.B  D0,D5
00001B0A  12EE 0025                978              MOVE.B  37(A6),(A1)+             *,
00001B0E  4EB9 000049A2            979              JSR     PrintDataReg
00001B14  4E75                     980              RTS                     ; return to input to get more input
00001B16                           981  
00001B16                           982  ADD_L_SrcEA_M2
00001B16  7803                     983              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001B18  4EB9 0000484E            984              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001B1E  4EB9 000049E2            985              JSR     PrintAdd
00001B24  4EB9 00004B64            986              JSR     LengthL
00001B2A  4EB9 00004B88            987              JSR     PrintSpace
00001B30  4EB9 000049BA            988              JSR     PrintIndirAddrReg
00001B36                           989  
00001B36  1A00                     990              MOVE.B  D0,D5
00001B38  12EE 0025                991              MOVE.B  37(A6),(A1)+             *,
00001B3C  4EB9 000049A2            992              JSR     PrintDataReg
00001B42  4E75                     993              RTS                     ; return to input to get more input
00001B44                           994  
00001B44                           995  ADD_L_SrcEA_M3
00001B44  7803                     996              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001B46  4EB9 0000484E            997              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001B4C  4EB9 000049E2            998              JSR     PrintAdd
00001B52  4EB9 00004B64            999              JSR     LengthL
00001B58  4EB9 00004B88           1000              JSR     PrintSpace
00001B5E  4EB9 000049C8           1001              JSR     PrintPostIncAddrReg
00001B64                          1002  
00001B64  1A00                    1003              MOVE.B  D0,D5
00001B66  12EE 0025               1004              MOVE.B  37(A6),(A1)+             *,
00001B6A  4EB9 000049A2           1005              JSR     PrintDataReg
00001B70  4E75                    1006              RTS                     ; return to input to get more input
00001B72                          1007  
00001B72                          1008  ADD_L_SrcEA_M4
00001B72  7803                    1009              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001B74  4EB9 0000484E           1010              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001B7A  4EB9 000049E2           1011              JSR     PrintAdd
00001B80  4EB9 00004B64           1012              JSR     LengthL
00001B86  4EB9 00004B88           1013              JSR     PrintSpace
00001B8C  4EB9 000049D2           1014              JSR     PrintPreDeincAddrReg
00001B92                          1015  
00001B92  1A00                    1016              MOVE.B  D0,D5
00001B94  12EE 0025               1017              MOVE.B  37(A6),(A1)+             *,
00001B98  4EB9 000049A2           1018              JSR     PrintDataReg
00001B9E  4E75                    1019              RTS                     ; return to input to get more input
00001BA0                          1020  
00001BA0                          1021  ADD_L_SrcEA_M7
00001BA0  7803                    1022              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001BA2  4EB9 0000484E           1023              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001BA8                          1024  
00001BA8  BABC 00000000           1025              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001BAE  6700 001C               1026              BEQ     ADD_L_SrcEA_xxxW
00001BB2                          1027  
00001BB2  BABC 00000001           1028              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001BB8  6700 0038               1029              BEQ     ADD_L_SrcEA_xxxL
00001BBC                          1030  
00001BBC  BABC 00000004           1031              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00001BC2  6700 0054               1032              BEQ     ADD_L_SrcEA_Data
00001BC6                          1033  
00001BC6  4EF9 00004846           1034              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001BCC                          1035  
00001BCC                          1036  ADD_L_SrcEA_xxxW
00001BCC  4EB9 000049E2           1037              JSR     PrintAdd
00001BD2  4EB9 00004B64           1038              JSR     LengthL
00001BD8  4EB9 00004B88           1039              JSR     PrintSpace
00001BDE  4EB9 00004948           1040              JSR     PrintByteOrWord
00001BE4                          1041  
00001BE4  1A00                    1042              MOVE.B  D0,D5
00001BE6  12EE 0025               1043              MOVE.B  37(A6),(A1)+             *,
00001BEA  4EB9 000049A2           1044              JSR     PrintDataReg
00001BF0  4E75                    1045              RTS                     ; return to input to get more input
00001BF2                          1046  
00001BF2                          1047  ADD_L_SrcEA_xxxL
00001BF2  4EB9 000049E2           1048              JSR     PrintAdd
00001BF8  4EB9 00004B64           1049              JSR     LengthL
00001BFE  4EB9 00004B88           1050              JSR     PrintSpace
00001C04  4EB9 0000495E           1051              JSR     PrintLong
00001C0A                          1052  
00001C0A  1A00                    1053              MOVE.B  D0,D5
00001C0C  12EE 0025               1054              MOVE.B  37(A6),(A1)+             *,
00001C10  4EB9 000049A2           1055              JSR     PrintDataReg
00001C16  4E75                    1056              RTS                     ; return to input to get more input
00001C18                          1057  
00001C18                          1058  ADD_L_SrcEA_Data
00001C18  4EB9 000049E2           1059              JSR     PrintAdd
00001C1E  4EB9 00004B64           1060              JSR     LengthL
00001C24  4EB9 00004B88           1061              JSR     PrintSpace
00001C2A  4EB9 0000493C           1062              JSR     PrintImmediateData
00001C30                          1063  
00001C30  1A00                    1064              MOVE.B  D0,D5
00001C32  12EE 0025               1065              MOVE.B  37(A6),(A1)+             *,
00001C36  4EB9 000049A2           1066              JSR     PrintDataReg
00001C3C  4E75                    1067              RTS                     ; return to input to get more input
00001C3E                          1068  
00001C3E  7803                    1069  ADD_B_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001C40  4EB9 0000484E           1070              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001C46                          1071  
00001C46  BABC 00000002           1072              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001C4C  6700 0026               1073              BEQ     ADD_B_DesEA_M2
00001C50                          1074  
00001C50  BABC 00000003           1075              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001C56  6700 004E               1076              BEQ     ADD_B_DesEA_M3
00001C5A                          1077  
00001C5A  BABC 00000004           1078              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001C60  6700 0072               1079              BEQ     ADD_B_DesEA_M4
00001C64                          1080  
00001C64  BABC 00000007           1081              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001C6A  6700 009A               1082              BEQ     ADD_B_DesEA_M7
00001C6E                          1083  
00001C6E  4EF9 00004846           1084              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001C74                          1085  
00001C74                          1086  ADD_B_DesEA_M2
00001C74  7803                    1087              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001C76  4EB9 0000484E           1088              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001C7C  4EB9 000049E2           1089              JSR     PrintAdd
00001C82  4EB9 00004B50           1090              JSR     LengthB
00001C88  4EB9 00004B88           1091              JSR     PrintSpace
00001C8E                          1092  
00001C8E  1E05                    1093              MOVE.B  D5,D7
00001C90  1A00                    1094              MOVE.B  D0,D5
00001C92  4EB9 000049A2           1095              JSR     PrintDataReg
00001C98                          1096  
00001C98  1A07                    1097              MOVE.B  D7,D5
00001C9A  12EE 0025               1098              MOVE.B  37(A6),(A1)+             *,
00001C9E  4EB9 000049BA           1099              JSR     PrintIndirAddrReg
00001CA4  4E75                    1100              RTS                     ; return to input to get more input
00001CA6                          1101  
00001CA6                          1102  ADD_B_DesEA_M3
00001CA6  7803                    1103              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001CA8  4EB9 0000484E           1104              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001CAE  4EB9 000049E2           1105              JSR     PrintAdd
00001CB4  4EB9 00004B50           1106              JSR     LengthB
00001CBA  4EB9 00004B88           1107              JSR     PrintSpace
00001CC0  4EB9 000049C8           1108              JSR     PrintPostIncAddrReg
00001CC6                          1109  
00001CC6  1A00                    1110              MOVE.B  D0,D5
00001CC8  12EE 0025               1111              MOVE.B  37(A6),(A1)+             *,
00001CCC  4EB9 000049A2           1112              JSR     PrintDataReg
00001CD2  4E75                    1113              RTS                     ; return to input to get more input
00001CD4                          1114  
00001CD4                          1115  ADD_B_DesEA_M4
00001CD4  7803                    1116              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001CD6  4EB9 0000484E           1117              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001CDC  4EB9 000049E2           1118              JSR     PrintAdd
00001CE2  4EB9 00004B50           1119              JSR     LengthB
00001CE8  4EB9 00004B88           1120              JSR     PrintSpace
00001CEE                          1121  
00001CEE  1E05                    1122              MOVE.B  D5,D7
00001CF0  1A00                    1123              MOVE.B  D0,D5
00001CF2  4EB9 000049A2           1124              JSR     PrintDataReg
00001CF8                          1125  
00001CF8  1A07                    1126              MOVE.B  D7,D5
00001CFA  12EE 0025               1127              MOVE.B  37(A6),(A1)+             *,
00001CFE  4EB9 000049D2           1128              JSR     PrintPreDeincAddrReg
00001D04  4E75                    1129              RTS                     ; return to input to get more input
00001D06                          1130  
00001D06                          1131  ADD_B_DesEA_M7
00001D06  7803                    1132              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001D08  4EB9 0000484E           1133              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001D0E                          1134  
00001D0E  BABC 00000000           1135              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001D14  6700 0012               1136              BEQ     ADD_B_DesEA_xxxW
00001D18                          1137  
00001D18  BABC 00000001           1138              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001D1E  6700 0032               1139              BEQ     ADD_B_DesEA_xxxL
00001D22                          1140  
00001D22  4EF9 00004846           1141              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001D28                          1142  
00001D28                          1143  ADD_B_DesEA_xxxW
00001D28  4EB9 000049E2           1144              JSR     PrintAdd
00001D2E  4EB9 00004B50           1145              JSR     LengthB
00001D34  4EB9 00004B88           1146              JSR     PrintSpace
00001D3A                          1147  
00001D3A  1E05                    1148              MOVE.B  D5,D7
00001D3C  1A00                    1149              MOVE.B  D0,D5
00001D3E  4EB9 000049A2           1150              JSR     PrintDataReg
00001D44                          1151  
00001D44  1A07                    1152              MOVE.B  D7,D5
00001D46  12EE 0025               1153              MOVE.B  37(A6),(A1)+             *,
00001D4A  4EB9 00004948           1154              JSR     PrintByteOrWord
00001D50  4E75                    1155              RTS                     ; return to input to get more input
00001D52                          1156  
00001D52                          1157  ADD_B_DesEA_xxxL
00001D52  4EB9 000049E2           1158              JSR     PrintAdd
00001D58  4EB9 00004B50           1159              JSR     LengthB
00001D5E  4EB9 00004B88           1160              JSR     PrintSpace
00001D64                          1161  
00001D64  1E05                    1162              MOVE.B  D5,D7
00001D66  1A00                    1163              MOVE.B  D0,D5
00001D68  4EB9 000049A2           1164              JSR     PrintDataReg
00001D6E                          1165  
00001D6E  1A07                    1166              MOVE.B  D7,D5
00001D70  12EE 0025               1167              MOVE.B  37(A6),(A1)+             *,
00001D74  4EB9 0000495E           1168              JSR     PrintLong
00001D7A  4E75                    1169              RTS                     ; return to input to get more input
00001D7C                          1170  
00001D7C  7803                    1171  ADD_W_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001D7E  4EB9 0000484E           1172              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001D84                          1173  
00001D84  BABC 00000002           1174              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001D8A  6700 0026               1175              BEQ     ADD_W_DesEA_M2
00001D8E                          1176  
00001D8E  BABC 00000003           1177              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001D94  6700 004E               1178              BEQ     ADD_W_DesEA_M3
00001D98                          1179  
00001D98  BABC 00000004           1180              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001D9E  6700 0072               1181              BEQ     ADD_W_DesEA_M4
00001DA2                          1182  
00001DA2  BABC 00000007           1183              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001DA8  6700 009A               1184              BEQ     ADD_W_DesEA_M7
00001DAC                          1185  
00001DAC  4EF9 00004846           1186              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001DB2                          1187  
00001DB2                          1188  ADD_W_DesEA_M2
00001DB2  7803                    1189              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001DB4  4EB9 0000484E           1190              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001DBA  4EB9 000049E2           1191              JSR     PrintAdd
00001DC0  4EB9 00004B5A           1192              JSR     LengthW
00001DC6  4EB9 00004B88           1193              JSR     PrintSpace
00001DCC                          1194  
00001DCC  1E05                    1195              MOVE.B  D5,D7
00001DCE  1A00                    1196              MOVE.B  D0,D5
00001DD0  4EB9 000049A2           1197              JSR     PrintDataReg
00001DD6                          1198  
00001DD6  1A07                    1199              MOVE.B  D7,D5
00001DD8  12EE 0025               1200              MOVE.B  37(A6),(A1)+             *,
00001DDC  4EB9 000049BA           1201              JSR     PrintIndirAddrReg
00001DE2  4E75                    1202              RTS                     ; return to input to get more input
00001DE4                          1203  
00001DE4                          1204  ADD_W_DesEA_M3
00001DE4  7803                    1205              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001DE6  4EB9 0000484E           1206              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001DEC  4EB9 000049E2           1207              JSR     PrintAdd
00001DF2  4EB9 00004B5A           1208              JSR     LengthW
00001DF8  4EB9 00004B88           1209              JSR     PrintSpace
00001DFE  4EB9 000049C8           1210              JSR     PrintPostIncAddrReg
00001E04                          1211  
00001E04  1A00                    1212              MOVE.B  D0,D5
00001E06  12EE 0025               1213              MOVE.B  37(A6),(A1)+             *,
00001E0A  4EB9 000049A2           1214              JSR     PrintDataReg
00001E10  4E75                    1215              RTS                     ; return to input to get more input
00001E12                          1216  
00001E12                          1217  ADD_W_DesEA_M4
00001E12  7803                    1218              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001E14  4EB9 0000484E           1219              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001E1A  4EB9 000049E2           1220              JSR     PrintAdd
00001E20  4EB9 00004B5A           1221              JSR     LengthW
00001E26  4EB9 00004B88           1222              JSR     PrintSpace
00001E2C                          1223  
00001E2C  1E05                    1224              MOVE.B  D5,D7
00001E2E  1A00                    1225              MOVE.B  D0,D5
00001E30  4EB9 000049A2           1226              JSR     PrintDataReg
00001E36                          1227  
00001E36  1A07                    1228              MOVE.B  D7,D5
00001E38  12EE 0025               1229              MOVE.B  37(A6),(A1)+             *,
00001E3C  4EB9 000049D2           1230              JSR     PrintPreDeincAddrReg
00001E42  4E75                    1231              RTS                     ; return to input to get more input
00001E44                          1232  
00001E44                          1233  ADD_W_DesEA_M7
00001E44  7803                    1234              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001E46  4EB9 0000484E           1235              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001E4C                          1236  
00001E4C  BABC 00000000           1237              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001E52  6700 0012               1238              BEQ     ADD_W_DesEA_xxxW
00001E56                          1239  
00001E56  BABC 00000001           1240              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001E5C  6700 0032               1241              BEQ     ADD_W_DesEA_xxxL
00001E60                          1242  
00001E60  4EF9 00004846           1243              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001E66                          1244  
00001E66                          1245  ADD_W_DesEA_xxxW
00001E66  4EB9 000049E2           1246              JSR     PrintAdd
00001E6C  4EB9 00004B5A           1247              JSR     LengthW
00001E72  4EB9 00004B88           1248              JSR     PrintSpace
00001E78                          1249  
00001E78  1E05                    1250              MOVE.B  D5,D7
00001E7A  1A00                    1251              MOVE.B  D0,D5
00001E7C  4EB9 000049A2           1252              JSR     PrintDataReg
00001E82                          1253  
00001E82  1A07                    1254              MOVE.B  D7,D5
00001E84  12EE 0025               1255              MOVE.B  37(A6),(A1)+             *,
00001E88  4EB9 00004948           1256              JSR     PrintByteOrWord
00001E8E  4E75                    1257              RTS                     ; return to input to get more input
00001E90                          1258  
00001E90                          1259  ADD_W_DesEA_xxxL
00001E90  4EB9 000049E2           1260              JSR     PrintAdd
00001E96  4EB9 00004B5A           1261              JSR     LengthW
00001E9C  4EB9 00004B88           1262              JSR     PrintSpace
00001EA2                          1263  
00001EA2  1E05                    1264              MOVE.B  D5,D7
00001EA4  1A00                    1265              MOVE.B  D0,D5
00001EA6  4EB9 000049A2           1266              JSR     PrintDataReg
00001EAC                          1267  
00001EAC  1A07                    1268              MOVE.B  D7,D5
00001EAE  12EE 0025               1269              MOVE.B  37(A6),(A1)+             *,
00001EB2  4EB9 0000495E           1270              JSR     PrintLong
00001EB8  4E75                    1271              RTS                     ; return to input to get more input
00001EBA                          1272  
00001EBA                          1273  ADD_L_DesEA
00001EBA  7803                    1274              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001EBC  4EB9 0000484E           1275              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001EC2                          1276  
00001EC2  BABC 00000002           1277              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001EC8  6700 0026               1278              BEQ     ADD_L_DesEA_M2
00001ECC                          1279  
00001ECC  BABC 00000003           1280              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001ED2  6700 004E               1281              BEQ     ADD_L_DesEA_M3
00001ED6                          1282  
00001ED6  BABC 00000004           1283              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001EDC  6700 0072               1284              BEQ     ADD_L_DesEA_M4
00001EE0                          1285  
00001EE0  BABC 00000007           1286              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001EE6  6700 009A               1287              BEQ     ADD_L_DesEA_M7
00001EEA                          1288  
00001EEA  4EF9 00004846           1289              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001EF0                          1290  
00001EF0                          1291  ADD_L_DesEA_M2
00001EF0  7803                    1292              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001EF2  4EB9 0000484E           1293              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001EF8  4EB9 000049E2           1294              JSR     PrintAdd
00001EFE  4EB9 00004B64           1295              JSR     LengthL
00001F04  4EB9 00004B88           1296              JSR     PrintSpace
00001F0A                          1297  
00001F0A  1E05                    1298              MOVE.B  D5,D7
00001F0C  1A00                    1299              MOVE.B  D0,D5
00001F0E  4EB9 000049A2           1300              JSR     PrintDataReg
00001F14                          1301  
00001F14  1A07                    1302              MOVE.B  D7,D5
00001F16  12EE 0025               1303              MOVE.B  37(A6),(A1)+             *,
00001F1A  4EB9 000049BA           1304              JSR     PrintIndirAddrReg
00001F20  4E75                    1305              RTS                     ; return to input to get more input
00001F22                          1306  
00001F22                          1307  ADD_L_DesEA_M3
00001F22  7803                    1308              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001F24  4EB9 0000484E           1309              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001F2A  4EB9 000049E2           1310              JSR     PrintAdd
00001F30  4EB9 00004B64           1311              JSR     LengthL
00001F36  4EB9 00004B88           1312              JSR     PrintSpace
00001F3C  4EB9 000049C8           1313              JSR     PrintPostIncAddrReg
00001F42                          1314  
00001F42  1A00                    1315              MOVE.B  D0,D5
00001F44  12EE 0025               1316              MOVE.B  37(A6),(A1)+             *,
00001F48  4EB9 000049A2           1317              JSR     PrintDataReg
00001F4E  4E75                    1318              RTS                     ; return to input to get more input
00001F50                          1319  
00001F50                          1320  ADD_L_DesEA_M4
00001F50  7803                    1321              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001F52  4EB9 0000484E           1322              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001F58  4EB9 000049E2           1323              JSR     PrintAdd
00001F5E  4EB9 00004B64           1324              JSR     LengthL
00001F64  4EB9 00004B88           1325              JSR     PrintSpace
00001F6A                          1326  
00001F6A  1E05                    1327              MOVE.B  D5,D7
00001F6C  1A00                    1328              MOVE.B  D0,D5
00001F6E  4EB9 000049A2           1329              JSR     PrintDataReg
00001F74                          1330  
00001F74  1A07                    1331              MOVE.B  D7,D5
00001F76  12EE 0025               1332              MOVE.B  37(A6),(A1)+             *,
00001F7A  4EB9 000049D2           1333              JSR     PrintPreDeincAddrReg
00001F80  4E75                    1334              RTS                     ; return to input to get more input
00001F82                          1335  
00001F82                          1336  ADD_L_DesEA_M7
00001F82  7803                    1337              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001F84  4EB9 0000484E           1338              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001F8A                          1339  
00001F8A  BABC 00000000           1340              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001F90  6700 0012               1341              BEQ     ADD_L_DesEA_xxxW
00001F94                          1342  
00001F94  BABC 00000001           1343              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001F9A  6700 0032               1344              BEQ     ADD_L_DesEA_xxxL
00001F9E                          1345  
00001F9E  4EF9 00004846           1346              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001FA4                          1347  
00001FA4                          1348  ADD_L_DesEA_xxxW
00001FA4  4EB9 000049E2           1349              JSR     PrintAdd
00001FAA  4EB9 00004B64           1350              JSR     LengthL
00001FB0  4EB9 00004B88           1351              JSR     PrintSpace
00001FB6                          1352  
00001FB6  1E05                    1353              MOVE.B  D5,D7
00001FB8  1A00                    1354              MOVE.B  D0,D5
00001FBA  4EB9 000049A2           1355              JSR     PrintDataReg
00001FC0                          1356  
00001FC0  1A07                    1357              MOVE.B  D7,D5
00001FC2  12EE 0025               1358              MOVE.B  37(A6),(A1)+             *,
00001FC6  4EB9 00004948           1359              JSR     PrintByteOrWord
00001FCC  4E75                    1360              RTS                     ; return to input to get more input
00001FCE                          1361  
00001FCE                          1362  ADD_L_DesEA_xxxL
00001FCE  4EB9 000049E2           1363              JSR     PrintAdd
00001FD4  4EB9 00004B64           1364              JSR     LengthL
00001FDA  4EB9 00004B88           1365              JSR     PrintSpace
00001FE0                          1366  
00001FE0  1E05                    1367              MOVE.B  D5,D7
00001FE2  1A00                    1368              MOVE.B  D0,D5
00001FE4  4EB9 000049A2           1369              JSR     PrintDataReg
00001FEA                          1370  
00001FEA  1A07                    1371              MOVE.B  D7,D5
00001FEC  12EE 0025               1372              MOVE.B  37(A6),(A1)+             *,
00001FF0  4EB9 0000495E           1373              JSR     PrintLong
00001FF6  4E75                    1374              RTS                     ; return to input to get more input
00001FF8                          1375  
00001FF8                          1376  
00001FF8                          1377  *************************************************                MULS_W_AND_Opcode          *************************************************
00001FF8                          1378  ; first four bit is (1100 #### #### ####)
00001FF8                          1379  MULS_W_AND_Opcode
00001FF8  7803                    1380              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00001FFA  4EB9 0000484E           1381              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00002000                          1382  
00002000  2005                    1383              MOVE.L  D5,D0               ; D0 will hold the register
00002002                          1384          ; D0 will hold the register (position 11-9)
00002002                          1385  
00002002  7803                    1386              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00002004  4EB9 0000484E           1387              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the opmode, and opcode
0000200A                          1388  
0000200A  BABC 00000000           1389              CMP.L   #0,D5               ; if opmode is 0, it is a byte with location specified is a source  (<ea> ^ Dn -> Dn)
00002010  6700 0044               1390              BEQ     And_B_SrcEA
00002014                          1391  
00002014  BABC 00000001           1392              CMP.L   #1,D5               ; if opmode is 1, it is a word with location specified is a source  (<ea> ^ Dn -> Dn)
0000201A  6700 01D0               1393              BEQ     And_W_SrcEA
0000201E                          1394  
0000201E  BABC 00000002           1395              CMP.L   #2,D5               ; if opmode is 2, it is a long with location specified is a source  (<ea> ^ Dn -> Dn)
00002024  6700 035C               1396              BEQ     And_L_SrcEA
00002028                          1397  
00002028  BABC 00000004           1398              CMP.L   #4,D5               ; if opmode is 4, it is a byte with location specified is desination (Dn ^ <ea> -> <ea>)
0000202E  6700 04E8               1399              BEQ     And_B_DesEA
00002032                          1400  
00002032  BABC 00000005           1401              CMP.L   #5,D5               ; if opmode is 5, it is a word with location specified is desination (Dn ^ <ea> -> <ea>)
00002038  6700 0620               1402              BEQ     And_W_DesEA
0000203C                          1403  
0000203C  BABC 00000006           1404              CMP.L   #6,D5               ; if opmode is 6, it is a long with location specified is desination (Dn ^ <ea> -> <ea>)
00002042  6700 0758               1405              BEQ     And_L_DesEA
00002046                          1406  
00002046  BABC 00000007           1407              CMP.L   #7,D5               ; if opmode is 7, the opcode is MULS.W
0000204C  6700 0890               1408              BEQ     MULS_W
00002050                          1409  
00002050  4EF9 00004846           1410              JMP     InvalidOpcode       ; it is not valid since it is not one of the valid opmode
00002056                          1411  
00002056  7803                    1412  And_B_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002058  4EB9 0000484E           1413              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
0000205E                          1414  
0000205E  BABC 00000000           1415              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002064  6700 0030               1416              BEQ     And_B_SrcEA_M0
00002068                          1417  
00002068  BABC 00000002           1418              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
0000206E  6700 0054               1419              BEQ     And_B_SrcEA_M2
00002072                          1420  
00002072  BABC 00000003           1421              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002078  6700 0078               1422              BEQ     And_B_SrcEA_M3
0000207C                          1423  
0000207C  BABC 00000004           1424              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002082  6700 009C               1425              BEQ     And_B_SrcEA_M4
00002086                          1426  
00002086  BABC 00000007           1427              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
0000208C  6700 00C0               1428              BEQ     And_B_SrcEA_M7
00002090                          1429  
00002090  4EF9 00004846           1430              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002096                          1431  
00002096                          1432  And_B_SrcEA_M0
00002096  7803                    1433              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002098  4EB9 0000484E           1434              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000209E  4EB9 00004A04           1435              JSR     PrintAnd
000020A4  4EB9 00004B50           1436              JSR     LengthB
000020AA  4EB9 00004B88           1437              JSR     PrintSpace
000020B0  4EB9 000049A2           1438              JSR     PrintDataReg
000020B6                          1439  
000020B6  1A00                    1440              MOVE.B  D0,D5
000020B8  12EE 0025               1441              MOVE.B  37(A6),(A1)+             *,
000020BC  4EB9 000049A2           1442              JSR     PrintDataReg
000020C2  4E75                    1443              RTS                     ; return to input to get more input
000020C4                          1444  
000020C4                          1445  And_B_SrcEA_M2
000020C4  7803                    1446              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000020C6  4EB9 0000484E           1447              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000020CC  4EB9 00004A04           1448              JSR     PrintAnd
000020D2  4EB9 00004B50           1449              JSR     LengthB
000020D8  4EB9 00004B88           1450              JSR     PrintSpace
000020DE  4EB9 000049BA           1451              JSR     PrintIndirAddrReg
000020E4                          1452  
000020E4  1A00                    1453              MOVE.B  D0,D5
000020E6  12EE 0025               1454              MOVE.B  37(A6),(A1)+             *,
000020EA  4EB9 000049A2           1455              JSR     PrintDataReg
000020F0  4E75                    1456              RTS                     ; return to input to get more input
000020F2                          1457  
000020F2                          1458  And_B_SrcEA_M3
000020F2  7803                    1459              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000020F4  4EB9 0000484E           1460              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000020FA  4EB9 00004A04           1461              JSR     PrintAnd
00002100  4EB9 00004B50           1462              JSR     LengthB
00002106  4EB9 00004B88           1463              JSR     PrintSpace
0000210C  4EB9 000049C8           1464              JSR     PrintPostIncAddrReg
00002112                          1465  
00002112  1A00                    1466              MOVE.B  D0,D5
00002114  12EE 0025               1467              MOVE.B  37(A6),(A1)+             *,
00002118  4EB9 000049A2           1468              JSR     PrintDataReg
0000211E  4E75                    1469              RTS                     ; return to input to get more input
00002120                          1470  
00002120                          1471  And_B_SrcEA_M4
00002120  7803                    1472              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002122  4EB9 0000484E           1473              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002128  4EB9 00004A04           1474              JSR     PrintAnd
0000212E  4EB9 00004B50           1475              JSR     LengthB
00002134  4EB9 00004B88           1476              JSR     PrintSpace
0000213A  4EB9 000049D2           1477              JSR     PrintPreDeincAddrReg
00002140                          1478  
00002140  1A00                    1479              MOVE.B  D0,D5
00002142  12EE 0025               1480              MOVE.B  37(A6),(A1)+             *,
00002146  4EB9 000049A2           1481              JSR     PrintDataReg
0000214C  4E75                    1482              RTS                     ; return to input to get more input
0000214E                          1483  
0000214E                          1484  And_B_SrcEA_M7
0000214E  7803                    1485              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002150  4EB9 0000484E           1486              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002156                          1487  
00002156  BABC 00000000           1488              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
0000215C  6700 001C               1489              BEQ     And_B_SrcEA_xxxW
00002160                          1490  
00002160  BABC 00000001           1491              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002166  6700 0038               1492              BEQ     And_B_SrcEA_xxxL
0000216A                          1493  
0000216A  BABC 00000004           1494              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002170  6700 0054               1495              BEQ     And_B_SrcEA_Data
00002174                          1496  
00002174  4EF9 00004846           1497              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000217A                          1498  
0000217A                          1499  And_B_SrcEA_xxxW
0000217A  4EB9 00004A04           1500              JSR     PrintAnd
00002180  4EB9 00004B50           1501              JSR     LengthB
00002186  4EB9 00004B88           1502              JSR     PrintSpace
0000218C  4EB9 00004948           1503              JSR     PrintByteOrWord
00002192                          1504  
00002192  1A00                    1505              MOVE.B  D0,D5
00002194  12EE 0025               1506              MOVE.B  37(A6),(A1)+             *,
00002198  4EB9 000049A2           1507              JSR     PrintDataReg
0000219E  4E75                    1508              RTS                     ; return to input to get more input
000021A0                          1509  
000021A0                          1510  And_B_SrcEA_xxxL
000021A0  4EB9 00004A04           1511              JSR     PrintAnd
000021A6  4EB9 00004B50           1512              JSR     LengthB
000021AC  4EB9 00004B88           1513              JSR     PrintSpace
000021B2  4EB9 0000495E           1514              JSR     PrintLong
000021B8                          1515  
000021B8  1A00                    1516              MOVE.B  D0,D5
000021BA  12EE 0025               1517              MOVE.B  37(A6),(A1)+             *,
000021BE  4EB9 000049A2           1518              JSR     PrintDataReg
000021C4  4E75                    1519              RTS                     ; return to input to get more input
000021C6                          1520  
000021C6                          1521  And_B_SrcEA_Data
000021C6  4EB9 00004A04           1522              JSR     PrintAnd
000021CC  4EB9 00004B50           1523              JSR     LengthB
000021D2  4EB9 00004B88           1524              JSR     PrintSpace
000021D8  4EB9 0000493C           1525              JSR     PrintImmediateData
000021DE                          1526  
000021DE  1A00                    1527              MOVE.B  D0,D5
000021E0  12EE 0025               1528              MOVE.B  37(A6),(A1)+             *,
000021E4  4EB9 000049A2           1529              JSR     PrintDataReg
000021EA  4E75                    1530              RTS                     ; return to input to get more input
000021EC                          1531  
000021EC  7803                    1532  And_W_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000021EE  4EB9 0000484E           1533              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000021F4                          1534  
000021F4  BABC 00000000           1535              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000021FA  6700 0030               1536              BEQ     And_W_SrcEA_M0
000021FE                          1537  
000021FE  BABC 00000002           1538              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002204  6700 0054               1539              BEQ     And_W_SrcEA_M2
00002208                          1540  
00002208  BABC 00000003           1541              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
0000220E  6700 0078               1542              BEQ     And_W_SrcEA_M3
00002212                          1543  
00002212  BABC 00000004           1544              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002218  6700 009C               1545              BEQ     And_W_SrcEA_M4
0000221C                          1546  
0000221C  BABC 00000007           1547              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002222  6700 00C0               1548              BEQ     And_W_SrcEA_M7
00002226                          1549  
00002226  4EF9 00004846           1550              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000222C                          1551  
0000222C                          1552  And_W_SrcEA_M0
0000222C  7803                    1553              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000222E  4EB9 0000484E           1554              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002234  4EB9 00004A04           1555              JSR     PrintAnd
0000223A  4EB9 00004B5A           1556              JSR     LengthW
00002240  4EB9 00004B88           1557              JSR     PrintSpace
00002246  4EB9 000049A2           1558              JSR     PrintDataReg
0000224C                          1559  
0000224C  1A00                    1560              MOVE.B  D0,D5
0000224E  12EE 0025               1561              MOVE.B  37(A6),(A1)+             *,
00002252  4EB9 000049A2           1562              JSR     PrintDataReg
00002258  4E75                    1563              RTS                     ; return to input to get more input
0000225A                          1564  
0000225A                          1565  And_W_SrcEA_M2
0000225A  7803                    1566              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000225C  4EB9 0000484E           1567              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002262  4EB9 00004A04           1568              JSR     PrintAnd
00002268  4EB9 00004B5A           1569              JSR     LengthW
0000226E  4EB9 00004B88           1570              JSR     PrintSpace
00002274  4EB9 000049BA           1571              JSR     PrintIndirAddrReg
0000227A                          1572  
0000227A  1A00                    1573              MOVE.B  D0,D5
0000227C  12EE 0025               1574              MOVE.B  37(A6),(A1)+             *,
00002280  4EB9 000049A2           1575              JSR     PrintDataReg
00002286  4E75                    1576              RTS                     ; return to input to get more input
00002288                          1577  
00002288                          1578  And_W_SrcEA_M3
00002288  7803                    1579              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000228A  4EB9 0000484E           1580              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002290  4EB9 00004A04           1581              JSR     PrintAnd
00002296  4EB9 00004B5A           1582              JSR     LengthW
0000229C  4EB9 00004B88           1583              JSR     PrintSpace
000022A2  4EB9 000049C8           1584              JSR     PrintPostIncAddrReg
000022A8                          1585  
000022A8  1A00                    1586              MOVE.B  D0,D5
000022AA  12EE 0025               1587              MOVE.B  37(A6),(A1)+             *,
000022AE  4EB9 000049A2           1588              JSR     PrintDataReg
000022B4  4E75                    1589              RTS                     ; return to input to get more input
000022B6                          1590  
000022B6                          1591  And_W_SrcEA_M4
000022B6  7803                    1592              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000022B8  4EB9 0000484E           1593              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000022BE  4EB9 00004A04           1594              JSR     PrintAnd
000022C4  4EB9 00004B5A           1595              JSR     LengthW
000022CA  4EB9 00004B88           1596              JSR     PrintSpace
000022D0  4EB9 000049D2           1597              JSR     PrintPreDeincAddrReg
000022D6                          1598  
000022D6  1A00                    1599              MOVE.B  D0,D5
000022D8  12EE 0025               1600              MOVE.B  37(A6),(A1)+             *,
000022DC  4EB9 000049A2           1601              JSR     PrintDataReg
000022E2  4E75                    1602              RTS                     ; return to input to get more input
000022E4                          1603  
000022E4                          1604  And_W_SrcEA_M7
000022E4  7803                    1605              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000022E6  4EB9 0000484E           1606              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000022EC                          1607  
000022EC  BABC 00000000           1608              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000022F2  6700 001C               1609              BEQ     And_W_SrcEA_xxxW
000022F6                          1610  
000022F6  BABC 00000001           1611              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000022FC  6700 0038               1612              BEQ     And_W_SrcEA_xxxL
00002300                          1613  
00002300  BABC 00000004           1614              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002306  6700 0054               1615              BEQ     And_W_SrcEA_Data
0000230A                          1616  
0000230A  4EF9 00004846           1617              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002310                          1618  
00002310                          1619  And_W_SrcEA_xxxW
00002310  4EB9 00004A04           1620              JSR     PrintAnd
00002316  4EB9 00004B5A           1621              JSR     LengthW
0000231C  4EB9 00004B88           1622              JSR     PrintSpace
00002322  4EB9 00004948           1623              JSR     PrintByteOrWord
00002328                          1624  
00002328  1A00                    1625              MOVE.B  D0,D5
0000232A  12EE 0025               1626              MOVE.B  37(A6),(A1)+             *,
0000232E  4EB9 000049A2           1627              JSR     PrintDataReg
00002334  4E75                    1628              RTS                     ; return to input to get more input
00002336                          1629  
00002336                          1630  And_W_SrcEA_xxxL
00002336  4EB9 00004A04           1631              JSR     PrintAnd
0000233C  4EB9 00004B5A           1632              JSR     LengthW
00002342  4EB9 00004B88           1633              JSR     PrintSpace
00002348  4EB9 0000495E           1634              JSR     PrintLong
0000234E                          1635  
0000234E  1A00                    1636              MOVE.B  D0,D5
00002350  12EE 0025               1637              MOVE.B  37(A6),(A1)+             *,
00002354  4EB9 000049A2           1638              JSR     PrintDataReg
0000235A  4E75                    1639              RTS                     ; return to input to get more input
0000235C                          1640  
0000235C                          1641  And_W_SrcEA_Data
0000235C  4EB9 00004A04           1642              JSR     PrintAnd
00002362  4EB9 00004B5A           1643              JSR     LengthW
00002368  4EB9 00004B88           1644              JSR     PrintSpace
0000236E  4EB9 0000493C           1645              JSR     PrintImmediateData
00002374                          1646  
00002374  1A00                    1647              MOVE.B  D0,D5
00002376  12EE 0025               1648              MOVE.B  37(A6),(A1)+             *,
0000237A  4EB9 000049A2           1649              JSR     PrintDataReg
00002380  4E75                    1650              RTS                     ; return to input to get more input
00002382                          1651  
00002382  7803                    1652  And_L_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002384  4EB9 0000484E           1653              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
0000238A                          1654  
0000238A  BABC 00000000           1655              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002390  6700 0030               1656              BEQ     And_L_SrcEA_M0
00002394                          1657  
00002394  BABC 00000002           1658              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
0000239A  6700 0054               1659              BEQ     And_L_SrcEA_M2
0000239E                          1660  
0000239E  BABC 00000003           1661              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000023A4  6700 0078               1662              BEQ     And_L_SrcEA_M3
000023A8                          1663  
000023A8  BABC 00000004           1664              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000023AE  6700 009C               1665              BEQ     And_L_SrcEA_M4
000023B2                          1666  
000023B2  BABC 00000007           1667              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000023B8  6700 00C0               1668              BEQ     And_L_SrcEA_M7
000023BC                          1669  
000023BC  4EF9 00004846           1670              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000023C2                          1671  
000023C2                          1672  And_L_SrcEA_M0
000023C2  7803                    1673              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000023C4  4EB9 0000484E           1674              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000023CA  4EB9 00004A04           1675              JSR     PrintAnd
000023D0  4EB9 00004B64           1676              JSR     LengthL
000023D6  4EB9 00004B88           1677              JSR     PrintSpace
000023DC  4EB9 000049A2           1678              JSR     PrintDataReg
000023E2                          1679  
000023E2  1A00                    1680              MOVE.B  D0,D5
000023E4  12EE 0025               1681              MOVE.B  37(A6),(A1)+             *,
000023E8  4EB9 000049A2           1682              JSR     PrintDataReg
000023EE  4E75                    1683              RTS                     ; return to input to get more input
000023F0                          1684  
000023F0                          1685  And_L_SrcEA_M2
000023F0  7803                    1686              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000023F2  4EB9 0000484E           1687              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000023F8  4EB9 00004A04           1688              JSR     PrintAnd
000023FE  4EB9 00004B64           1689              JSR     LengthL
00002404  4EB9 00004B88           1690              JSR     PrintSpace
0000240A  4EB9 000049BA           1691              JSR     PrintIndirAddrReg
00002410                          1692  
00002410  1A00                    1693              MOVE.B  D0,D5
00002412  12EE 0025               1694              MOVE.B  37(A6),(A1)+             *,
00002416  4EB9 000049A2           1695              JSR     PrintDataReg
0000241C  4E75                    1696              RTS                     ; return to input to get more input
0000241E                          1697  
0000241E                          1698  And_L_SrcEA_M3
0000241E  7803                    1699              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002420  4EB9 0000484E           1700              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002426  4EB9 00004A04           1701              JSR     PrintAnd
0000242C  4EB9 00004B64           1702              JSR     LengthL
00002432  4EB9 00004B88           1703              JSR     PrintSpace
00002438  4EB9 000049C8           1704              JSR     PrintPostIncAddrReg
0000243E                          1705  
0000243E  1A00                    1706              MOVE.B  D0,D5
00002440  12EE 0025               1707              MOVE.B  37(A6),(A1)+             *,
00002444  4EB9 000049A2           1708              JSR     PrintDataReg
0000244A  4E75                    1709              RTS                     ; return to input to get more input
0000244C                          1710  
0000244C                          1711  And_L_SrcEA_M4
0000244C  7803                    1712              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000244E  4EB9 0000484E           1713              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002454  4EB9 00004A04           1714              JSR     PrintAnd
0000245A  4EB9 00004B64           1715              JSR     LengthL
00002460  4EB9 00004B88           1716              JSR     PrintSpace
00002466  4EB9 000049D2           1717              JSR     PrintPreDeincAddrReg
0000246C                          1718  
0000246C  1A00                    1719              MOVE.B  D0,D5
0000246E  12EE 0025               1720              MOVE.B  37(A6),(A1)+             *,
00002472  4EB9 000049A2           1721              JSR     PrintDataReg
00002478  4E75                    1722              RTS                     ; return to input to get more input
0000247A                          1723  
0000247A                          1724  And_L_SrcEA_M7
0000247A  7803                    1725              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000247C  4EB9 0000484E           1726              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002482                          1727  
00002482  BABC 00000000           1728              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002488  6700 001C               1729              BEQ     And_L_SrcEA_xxxW
0000248C                          1730  
0000248C  BABC 00000001           1731              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002492  6700 0038               1732              BEQ     And_L_SrcEA_xxxL
00002496                          1733  
00002496  BABC 00000004           1734              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
0000249C  6700 0054               1735              BEQ     And_L_SrcEA_Data
000024A0                          1736  
000024A0  4EF9 00004846           1737              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000024A6                          1738  
000024A6                          1739  And_L_SrcEA_xxxW
000024A6  4EB9 00004A04           1740              JSR     PrintAnd
000024AC  4EB9 00004B64           1741              JSR     LengthL
000024B2  4EB9 00004B88           1742              JSR     PrintSpace
000024B8  4EB9 00004948           1743              JSR     PrintByteOrWord
000024BE                          1744  
000024BE  1A00                    1745              MOVE.B  D0,D5
000024C0  12EE 0025               1746              MOVE.B  37(A6),(A1)+             *,
000024C4  4EB9 000049A2           1747              JSR     PrintDataReg
000024CA  4E75                    1748              RTS                     ; return to input to get more input
000024CC                          1749  
000024CC                          1750  And_L_SrcEA_xxxL
000024CC  4EB9 00004A04           1751              JSR     PrintAnd
000024D2  4EB9 00004B64           1752              JSR     LengthL
000024D8  4EB9 00004B88           1753              JSR     PrintSpace
000024DE  4EB9 0000495E           1754              JSR     PrintLong
000024E4                          1755  
000024E4  1A00                    1756              MOVE.B  D0,D5
000024E6  12EE 0025               1757              MOVE.B  37(A6),(A1)+             *,
000024EA  4EB9 000049A2           1758              JSR     PrintDataReg
000024F0  4E75                    1759              RTS                     ; return to input to get more input
000024F2                          1760  
000024F2                          1761  And_L_SrcEA_Data
000024F2  4EB9 00004A04           1762              JSR     PrintAnd
000024F8  4EB9 00004B64           1763              JSR     LengthL
000024FE  4EB9 00004B88           1764              JSR     PrintSpace
00002504  4EB9 0000493C           1765              JSR     PrintImmediateData
0000250A                          1766  
0000250A  1A00                    1767              MOVE.B  D0,D5
0000250C  12EE 0025               1768              MOVE.B  37(A6),(A1)+             *,
00002510  4EB9 000049A2           1769              JSR     PrintDataReg
00002516  4E75                    1770              RTS                     ; return to input to get more input
00002518                          1771  
00002518  7803                    1772  And_B_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000251A  4EB9 0000484E           1773              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002520                          1774  
00002520  BABC 00000002           1775              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002526  6700 0026               1776              BEQ     And_B_DesEA_M2
0000252A                          1777  
0000252A  BABC 00000003           1778              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002530  6700 004E               1779              BEQ     And_B_DesEA_M3
00002534                          1780  
00002534  BABC 00000004           1781              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000253A  6700 0076               1782              BEQ     And_B_DesEA_M4
0000253E                          1783  
0000253E  BABC 00000007           1784              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002544  6700 009E               1785              BEQ     And_B_DesEA_M7
00002548                          1786  
00002548  4EF9 00004846           1787              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000254E                          1788  
0000254E                          1789  And_B_DesEA_M2
0000254E  7803                    1790              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002550  4EB9 0000484E           1791              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002556  4EB9 00004A04           1792              JSR     PrintAnd
0000255C  4EB9 00004B50           1793              JSR     LengthB
00002562  4EB9 00004B88           1794              JSR     PrintSpace
00002568                          1795  
00002568  1E05                    1796              MOVE.B  D5,D7
0000256A  1A00                    1797              MOVE.B  D0,D5
0000256C  4EB9 000049A2           1798              JSR     PrintDataReg
00002572                          1799  
00002572  1A07                    1800              MOVE.B  D7,D5
00002574  12EE 0025               1801              MOVE.B  37(A6),(A1)+             *,
00002578  4EB9 000049BA           1802              JSR     PrintIndirAddrReg
0000257E  4E75                    1803              RTS                     ; return to input to get more input
00002580                          1804  
00002580                          1805  And_B_DesEA_M3
00002580  7803                    1806              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002582  4EB9 0000484E           1807              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002588  4EB9 00004A04           1808              JSR     PrintAnd
0000258E  4EB9 00004B50           1809              JSR     LengthB
00002594  4EB9 00004B88           1810              JSR     PrintSpace
0000259A                          1811  
0000259A  1E05                    1812              MOVE.B  D5,D7
0000259C  1A00                    1813              MOVE.B  D0,D5
0000259E  4EB9 000049A2           1814              JSR     PrintDataReg
000025A4                          1815  
000025A4  1A07                    1816              MOVE.B  D7,D5
000025A6  12EE 0025               1817              MOVE.B  37(A6),(A1)+             *,
000025AA  4EB9 000049C8           1818              JSR     PrintPostIncAddrReg
000025B0  4E75                    1819              RTS                     ; return to input to get more input
000025B2                          1820  
000025B2                          1821  And_B_DesEA_M4
000025B2  7803                    1822              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000025B4  4EB9 0000484E           1823              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000025BA  4EB9 00004A04           1824              JSR     PrintAnd
000025C0  4EB9 00004B50           1825              JSR     LengthB
000025C6  4EB9 00004B88           1826              JSR     PrintSpace
000025CC                          1827  
000025CC  1E05                    1828              MOVE.B  D5,D7
000025CE  1A00                    1829              MOVE.B  D0,D5
000025D0  4EB9 000049A2           1830              JSR     PrintDataReg
000025D6                          1831  
000025D6  1A07                    1832              MOVE.B  D7,D5
000025D8  12EE 0025               1833              MOVE.B  37(A6),(A1)+             *,
000025DC  4EB9 000049D2           1834              JSR     PrintPreDeincAddrReg
000025E2  4E75                    1835              RTS                     ; return to input to get more input
000025E4                          1836  
000025E4                          1837  And_B_DesEA_M7
000025E4  7803                    1838              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000025E6  4EB9 0000484E           1839              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000025EC                          1840  
000025EC  BABC 00000000           1841              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000025F2  6700 0012               1842              BEQ     And_B_DesEA_xxxW
000025F6                          1843  
000025F6  BABC 00000001           1844              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000025FC  6700 0032               1845              BEQ     And_B_DesEA_xxxL
00002600                          1846  
00002600  4EF9 00004846           1847              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002606                          1848  
00002606                          1849  And_B_DesEA_xxxW
00002606  4EB9 00004A04           1850              JSR     PrintAnd
0000260C  4EB9 00004B50           1851              JSR     LengthB
00002612  4EB9 00004B88           1852              JSR     PrintSpace
00002618                          1853  
00002618  1E05                    1854              MOVE.B  D5,D7
0000261A  1A00                    1855              MOVE.B  D0,D5
0000261C  4EB9 000049A2           1856              JSR     PrintDataReg
00002622                          1857  
00002622  1A07                    1858              MOVE.B  D7,D5
00002624  12EE 0025               1859              MOVE.B  37(A6),(A1)+             *,
00002628  4EB9 00004948           1860              JSR     PrintByteOrWord
0000262E  4E75                    1861              RTS                     ; return to input to get more input
00002630                          1862  
00002630                          1863  And_B_DesEA_xxxL
00002630  4EB9 00004A04           1864              JSR     PrintAnd
00002636  4EB9 00004B50           1865              JSR     LengthB
0000263C  4EB9 00004B88           1866              JSR     PrintSpace
00002642                          1867  
00002642  1E05                    1868              MOVE.B  D5,D7
00002644  1A00                    1869              MOVE.B  D0,D5
00002646  4EB9 000049A2           1870              JSR     PrintDataReg
0000264C                          1871  
0000264C  1A07                    1872              MOVE.B  D7,D5
0000264E  12EE 0025               1873              MOVE.B  37(A6),(A1)+             *,
00002652  4EB9 0000495E           1874              JSR     PrintLong
00002658  4E75                    1875              RTS                     ; return to input to get more input
0000265A                          1876  
0000265A  7803                    1877  And_W_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000265C  4EB9 0000484E           1878              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002662                          1879  
00002662  BABC 00000002           1880              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002668  6700 0026               1881              BEQ     And_W_DesEA_M2
0000266C                          1882  
0000266C  BABC 00000003           1883              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002672  6700 004E               1884              BEQ     And_W_DesEA_M3
00002676                          1885  
00002676  BABC 00000004           1886              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000267C  6700 0076               1887              BEQ     And_W_DesEA_M4
00002680                          1888  
00002680  BABC 00000007           1889              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002686  6700 009E               1890              BEQ     And_W_DesEA_M7
0000268A                          1891  
0000268A  4EF9 00004846           1892              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002690                          1893  
00002690                          1894  And_W_DesEA_M2
00002690  7803                    1895              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002692  4EB9 0000484E           1896              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002698  4EB9 00004A04           1897              JSR     PrintAnd
0000269E  4EB9 00004B5A           1898              JSR     LengthW
000026A4  4EB9 00004B88           1899              JSR     PrintSpace
000026AA                          1900  
000026AA  1E05                    1901              MOVE.B  D5,D7
000026AC  1A00                    1902              MOVE.B  D0,D5
000026AE  4EB9 000049A2           1903              JSR     PrintDataReg
000026B4                          1904  
000026B4  1A07                    1905              MOVE.B  D7,D5
000026B6  12EE 0025               1906              MOVE.B  37(A6),(A1)+             *,
000026BA  4EB9 000049BA           1907              JSR     PrintIndirAddrReg
000026C0  4E75                    1908              RTS                     ; return to input to get more input
000026C2                          1909  
000026C2                          1910  And_W_DesEA_M3
000026C2  7803                    1911              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000026C4  4EB9 0000484E           1912              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000026CA  4EB9 00004A04           1913              JSR     PrintAnd
000026D0  4EB9 00004B5A           1914              JSR     LengthW
000026D6  4EB9 00004B88           1915              JSR     PrintSpace
000026DC                          1916  
000026DC  1E05                    1917              MOVE.B  D5,D7
000026DE  1A00                    1918              MOVE.B  D0,D5
000026E0  4EB9 000049A2           1919              JSR     PrintDataReg
000026E6                          1920  
000026E6  1A07                    1921              MOVE.B  D7,D5
000026E8  12EE 0025               1922              MOVE.B  37(A6),(A1)+             *,
000026EC  4EB9 000049C8           1923              JSR     PrintPostIncAddrReg
000026F2  4E75                    1924              RTS                     ; return to input to get more input
000026F4                          1925  
000026F4                          1926  And_W_DesEA_M4
000026F4  7803                    1927              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000026F6  4EB9 0000484E           1928              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000026FC  4EB9 00004A04           1929              JSR     PrintAnd
00002702  4EB9 00004B5A           1930              JSR     LengthW
00002708  4EB9 00004B88           1931              JSR     PrintSpace
0000270E                          1932  
0000270E  1E05                    1933              MOVE.B  D5,D7
00002710  1A00                    1934              MOVE.B  D0,D5
00002712  4EB9 000049A2           1935              JSR     PrintDataReg
00002718                          1936  
00002718  1A07                    1937              MOVE.B  D7,D5
0000271A  12EE 0025               1938              MOVE.B  37(A6),(A1)+             *,
0000271E  4EB9 000049D2           1939              JSR     PrintPreDeincAddrReg
00002724  4E75                    1940              RTS                     ; return to input to get more input
00002726                          1941  
00002726                          1942  And_W_DesEA_M7
00002726  7803                    1943              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002728  4EB9 0000484E           1944              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000272E                          1945  
0000272E  BABC 00000000           1946              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002734  6700 0012               1947              BEQ     And_W_DesEA_xxxW
00002738                          1948  
00002738  BABC 00000001           1949              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
0000273E  6700 0032               1950              BEQ     And_W_DesEA_xxxL
00002742                          1951  
00002742  4EF9 00004846           1952              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002748                          1953  
00002748                          1954  And_W_DesEA_xxxW
00002748  4EB9 00004A04           1955              JSR     PrintAnd
0000274E  4EB9 00004B5A           1956              JSR     LengthW
00002754  4EB9 00004B88           1957              JSR     PrintSpace
0000275A                          1958  
0000275A  1E05                    1959              MOVE.B  D5,D7
0000275C  1A00                    1960              MOVE.B  D0,D5
0000275E  4EB9 000049A2           1961              JSR     PrintDataReg
00002764                          1962  
00002764  1A07                    1963              MOVE.B  D7,D5
00002766  12EE 0025               1964              MOVE.B  37(A6),(A1)+             *,
0000276A  4EB9 00004948           1965              JSR     PrintByteOrWord
00002770  4E75                    1966              RTS                     ; return to input to get more input
00002772                          1967  
00002772                          1968  And_W_DesEA_xxxL
00002772  4EB9 00004A04           1969              JSR     PrintAnd
00002778  4EB9 00004B5A           1970              JSR     LengthW
0000277E  4EB9 00004B88           1971              JSR     PrintSpace
00002784                          1972  
00002784  1E05                    1973              MOVE.B  D5,D7
00002786  1A00                    1974              MOVE.B  D0,D5
00002788  4EB9 000049A2           1975              JSR     PrintDataReg
0000278E                          1976  
0000278E  1A07                    1977              MOVE.B  D7,D5
00002790  12EE 0025               1978              MOVE.B  37(A6),(A1)+             *,
00002794  4EB9 0000495E           1979              JSR     PrintLong
0000279A  4E75                    1980              RTS                     ; return to input to get more input
0000279C                          1981  
0000279C  7803                    1982  And_L_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000279E  4EB9 0000484E           1983              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000027A4                          1984  
000027A4  BABC 00000002           1985              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000027AA  6700 0026               1986              BEQ     And_L_DesEA_M2
000027AE                          1987  
000027AE  BABC 00000003           1988              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000027B4  6700 004E               1989              BEQ     And_L_DesEA_M3
000027B8                          1990  
000027B8  BABC 00000004           1991              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000027BE  6700 0076               1992              BEQ     And_L_DesEA_M4
000027C2                          1993  
000027C2  BABC 00000007           1994              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000027C8  6700 009E               1995              BEQ     And_L_DesEA_M7
000027CC                          1996  
000027CC  4EF9 00004846           1997              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000027D2                          1998  
000027D2                          1999  And_L_DesEA_M2
000027D2  7803                    2000              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000027D4  4EB9 0000484E           2001              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000027DA  4EB9 00004A04           2002              JSR     PrintAnd
000027E0  4EB9 00004B64           2003              JSR     LengthL
000027E6  4EB9 00004B88           2004              JSR     PrintSpace
000027EC                          2005  
000027EC  1E05                    2006              MOVE.B  D5,D7
000027EE  1A00                    2007              MOVE.B  D0,D5
000027F0  4EB9 000049A2           2008              JSR     PrintDataReg
000027F6                          2009  
000027F6  1A07                    2010              MOVE.B  D7,D5
000027F8  12EE 0025               2011              MOVE.B  37(A6),(A1)+             *,
000027FC  4EB9 000049BA           2012              JSR     PrintIndirAddrReg
00002802  4E75                    2013              RTS                     ; return to input to get more input
00002804                          2014  
00002804                          2015  And_L_DesEA_M3
00002804  7803                    2016              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002806  4EB9 0000484E           2017              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000280C  4EB9 00004A04           2018              JSR     PrintAnd
00002812  4EB9 00004B64           2019              JSR     LengthL
00002818  4EB9 00004B88           2020              JSR     PrintSpace
0000281E                          2021  
0000281E  1E05                    2022              MOVE.B  D5,D7
00002820  1A00                    2023              MOVE.B  D0,D5
00002822  4EB9 000049A2           2024              JSR     PrintDataReg
00002828                          2025  
00002828  1A07                    2026              MOVE.B  D7,D5
0000282A  12EE 0025               2027              MOVE.B  37(A6),(A1)+             *,
0000282E  4EB9 000049C8           2028              JSR     PrintPostIncAddrReg
00002834  4E75                    2029              RTS                     ; return to input to get more input
00002836                          2030  
00002836                          2031  And_L_DesEA_M4
00002836  7803                    2032              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002838  4EB9 0000484E           2033              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000283E  4EB9 00004A04           2034              JSR     PrintAnd
00002844  4EB9 00004B64           2035              JSR     LengthL
0000284A  4EB9 00004B88           2036              JSR     PrintSpace
00002850                          2037  
00002850  1E05                    2038              MOVE.B  D5,D7
00002852  1A00                    2039              MOVE.B  D0,D5
00002854  4EB9 000049A2           2040              JSR     PrintDataReg
0000285A                          2041  
0000285A  1A07                    2042              MOVE.B  D7,D5
0000285C  12EE 0025               2043              MOVE.B  37(A6),(A1)+             *,
00002860  4EB9 000049D2           2044              JSR     PrintPreDeincAddrReg
00002866  4E75                    2045              RTS                     ; return to input to get more input
00002868                          2046  
00002868                          2047  And_L_DesEA_M7
00002868  7803                    2048              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000286A  4EB9 0000484E           2049              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002870                          2050  
00002870  BABC 00000000           2051              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002876  6700 0012               2052              BEQ     And_L_DesEA_xxxW
0000287A                          2053  
0000287A  BABC 00000001           2054              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002880  6700 0032               2055              BEQ     And_L_DesEA_xxxL
00002884                          2056  
00002884  4EF9 00004846           2057              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000288A                          2058  
0000288A                          2059  And_L_DesEA_xxxW
0000288A  4EB9 00004A04           2060              JSR     PrintAnd
00002890  4EB9 00004B64           2061              JSR     LengthL
00002896  4EB9 00004B88           2062              JSR     PrintSpace
0000289C                          2063  
0000289C  1E05                    2064              MOVE.B  D5,D7
0000289E  1A00                    2065              MOVE.B  D0,D5
000028A0  4EB9 000049A2           2066              JSR     PrintDataReg
000028A6                          2067  
000028A6  1A07                    2068              MOVE.B  D7,D5
000028A8  12EE 0025               2069              MOVE.B  37(A6),(A1)+             *,
000028AC  4EB9 00004948           2070              JSR     PrintByteOrWord
000028B2  4E75                    2071              RTS                     ; return to input to get more input
000028B4                          2072  
000028B4                          2073  And_L_DesEA_xxxL
000028B4  4EB9 00004A04           2074              JSR     PrintAnd
000028BA  4EB9 00004B64           2075              JSR     LengthL
000028C0  4EB9 00004B88           2076              JSR     PrintSpace
000028C6                          2077  
000028C6  1E05                    2078              MOVE.B  D5,D7
000028C8  1A00                    2079              MOVE.B  D0,D5
000028CA  4EB9 000049A2           2080              JSR     PrintDataReg
000028D0                          2081  
000028D0  1A07                    2082              MOVE.B  D7,D5
000028D2  12EE 0025               2083              MOVE.B  37(A6),(A1)+             *,
000028D6  4EB9 0000495E           2084              JSR     PrintLong
000028DC  4E75                    2085              RTS                     ; return to input to get more input
000028DE                          2086  
000028DE  7803                    2087  MULS_W      MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000028E0  4EB9 0000484E           2088              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000028E6                          2089  
000028E6  BABC 00000000           2090              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000028EC  6700 0030               2091              BEQ     MULS_W_M0
000028F0                          2092  
000028F0  BABC 00000002           2093              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000028F6  6700 0054               2094              BEQ     MULS_W_M2
000028FA                          2095  
000028FA  BABC 00000003           2096              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002900  6700 0078               2097              BEQ     MULS_W_M3
00002904                          2098  
00002904  BABC 00000004           2099              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000290A  6700 009C               2100              BEQ     MULS_W_M4
0000290E                          2101  
0000290E  BABC 00000007           2102              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002914  6700 00C0               2103              BEQ     MULS_W_M7
00002918                          2104  
00002918  4EF9 00004846           2105              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000291E                          2106  
0000291E  7803                    2107  MULS_W_M0   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002920  4EB9 0000484E           2108              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002926  4EB9 00004AE0           2109              JSR     PrintMuls
0000292C  4EB9 00004B5A           2110              JSR     LengthW
00002932  4EB9 00004B88           2111              JSR     PrintSpace
00002938  4EB9 000049A2           2112              JSR     PrintDataReg
0000293E                          2113  
0000293E  1A00                    2114              MOVE.B  D0,D5
00002940  12EE 0025               2115              MOVE.B  37(A6),(A1)+             *,
00002944  4EB9 000049A2           2116              JSR     PrintDataReg
0000294A  4E75                    2117              RTS                     ; return to input to get more input
0000294C                          2118  
0000294C  7803                    2119  MULS_W_M2   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000294E  4EB9 0000484E           2120              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002954  4EB9 00004AE0           2121              JSR     PrintMuls
0000295A  4EB9 00004B5A           2122              JSR     LengthW
00002960  4EB9 00004B88           2123              JSR     PrintSpace
00002966  4EB9 000049BA           2124              JSR     PrintIndirAddrReg
0000296C                          2125  
0000296C  1A00                    2126              MOVE.B  D0,D5
0000296E  12EE 0025               2127              MOVE.B  37(A6),(A1)+             *,
00002972  4EB9 000049A2           2128              JSR     PrintDataReg
00002978  4E75                    2129              RTS                     ; return to input to get more input
0000297A                          2130  
0000297A  7803                    2131  MULS_W_M3   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000297C  4EB9 0000484E           2132              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002982  4EB9 00004AE0           2133              JSR     PrintMuls
00002988  4EB9 00004B5A           2134              JSR     LengthW
0000298E  4EB9 00004B88           2135              JSR     PrintSpace
00002994  4EB9 000049C8           2136              JSR     PrintPostIncAddrReg
0000299A                          2137  
0000299A  1A00                    2138              MOVE.B  D0,D5
0000299C  12EE 0025               2139              MOVE.B  37(A6),(A1)+             *,
000029A0  4EB9 000049A2           2140              JSR     PrintDataReg
000029A6  4E75                    2141              RTS                     ; return to input to get more input
000029A8                          2142  
000029A8  7803                    2143  MULS_W_M4   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000029AA  4EB9 0000484E           2144              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000029B0  4EB9 00004AE0           2145              JSR     PrintMuls
000029B6  4EB9 00004B5A           2146              JSR     LengthW
000029BC  4EB9 00004B88           2147              JSR     PrintSpace
000029C2  4EB9 000049D2           2148              JSR     PrintPreDeincAddrReg
000029C8                          2149  
000029C8  1A00                    2150              MOVE.B  D0,D5
000029CA  12EE 0025               2151              MOVE.B  37(A6),(A1)+             *,
000029CE  4EB9 000049A2           2152              JSR     PrintDataReg
000029D4  4E75                    2153              RTS                     ; return to input to get more input
000029D6                          2154  
000029D6  7803                    2155  MULS_W_M7   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000029D8  4EB9 0000484E           2156              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000029DE                          2157  
000029DE  BABC 00000000           2158              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000029E4  6700 001C               2159              BEQ     MULS_W_xxxW
000029E8                          2160  
000029E8  BABC 00000001           2161              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000029EE  6700 0038               2162              BEQ     MULS_W_xxxL
000029F2                          2163  
000029F2  BABC 00000004           2164              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
000029F8  6700 0054               2165              BEQ     MULS_W_Data
000029FC                          2166  
000029FC  4EF9 00004846           2167              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002A02                          2168  
00002A02                          2169  MULS_W_xxxW
00002A02  4EB9 00004AE0           2170              JSR     PrintMuls
00002A08  4EB9 00004B5A           2171              JSR     LengthW
00002A0E  4EB9 00004B88           2172              JSR     PrintSpace
00002A14  4EB9 00004948           2173              JSR     PrintByteOrWord
00002A1A                          2174  
00002A1A  1A00                    2175              MOVE.B  D0,D5
00002A1C  12EE 0025               2176              MOVE.B  37(A6),(A1)+             *,
00002A20  4EB9 000049A2           2177              JSR     PrintDataReg
00002A26  4E75                    2178              RTS                     ; return to input to get more input
00002A28                          2179  
00002A28                          2180  MULS_W_xxxL
00002A28  4EB9 00004AE0           2181              JSR     PrintMuls
00002A2E  4EB9 00004B5A           2182              JSR     LengthW
00002A34  4EB9 00004B88           2183              JSR     PrintSpace
00002A3A  4EB9 0000495E           2184              JSR     PrintLong
00002A40                          2185  
00002A40  1A00                    2186              MOVE.B  D0,D5
00002A42  12EE 0025               2187              MOVE.B  37(A6),(A1)+             *,
00002A46  4EB9 000049A2           2188              JSR     PrintDataReg
00002A4C  4E75                    2189              RTS                     ; return to input to get more input
00002A4E                          2190  
00002A4E                          2191  MULS_W_Data
00002A4E  4EB9 00004AE0           2192              JSR     PrintMuls
00002A54  4EB9 00004B5A           2193              JSR     LengthW
00002A5A  4EB9 00004B88           2194              JSR     PrintSpace
00002A60  4EB9 0000493C           2195              JSR     PrintImmediateData
00002A66                          2196  
00002A66  1A00                    2197              MOVE.B  D0,D5
00002A68  12EE 0025               2198              MOVE.B  37(A6),(A1)+             *,
00002A6C  4EB9 000049A2           2199              JSR     PrintDataReg
00002A72  4E75                    2200              RTS                     ; return to input to get more input
00002A74                          2201  
00002A74                          2202  *************************************************                SUB_Opcode                 *************************************************
00002A74                          2203  ; first four bit is (1001 #### #### ####)
00002A74  7803                    2204  SUB_Opcode  MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00002A76  4EB9 0000484E           2205              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00002A7C                          2206  
00002A7C  2005                    2207              MOVE.L  D5,D0               ; D0 will hold the register
00002A7E                          2208          ; D0 will hold the register (position 11-9)
00002A7E                          2209  
00002A7E  7803                    2210              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00002A80  4EB9 0000484E           2211              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the opmode
00002A86                          2212  
00002A86  BABC 00000000           2213              CMP.L   #0,D5               ; if opmode is 0, it is a byte with location specified is a source  (Dn - <ea> -> <ea>)
00002A8C  6700 003A               2214              BEQ     SUB_B_SrcEA
00002A90                          2215  
00002A90  BABC 00000001           2216              CMP.L   #1,D5               ; if opmode is 1, it is a word with location specified is a source  (Dn - <ea> -> <ea>)
00002A96  6700 01FE               2217              BEQ     SUB_W_SrcEA
00002A9A                          2218  
00002A9A  BABC 00000002           2219              CMP.L   #2,D5               ; if opmode is 2, it is a long with location specified is a source  (Dn - <ea> -> <ea>)
00002AA0  6700 03C2               2220              BEQ     SUB_L_SrcEA
00002AA4                          2221  
00002AA4  BABC 00000004           2222              CMP.L   #4,D5               ; if opmode is 4, it is a byte with location specified is a Destination (<ea> - Dn -> <ea>)
00002AAA  6700 0586               2223              BEQ     SUB_B_DesEA
00002AAE                          2224  
00002AAE  BABC 00000005           2225              CMP.L   #5,D5               ; if opmode is 5, it is a word with location specified is a Destination (<ea> - Dn -> <ea>)
00002AB4  6700 06C8               2226              BEQ     SUB_W_DesEA
00002AB8                          2227  
00002AB8  BABC 00000006           2228              CMP.L   #6,D5               ; if opmode is 6, it is a long with location specified is a Destination (<ea> - Dn -> <ea>)
00002ABE  6700 080A               2229              BEQ     SUB_L_DesEA
00002AC2                          2230  
00002AC2  4EF9 00004846           2231              JMP     InvalidOpcode       ; if it is not one of the opmode the opcode is invalid
00002AC8                          2232  
00002AC8  7803                    2233  SUB_B_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002ACA  4EB9 0000484E           2234              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002AD0                          2235  
00002AD0  BABC 00000000           2236              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002AD6  6700 003A               2237              BEQ     SUB_B_SrcEA_M0
00002ADA                          2238  
00002ADA  BABC 00000001           2239              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00002AE0  6700 005E               2240              BEQ     SUB_B_SrcEA_M1
00002AE4                          2241  
00002AE4  BABC 00000002           2242              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002AEA  6700 0082               2243              BEQ     SUB_B_SrcEA_M2
00002AEE                          2244  
00002AEE  BABC 00000003           2245              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002AF4  6700 00A6               2246              BEQ     SUB_B_SrcEA_M3
00002AF8                          2247  
00002AF8  BABC 00000004           2248              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002AFE  6700 00CA               2249              BEQ     SUB_B_SrcEA_M4
00002B02                          2250  
00002B02  BABC 00000007           2251              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002B08  6700 00EE               2252              BEQ     SUB_B_SrcEA_M7
00002B0C                          2253  
00002B0C  4EF9 00004846           2254              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002B12                          2255  
00002B12                          2256  SUB_B_SrcEA_M0
00002B12  7803                    2257              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B14  4EB9 0000484E           2258              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002B1A  4EB9 00004B42           2259              JSR     PrintSub
00002B20  4EB9 00004B50           2260              JSR     LengthB
00002B26  4EB9 00004B88           2261              JSR     PrintSpace
00002B2C  4EB9 000049A2           2262              JSR     PrintDataReg
00002B32                          2263  
00002B32  1A00                    2264              MOVE.B  D0,D5
00002B34  12EE 0025               2265              MOVE.B  37(A6),(A1)+             *,
00002B38  4EB9 000049A2           2266              JSR     PrintDataReg
00002B3E  4E75                    2267              RTS                     ; return to input to get more input
00002B40                          2268  
00002B40                          2269  SUB_B_SrcEA_M1
00002B40  7803                    2270              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B42  4EB9 0000484E           2271              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002B48  4EB9 00004B42           2272              JSR     PrintSub
00002B4E  4EB9 00004B50           2273              JSR     LengthB
00002B54  4EB9 00004B88           2274              JSR     PrintSpace
00002B5A  4EB9 000049AE           2275              JSR     PrintAddrReg
00002B60                          2276  
00002B60  1A00                    2277              MOVE.B  D0,D5
00002B62  12EE 0025               2278              MOVE.B  37(A6),(A1)+             *,
00002B66  4EB9 000049A2           2279              JSR     PrintDataReg
00002B6C  4E75                    2280              RTS                     ; return to input to get more input
00002B6E                          2281  
00002B6E                          2282  SUB_B_SrcEA_M2
00002B6E  7803                    2283              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B70  4EB9 0000484E           2284              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002B76  4EB9 00004B42           2285              JSR     PrintSub
00002B7C  4EB9 00004B50           2286              JSR     LengthB
00002B82  4EB9 00004B88           2287              JSR     PrintSpace
00002B88  4EB9 000049BA           2288              JSR     PrintIndirAddrReg
00002B8E                          2289  
00002B8E  1A00                    2290              MOVE.B  D0,D5
00002B90  12EE 0025               2291              MOVE.B  37(A6),(A1)+             *,
00002B94  4EB9 000049A2           2292              JSR     PrintDataReg
00002B9A  4E75                    2293              RTS                     ; return to input to get more input
00002B9C                          2294  
00002B9C                          2295  SUB_B_SrcEA_M3
00002B9C  7803                    2296              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B9E  4EB9 0000484E           2297              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002BA4  4EB9 00004B42           2298              JSR     PrintSub
00002BAA  4EB9 00004B50           2299              JSR     LengthB
00002BB0  4EB9 00004B88           2300              JSR     PrintSpace
00002BB6  4EB9 000049C8           2301              JSR     PrintPostIncAddrReg
00002BBC                          2302  
00002BBC  1A00                    2303              MOVE.B  D0,D5
00002BBE  12EE 0025               2304              MOVE.B  37(A6),(A1)+             *,
00002BC2  4EB9 000049A2           2305              JSR     PrintDataReg
00002BC8  4E75                    2306              RTS                     ; return to input to get more input
00002BCA                          2307  
00002BCA                          2308  SUB_B_SrcEA_M4
00002BCA  7803                    2309              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002BCC  4EB9 0000484E           2310              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002BD2  4EB9 00004B42           2311              JSR     PrintSub
00002BD8  4EB9 00004B50           2312              JSR     LengthB
00002BDE  4EB9 00004B88           2313              JSR     PrintSpace
00002BE4  4EB9 000049D2           2314              JSR     PrintPreDeincAddrReg
00002BEA                          2315  
00002BEA  1A00                    2316              MOVE.B  D0,D5
00002BEC  12EE 0025               2317              MOVE.B  37(A6),(A1)+             *,
00002BF0  4EB9 000049A2           2318              JSR     PrintDataReg
00002BF6  4E75                    2319              RTS                     ; return to input to get more input
00002BF8                          2320  
00002BF8                          2321  SUB_B_SrcEA_M7
00002BF8  7803                    2322              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002BFA  4EB9 0000484E           2323              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002C00                          2324  
00002C00  BABC 00000000           2325              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002C06  6700 001C               2326              BEQ     SUB_B_SrcEA_xxxW
00002C0A                          2327  
00002C0A  BABC 00000001           2328              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002C10  6700 0038               2329              BEQ     SUB_B_SrcEA_xxxL
00002C14                          2330  
00002C14  BABC 00000004           2331              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002C1A  6700 0054               2332              BEQ     SUB_B_SrcEA_Data
00002C1E                          2333  
00002C1E  4EF9 00004846           2334              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002C24                          2335  
00002C24                          2336  SUB_B_SrcEA_xxxW
00002C24  4EB9 00004B42           2337              JSR     PrintSub
00002C2A  4EB9 00004B50           2338              JSR     LengthB
00002C30  4EB9 00004B88           2339              JSR     PrintSpace
00002C36  4EB9 00004948           2340              JSR     PrintByteOrWord
00002C3C                          2341  
00002C3C  1A00                    2342              MOVE.B  D0,D5
00002C3E  12EE 0025               2343              MOVE.B  37(A6),(A1)+             *,
00002C42  4EB9 000049A2           2344              JSR     PrintDataReg
00002C48  4E75                    2345              RTS                     ; return to input to get more input
00002C4A                          2346  
00002C4A                          2347  SUB_B_SrcEA_xxxL
00002C4A  4EB9 00004B42           2348              JSR     PrintSub
00002C50  4EB9 00004B50           2349              JSR     LengthB
00002C56  4EB9 00004B88           2350              JSR     PrintSpace
00002C5C  4EB9 0000495E           2351              JSR     PrintLong
00002C62                          2352  
00002C62  1A00                    2353              MOVE.B  D0,D5
00002C64  12EE 0025               2354              MOVE.B  37(A6),(A1)+             *,
00002C68  4EB9 000049A2           2355              JSR     PrintDataReg
00002C6E  4E75                    2356              RTS                     ; return to input to get more input
00002C70                          2357  
00002C70                          2358  SUB_B_SrcEA_Data
00002C70  4EB9 00004B42           2359              JSR     PrintSub
00002C76  4EB9 00004B50           2360              JSR     LengthB
00002C7C  4EB9 00004B88           2361              JSR     PrintSpace
00002C82  4EB9 0000493C           2362              JSR     PrintImmediateData
00002C88                          2363  
00002C88  1A00                    2364              MOVE.B  D0,D5
00002C8A  12EE 0025               2365              MOVE.B  37(A6),(A1)+             *,
00002C8E  4EB9 000049A2           2366              JSR     PrintDataReg
00002C94  4E75                    2367              RTS                     ; return to input to get more input
00002C96                          2368  
00002C96                          2369  
00002C96  7803                    2370  SUB_W_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002C98  4EB9 0000484E           2371              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002C9E                          2372  
00002C9E  BABC 00000000           2373              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002CA4  6700 003A               2374              BEQ     SUB_W_SrcEA_M0
00002CA8                          2375  
00002CA8  BABC 00000001           2376              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00002CAE  6700 005E               2377              BEQ     SUB_W_SrcEA_M1
00002CB2                          2378  
00002CB2  BABC 00000002           2379              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002CB8  6700 0082               2380              BEQ     SUB_W_SrcEA_M2
00002CBC                          2381  
00002CBC  BABC 00000003           2382              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002CC2  6700 00A6               2383              BEQ     SUB_W_SrcEA_M3
00002CC6                          2384  
00002CC6  BABC 00000004           2385              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002CCC  6700 00CA               2386              BEQ     SUB_W_SrcEA_M4
00002CD0                          2387  
00002CD0  BABC 00000007           2388              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002CD6  6700 00EE               2389              BEQ     SUB_W_SrcEA_M7
00002CDA                          2390  
00002CDA  4EF9 00004846           2391              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002CE0                          2392  
00002CE0                          2393  SUB_W_SrcEA_M0
00002CE0  7803                    2394              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002CE2  4EB9 0000484E           2395              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002CE8  4EB9 00004B42           2396              JSR     PrintSub
00002CEE  4EB9 00004B5A           2397              JSR     LengthW
00002CF4  4EB9 00004B88           2398              JSR     PrintSpace
00002CFA  4EB9 000049A2           2399              JSR     PrintDataReg
00002D00                          2400  
00002D00  1A00                    2401              MOVE.B  D0,D5
00002D02  12EE 0025               2402              MOVE.B  37(A6),(A1)+             *,
00002D06  4EB9 000049A2           2403              JSR     PrintDataReg
00002D0C  4E75                    2404              RTS                     ; return to input to get more input
00002D0E                          2405  
00002D0E                          2406  SUB_W_SrcEA_M1
00002D0E  7803                    2407              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D10  4EB9 0000484E           2408              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002D16  4EB9 00004B42           2409              JSR     PrintSub
00002D1C  4EB9 00004B5A           2410              JSR     LengthW
00002D22  4EB9 00004B88           2411              JSR     PrintSpace
00002D28  4EB9 000049AE           2412              JSR     PrintAddrReg
00002D2E                          2413  
00002D2E  1A00                    2414              MOVE.B  D0,D5
00002D30  12EE 0025               2415              MOVE.B  37(A6),(A1)+             *,
00002D34  4EB9 000049A2           2416              JSR     PrintDataReg
00002D3A  4E75                    2417              RTS                     ; return to input to get more input
00002D3C                          2418  
00002D3C                          2419  SUB_W_SrcEA_M2
00002D3C  7803                    2420              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D3E  4EB9 0000484E           2421              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002D44  4EB9 00004B42           2422              JSR     PrintSub
00002D4A  4EB9 00004B5A           2423              JSR     LengthW
00002D50  4EB9 00004B88           2424              JSR     PrintSpace
00002D56  4EB9 000049BA           2425              JSR     PrintIndirAddrReg
00002D5C                          2426  
00002D5C  1A00                    2427              MOVE.B  D0,D5
00002D5E  12EE 0025               2428              MOVE.B  37(A6),(A1)+             *,
00002D62  4EB9 000049A2           2429              JSR     PrintDataReg
00002D68  4E75                    2430              RTS                     ; return to input to get more input
00002D6A                          2431  
00002D6A                          2432  SUB_W_SrcEA_M3
00002D6A  7803                    2433              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D6C  4EB9 0000484E           2434              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002D72  4EB9 00004B42           2435              JSR     PrintSub
00002D78  4EB9 00004B5A           2436              JSR     LengthW
00002D7E  4EB9 00004B88           2437              JSR     PrintSpace
00002D84  4EB9 000049C8           2438              JSR     PrintPostIncAddrReg
00002D8A                          2439  
00002D8A  1A00                    2440              MOVE.B  D0,D5
00002D8C  12EE 0025               2441              MOVE.B  37(A6),(A1)+             *,
00002D90  4EB9 000049A2           2442              JSR     PrintDataReg
00002D96  4E75                    2443              RTS                     ; return to input to get more input
00002D98                          2444  
00002D98                          2445  SUB_W_SrcEA_M4
00002D98  7803                    2446              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D9A  4EB9 0000484E           2447              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002DA0  4EB9 00004B42           2448              JSR     PrintSub
00002DA6  4EB9 00004B5A           2449              JSR     LengthW
00002DAC  4EB9 00004B88           2450              JSR     PrintSpace
00002DB2  4EB9 000049D2           2451              JSR     PrintPreDeincAddrReg
00002DB8                          2452  
00002DB8  1A00                    2453              MOVE.B  D0,D5
00002DBA  12EE 0025               2454              MOVE.B  37(A6),(A1)+             *,
00002DBE  4EB9 000049A2           2455              JSR     PrintDataReg
00002DC4  4E75                    2456              RTS                     ; return to input to get more input
00002DC6                          2457  
00002DC6                          2458  SUB_W_SrcEA_M7
00002DC6  7803                    2459              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002DC8  4EB9 0000484E           2460              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002DCE                          2461  
00002DCE  BABC 00000000           2462              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002DD4  6700 001C               2463              BEQ     SUB_W_SrcEA_xxxW
00002DD8                          2464  
00002DD8  BABC 00000001           2465              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002DDE  6700 0038               2466              BEQ     SUB_W_SrcEA_xxxL
00002DE2                          2467  
00002DE2  BABC 00000004           2468              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002DE8  6700 0054               2469              BEQ     SUB_W_SrcEA_Data
00002DEC                          2470  
00002DEC  4EF9 00004846           2471              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002DF2                          2472  
00002DF2                          2473  SUB_W_SrcEA_xxxW
00002DF2  4EB9 00004B42           2474              JSR     PrintSub
00002DF8  4EB9 00004B5A           2475              JSR     LengthW
00002DFE  4EB9 00004B88           2476              JSR     PrintSpace
00002E04  4EB9 00004948           2477              JSR     PrintByteOrWord
00002E0A                          2478  
00002E0A  1A00                    2479              MOVE.B  D0,D5
00002E0C  12EE 0025               2480              MOVE.B  37(A6),(A1)+             *,
00002E10  4EB9 000049A2           2481              JSR     PrintDataReg
00002E16  4E75                    2482              RTS                     ; return to input to get more input
00002E18                          2483  
00002E18                          2484  SUB_W_SrcEA_xxxL
00002E18  4EB9 00004B42           2485              JSR     PrintSub
00002E1E  4EB9 00004B5A           2486              JSR     LengthW
00002E24  4EB9 00004B88           2487              JSR     PrintSpace
00002E2A  4EB9 0000495E           2488              JSR     PrintLong
00002E30                          2489  
00002E30  1A00                    2490              MOVE.B  D0,D5
00002E32  12EE 0025               2491              MOVE.B  37(A6),(A1)+             *,
00002E36  4EB9 000049A2           2492              JSR     PrintDataReg
00002E3C  4E75                    2493              RTS                     ; return to input to get more input
00002E3E                          2494  
00002E3E                          2495  SUB_W_SrcEA_Data
00002E3E  4EB9 00004B42           2496              JSR     PrintSub
00002E44  4EB9 00004B5A           2497              JSR     LengthW
00002E4A  4EB9 00004B88           2498              JSR     PrintSpace
00002E50  4EB9 0000493C           2499              JSR     PrintImmediateData
00002E56                          2500  
00002E56  1A00                    2501              MOVE.B  D0,D5
00002E58  12EE 0025               2502              MOVE.B  37(A6),(A1)+             *,
00002E5C  4EB9 000049A2           2503              JSR     PrintDataReg
00002E62  4E75                    2504              RTS                     ; return to input to get more input
00002E64                          2505  
00002E64  7803                    2506  SUB_L_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002E66  4EB9 0000484E           2507              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002E6C                          2508  
00002E6C  BABC 00000000           2509              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002E72  6700 003A               2510              BEQ     SUB_L_SrcEA_M0
00002E76                          2511  
00002E76  BABC 00000001           2512              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00002E7C  6700 005E               2513              BEQ     SUB_L_SrcEA_M1
00002E80                          2514  
00002E80  BABC 00000002           2515              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002E86  6700 0082               2516              BEQ     SUB_L_SrcEA_M2
00002E8A                          2517  
00002E8A  BABC 00000003           2518              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002E90  6700 00A6               2519              BEQ     SUB_L_SrcEA_M3
00002E94                          2520  
00002E94  BABC 00000004           2521              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002E9A  6700 00CA               2522              BEQ     SUB_L_SrcEA_M4
00002E9E                          2523  
00002E9E  BABC 00000007           2524              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002EA4  6700 00EE               2525              BEQ     SUB_L_SrcEA_M7
00002EA8                          2526  
00002EA8  4EF9 00004846           2527              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002EAE                          2528  
00002EAE                          2529  SUB_L_SrcEA_M0
00002EAE  7803                    2530              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002EB0  4EB9 0000484E           2531              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002EB6  4EB9 00004B42           2532              JSR     PrintSub
00002EBC  4EB9 00004B64           2533              JSR     LengthL
00002EC2  4EB9 00004B88           2534              JSR     PrintSpace
00002EC8  4EB9 000049A2           2535              JSR     PrintDataReg
00002ECE                          2536  
00002ECE  1A00                    2537              MOVE.B  D0,D5
00002ED0  12EE 0025               2538              MOVE.B  37(A6),(A1)+             *,
00002ED4  4EB9 000049A2           2539              JSR     PrintDataReg
00002EDA  4E75                    2540              RTS                     ; return to input to get more input
00002EDC                          2541  
00002EDC                          2542  SUB_L_SrcEA_M1
00002EDC  7803                    2543              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002EDE  4EB9 0000484E           2544              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002EE4  4EB9 00004B42           2545              JSR     PrintSub
00002EEA  4EB9 00004B64           2546              JSR     LengthL
00002EF0  4EB9 00004B88           2547              JSR     PrintSpace
00002EF6  4EB9 000049AE           2548              JSR     PrintAddrReg
00002EFC                          2549  
00002EFC  1A00                    2550              MOVE.B  D0,D5
00002EFE  12EE 0025               2551              MOVE.B  37(A6),(A1)+             *,
00002F02  4EB9 000049A2           2552              JSR     PrintDataReg
00002F08  4E75                    2553              RTS                     ; return to input to get more input
00002F0A                          2554  
00002F0A                          2555  SUB_L_SrcEA_M2
00002F0A  7803                    2556              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F0C  4EB9 0000484E           2557              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F12  4EB9 00004B42           2558              JSR     PrintSub
00002F18  4EB9 00004B64           2559              JSR     LengthL
00002F1E  4EB9 00004B88           2560              JSR     PrintSpace
00002F24  4EB9 000049BA           2561              JSR     PrintIndirAddrReg
00002F2A                          2562  
00002F2A  1A00                    2563              MOVE.B  D0,D5
00002F2C  12EE 0025               2564              MOVE.B  37(A6),(A1)+             *,
00002F30  4EB9 000049A2           2565              JSR     PrintDataReg
00002F36  4E75                    2566              RTS                     ; return to input to get more input
00002F38                          2567  
00002F38                          2568  SUB_L_SrcEA_M3
00002F38  7803                    2569              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F3A  4EB9 0000484E           2570              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F40  4EB9 00004B42           2571              JSR     PrintSub
00002F46  4EB9 00004B64           2572              JSR     LengthL
00002F4C  4EB9 00004B88           2573              JSR     PrintSpace
00002F52  4EB9 000049C8           2574              JSR     PrintPostIncAddrReg
00002F58                          2575  
00002F58  1A00                    2576              MOVE.B  D0,D5
00002F5A  12EE 0025               2577              MOVE.B  37(A6),(A1)+             *,
00002F5E  4EB9 000049A2           2578              JSR     PrintDataReg
00002F64  4E75                    2579              RTS                     ; return to input to get more input
00002F66                          2580  
00002F66                          2581  SUB_L_SrcEA_M4
00002F66  7803                    2582              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F68  4EB9 0000484E           2583              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F6E  4EB9 00004B42           2584              JSR     PrintSub
00002F74  4EB9 00004B64           2585              JSR     LengthL
00002F7A  4EB9 00004B88           2586              JSR     PrintSpace
00002F80  4EB9 000049D2           2587              JSR     PrintPreDeincAddrReg
00002F86                          2588  
00002F86  1A00                    2589              MOVE.B  D0,D5
00002F88  12EE 0025               2590              MOVE.B  37(A6),(A1)+             *,
00002F8C  4EB9 000049A2           2591              JSR     PrintDataReg
00002F92  4E75                    2592              RTS                     ; return to input to get more input
00002F94                          2593  
00002F94                          2594  SUB_L_SrcEA_M7
00002F94  7803                    2595              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F96  4EB9 0000484E           2596              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F9C                          2597  
00002F9C  BABC 00000000           2598              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002FA2  6700 001C               2599              BEQ     SUB_L_SrcEA_xxxW
00002FA6                          2600  
00002FA6  BABC 00000001           2601              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002FAC  6700 0038               2602              BEQ     SUB_L_SrcEA_xxxL
00002FB0                          2603  
00002FB0  BABC 00000004           2604              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002FB6  6700 0054               2605              BEQ     SUB_L_SrcEA_Data
00002FBA                          2606  
00002FBA  4EF9 00004846           2607              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002FC0                          2608  
00002FC0                          2609  SUB_L_SrcEA_xxxW
00002FC0  4EB9 00004B42           2610              JSR     PrintSub
00002FC6  4EB9 00004B64           2611              JSR     LengthL
00002FCC  4EB9 00004B88           2612              JSR     PrintSpace
00002FD2  4EB9 00004948           2613              JSR     PrintByteOrWord
00002FD8                          2614  
00002FD8  1A00                    2615              MOVE.B  D0,D5
00002FDA  12EE 0025               2616              MOVE.B  37(A6),(A1)+             *,
00002FDE  4EB9 000049A2           2617              JSR     PrintDataReg
00002FE4  4E75                    2618              RTS                     ; return to input to get more input
00002FE6                          2619  
00002FE6                          2620  SUB_L_SrcEA_xxxL
00002FE6  4EB9 00004B42           2621              JSR     PrintSub
00002FEC  4EB9 00004B64           2622              JSR     LengthL
00002FF2  4EB9 00004B88           2623              JSR     PrintSpace
00002FF8  4EB9 0000495E           2624              JSR     PrintLong
00002FFE                          2625  
00002FFE  1A00                    2626              MOVE.B  D0,D5
00003000  12EE 0025               2627              MOVE.B  37(A6),(A1)+             *,
00003004  4EB9 000049A2           2628              JSR     PrintDataReg
0000300A  4E75                    2629              RTS                     ; return to input to get more input
0000300C                          2630  
0000300C                          2631  SUB_L_SrcEA_Data
0000300C  4EB9 00004B42           2632              JSR     PrintSub
00003012  4EB9 00004B64           2633              JSR     LengthL
00003018  4EB9 00004B88           2634              JSR     PrintSpace
0000301E  4EB9 0000493C           2635              JSR     PrintImmediateData
00003024                          2636  
00003024  1A00                    2637              MOVE.B  D0,D5
00003026  12EE 0025               2638              MOVE.B  37(A6),(A1)+             *,
0000302A  4EB9 000049A2           2639              JSR     PrintDataReg
00003030  4E75                    2640              RTS                     ; return to input to get more input
00003032                          2641  
00003032  7803                    2642  SUB_B_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00003034  4EB9 0000484E           2643              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
0000303A                          2644  
0000303A  BABC 00000002           2645              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00003040  6700 0026               2646              BEQ     SUB_B_DesEA_M2
00003044                          2647  
00003044  BABC 00000003           2648              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
0000304A  6700 004E               2649              BEQ     SUB_B_DesEA_M3
0000304E                          2650  
0000304E  BABC 00000004           2651              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00003054  6700 0076               2652              BEQ     SUB_B_DesEA_M4
00003058                          2653  
00003058  BABC 00000007           2654              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
0000305E  6700 009E               2655              BEQ     SUB_B_DesEA_M7
00003062                          2656  
00003062  4EF9 00004846           2657              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00003068                          2658  
00003068                          2659  SUB_B_DesEA_M2
00003068  7803                    2660              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000306A  4EB9 0000484E           2661              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003070  4EB9 00004B42           2662              JSR     PrintSub
00003076  4EB9 00004B50           2663              JSR     LengthB
0000307C  4EB9 00004B88           2664              JSR     PrintSpace
00003082                          2665  
00003082  1E05                    2666              MOVE.B  D5,D7
00003084  1A00                    2667              MOVE.B  D0,D5
00003086  4EB9 000049A2           2668              JSR     PrintDataReg
0000308C                          2669  
0000308C  1A07                    2670              MOVE.B  D7,D5
0000308E  12EE 0025               2671              MOVE.B  37(A6),(A1)+             *,
00003092  4EB9 000049BA           2672              JSR     PrintIndirAddrReg
00003098  4E75                    2673              RTS                     ; return to input to get more input
0000309A                          2674  
0000309A                          2675  SUB_B_DesEA_M3
0000309A  7803                    2676              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000309C  4EB9 0000484E           2677              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000030A2  4EB9 00004B42           2678              JSR     PrintSub
000030A8  4EB9 00004B50           2679              JSR     LengthB
000030AE  4EB9 00004B88           2680              JSR     PrintSpace
000030B4                          2681  
000030B4  1E05                    2682              MOVE.B  D5,D7
000030B6  1A00                    2683              MOVE.B  D0,D5
000030B8  4EB9 000049A2           2684              JSR     PrintDataReg
000030BE                          2685  
000030BE  1A07                    2686              MOVE.B  D7,D5
000030C0  12EE 0025               2687              MOVE.B  37(A6),(A1)+             *,
000030C4  4EB9 000049C8           2688              JSR     PrintPostIncAddrReg
000030CA  4E75                    2689              RTS                     ; return to input to get more input
000030CC                          2690  
000030CC                          2691  SUB_B_DesEA_M4
000030CC  7803                    2692              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000030CE  4EB9 0000484E           2693              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000030D4  4EB9 00004B42           2694              JSR     PrintSub
000030DA  4EB9 00004B50           2695              JSR     LengthB
000030E0  4EB9 00004B88           2696              JSR     PrintSpace
000030E6                          2697  
000030E6  1E05                    2698              MOVE.B  D5,D7
000030E8  1A00                    2699              MOVE.B  D0,D5
000030EA  4EB9 000049A2           2700              JSR     PrintDataReg
000030F0                          2701  
000030F0  1A07                    2702              MOVE.B  D7,D5
000030F2  12EE 0025               2703              MOVE.B  37(A6),(A1)+             *,
000030F6  4EB9 000049D2           2704              JSR     PrintPreDeincAddrReg
000030FC  4E75                    2705              RTS                     ; return to input to get more input
000030FE                          2706  
000030FE                          2707  SUB_B_DesEA_M7
000030FE  7803                    2708              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003100  4EB9 0000484E           2709              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003106                          2710  
00003106  BABC 00000000           2711              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
0000310C  6700 FB16               2712              BEQ     SUB_B_SrcEA_xxxW
00003110                          2713  
00003110  BABC 00000001           2714              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00003116  6700 FB32               2715              BEQ     SUB_B_SrcEA_xxxL
0000311A                          2716  
0000311A  BABC 00000004           2717              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00003120  6700 FB4E               2718              BEQ     SUB_B_SrcEA_Data
00003124                          2719  
00003124  4EF9 00004846           2720              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000312A                          2721  
0000312A                          2722  SUB_B_DesEA_xxxW
0000312A  4EB9 00004B42           2723              JSR     PrintSub
00003130  4EB9 00004B50           2724              JSR     LengthB
00003136  4EB9 00004B88           2725              JSR     PrintSpace
0000313C                          2726  
0000313C  1E05                    2727              MOVE.B  D5,D7
0000313E  1A00                    2728              MOVE.B  D0,D5
00003140  4EB9 000049A2           2729              JSR     PrintDataReg
00003146                          2730  
00003146  1A07                    2731              MOVE.B  D7,D5
00003148  12EE 0025               2732              MOVE.B  37(A6),(A1)+             *,
0000314C  4EB9 00004948           2733              JSR     PrintByteOrWord
00003152  4E75                    2734              RTS                     ; return to input to get more input
00003154                          2735  
00003154                          2736  SUB_B_DesEA_xxxL
00003154  4EB9 00004B42           2737              JSR     PrintSub
0000315A  4EB9 00004B50           2738              JSR     LengthB
00003160  4EB9 00004B88           2739              JSR     PrintSpace
00003166                          2740  
00003166  1E05                    2741              MOVE.B  D5,D7
00003168  1A00                    2742              MOVE.B  D0,D5
0000316A  4EB9 000049A2           2743              JSR     PrintDataReg
00003170                          2744  
00003170  1A07                    2745              MOVE.B  D7,D5
00003172  12EE 0025               2746              MOVE.B  37(A6),(A1)+             *,
00003176  4EB9 0000495E           2747              JSR     PrintLong
0000317C  4E75                    2748              RTS                     ; return to input to get more input
0000317E                          2749  
0000317E  7803                    2750  SUB_W_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00003180  4EB9 0000484E           2751              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00003186                          2752  
00003186  BABC 00000002           2753              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
0000318C  6700 0026               2754              BEQ     SUB_W_DesEA_M2
00003190                          2755  
00003190  BABC 00000003           2756              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00003196  6700 004E               2757              BEQ     SUB_W_DesEA_M3
0000319A                          2758  
0000319A  BABC 00000004           2759              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000031A0  6700 0076               2760              BEQ     SUB_W_DesEA_M4
000031A4                          2761  
000031A4  BABC 00000007           2762              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000031AA  6700 009E               2763              BEQ     SUB_W_DesEA_M7
000031AE                          2764  
000031AE  4EF9 00004846           2765              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000031B4                          2766  
000031B4                          2767  SUB_W_DesEA_M2
000031B4  7803                    2768              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000031B6  4EB9 0000484E           2769              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000031BC  4EB9 00004B42           2770              JSR     PrintSub
000031C2  4EB9 00004B5A           2771              JSR     LengthW
000031C8  4EB9 00004B88           2772              JSR     PrintSpace
000031CE                          2773  
000031CE  1E05                    2774              MOVE.B  D5,D7
000031D0  1A00                    2775              MOVE.B  D0,D5
000031D2  4EB9 000049A2           2776              JSR     PrintDataReg
000031D8                          2777  
000031D8  1A07                    2778              MOVE.B  D7,D5
000031DA  12EE 0025               2779              MOVE.B  37(A6),(A1)+             *,
000031DE  4EB9 000049BA           2780              JSR     PrintIndirAddrReg
000031E4  4E75                    2781              RTS                     ; return to input to get more input
000031E6                          2782  
000031E6                          2783  SUB_W_DesEA_M3
000031E6  7803                    2784              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000031E8  4EB9 0000484E           2785              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000031EE  4EB9 00004B42           2786              JSR     PrintSub
000031F4  4EB9 00004B5A           2787              JSR     LengthW
000031FA  4EB9 00004B88           2788              JSR     PrintSpace
00003200                          2789  
00003200  1E05                    2790              MOVE.B  D5,D7
00003202  1A00                    2791              MOVE.B  D0,D5
00003204  4EB9 000049A2           2792              JSR     PrintDataReg
0000320A                          2793  
0000320A  1A07                    2794              MOVE.B  D7,D5
0000320C  12EE 0025               2795              MOVE.B  37(A6),(A1)+             *,
00003210  4EB9 000049C8           2796              JSR     PrintPostIncAddrReg
00003216  4E75                    2797              RTS                     ; return to input to get more input
00003218                          2798  
00003218                          2799  SUB_W_DesEA_M4
00003218  7803                    2800              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000321A  4EB9 0000484E           2801              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003220  4EB9 00004B42           2802              JSR     PrintSub
00003226  4EB9 00004B5A           2803              JSR     LengthW
0000322C  4EB9 00004B88           2804              JSR     PrintSpace
00003232                          2805  
00003232  1E05                    2806              MOVE.B  D5,D7
00003234  1A00                    2807              MOVE.B  D0,D5
00003236  4EB9 000049A2           2808              JSR     PrintDataReg
0000323C                          2809  
0000323C  1A07                    2810              MOVE.B  D7,D5
0000323E  12EE 0025               2811              MOVE.B  37(A6),(A1)+             *,
00003242  4EB9 000049D2           2812              JSR     PrintPreDeincAddrReg
00003248  4E75                    2813              RTS                     ; return to input to get more input
0000324A                          2814  
0000324A                          2815  SUB_W_DesEA_M7
0000324A  7803                    2816              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000324C  4EB9 0000484E           2817              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003252                          2818  
00003252  BABC 00000000           2819              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00003258  6700 FB98               2820              BEQ     SUB_W_SrcEA_xxxW
0000325C                          2821  
0000325C  BABC 00000001           2822              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00003262  6700 FBB4               2823              BEQ     SUB_W_SrcEA_xxxL
00003266                          2824  
00003266  BABC 00000004           2825              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
0000326C  6700 FBD0               2826              BEQ     SUB_W_SrcEA_Data
00003270                          2827  
00003270  4EF9 00004846           2828              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00003276                          2829  
00003276                          2830  SUB_W_DesEA_xxxW
00003276  4EB9 00004B42           2831              JSR     PrintSub
0000327C  4EB9 00004B5A           2832              JSR     LengthW
00003282  4EB9 00004B88           2833              JSR     PrintSpace
00003288                          2834  
00003288  1E05                    2835              MOVE.B  D5,D7
0000328A  1A00                    2836              MOVE.B  D0,D5
0000328C  4EB9 000049A2           2837              JSR     PrintDataReg
00003292                          2838  
00003292  1A07                    2839              MOVE.B  D7,D5
00003294  12EE 0025               2840              MOVE.B  37(A6),(A1)+             *,
00003298  4EB9 00004948           2841              JSR     PrintByteOrWord
0000329E  4E75                    2842              RTS                     ; return to input to get more input
000032A0                          2843  
000032A0                          2844  SUB_W_DesEA_xxxL
000032A0  4EB9 00004B42           2845              JSR     PrintSub
000032A6  4EB9 00004B5A           2846              JSR     LengthW
000032AC  4EB9 00004B88           2847              JSR     PrintSpace
000032B2                          2848  
000032B2  1E05                    2849              MOVE.B  D5,D7
000032B4  1A00                    2850              MOVE.B  D0,D5
000032B6  4EB9 000049A2           2851              JSR     PrintDataReg
000032BC                          2852  
000032BC  1A07                    2853              MOVE.B  D7,D5
000032BE  12EE 0025               2854              MOVE.B  37(A6),(A1)+             *,
000032C2  4EB9 0000495E           2855              JSR     PrintLong
000032C8  4E75                    2856              RTS                     ; return to input to get more input
000032CA                          2857  
000032CA  7803                    2858  SUB_L_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000032CC  4EB9 0000484E           2859              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000032D2                          2860  
000032D2  BABC 00000002           2861              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000032D8  6700 0026               2862              BEQ     SUB_L_DesEA_M2
000032DC                          2863  
000032DC  BABC 00000003           2864              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000032E2  6700 004E               2865              BEQ     SUB_L_DesEA_M3
000032E6                          2866  
000032E6  BABC 00000004           2867              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000032EC  6700 0076               2868              BEQ     SUB_L_DesEA_M4
000032F0                          2869  
000032F0  BABC 00000007           2870              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000032F6  6700 009E               2871              BEQ     SUB_L_DesEA_M7
000032FA                          2872  
000032FA  4EF9 00004846           2873              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00003300                          2874  
00003300                          2875  SUB_L_DesEA_M2
00003300  7803                    2876              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003302  4EB9 0000484E           2877              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003308  4EB9 00004B42           2878              JSR     PrintSub
0000330E  4EB9 00004B64           2879              JSR     LengthL
00003314  4EB9 00004B88           2880              JSR     PrintSpace
0000331A                          2881  
0000331A  1E05                    2882              MOVE.B  D5,D7
0000331C  1A00                    2883              MOVE.B  D0,D5
0000331E  4EB9 000049A2           2884              JSR     PrintDataReg
00003324                          2885  
00003324  1A07                    2886              MOVE.B  D7,D5
00003326  12EE 0025               2887              MOVE.B  37(A6),(A1)+             *,
0000332A  4EB9 000049BA           2888              JSR     PrintIndirAddrReg
00003330  4E75                    2889              RTS                     ; return to input to get more input
00003332                          2890  
00003332                          2891  SUB_L_DesEA_M3
00003332  7803                    2892              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003334  4EB9 0000484E           2893              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000333A  4EB9 00004B42           2894              JSR     PrintSub
00003340  4EB9 00004B64           2895              JSR     LengthL
00003346  4EB9 00004B88           2896              JSR     PrintSpace
0000334C                          2897  
0000334C  1E05                    2898              MOVE.B  D5,D7
0000334E  1A00                    2899              MOVE.B  D0,D5
00003350  4EB9 000049A2           2900              JSR     PrintDataReg
00003356                          2901  
00003356  1A07                    2902              MOVE.B  D7,D5
00003358  12EE 0025               2903              MOVE.B  37(A6),(A1)+             *,
0000335C  4EB9 000049C8           2904              JSR     PrintPostIncAddrReg
00003362  4E75                    2905              RTS                     ; return to input to get more input
00003364                          2906  
00003364                          2907  SUB_L_DesEA_M4
00003364  7803                    2908              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003366  4EB9 0000484E           2909              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000336C  4EB9 00004B42           2910              JSR     PrintSub
00003372  4EB9 00004B64           2911              JSR     LengthL
00003378  4EB9 00004B88           2912              JSR     PrintSpace
0000337E                          2913  
0000337E  1E05                    2914              MOVE.B  D5,D7
00003380  1A00                    2915              MOVE.B  D0,D5
00003382  4EB9 000049A2           2916              JSR     PrintDataReg
00003388                          2917  
00003388  1A07                    2918              MOVE.B  D7,D5
0000338A  12EE 0025               2919              MOVE.B  37(A6),(A1)+             *,
0000338E  4EB9 000049D2           2920              JSR     PrintPreDeincAddrReg
00003394  4E75                    2921              RTS                     ; return to input to get more input
00003396                          2922  
00003396                          2923  SUB_L_DesEA_M7
00003396  7803                    2924              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003398  4EB9 0000484E           2925              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000339E                          2926  
0000339E  BABC 00000000           2927              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000033A4  6700 FC1A               2928              BEQ     SUB_L_SrcEA_xxxW
000033A8                          2929  
000033A8  BABC 00000001           2930              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000033AE  6700 FC36               2931              BEQ     SUB_L_SrcEA_xxxL
000033B2                          2932  
000033B2  4EF9 00004846           2933              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000033B8                          2934  
000033B8                          2935  SUB_L_DesEA_xxxW
000033B8  4EB9 00004B42           2936              JSR     PrintSub
000033BE  4EB9 00004B64           2937              JSR     LengthL
000033C4  4EB9 00004B88           2938              JSR     PrintSpace
000033CA                          2939  
000033CA  1E05                    2940              MOVE.B  D5,D7
000033CC  1A00                    2941              MOVE.B  D0,D5
000033CE  4EB9 000049A2           2942              JSR     PrintDataReg
000033D4                          2943  
000033D4  1A07                    2944              MOVE.B  D7,D5
000033D6  12EE 0025               2945              MOVE.B  37(A6),(A1)+             *,
000033DA  4EB9 00004948           2946              JSR     PrintByteOrWord
000033E0  4E75                    2947              RTS                     ; return to input to get more input
000033E2                          2948  
000033E2                          2949  SUB_L_DesEA_xxxL
000033E2  4EB9 00004B42           2950              JSR     PrintSub
000033E8  4EB9 00004B64           2951              JSR     LengthL
000033EE  4EB9 00004B88           2952              JSR     PrintSpace
000033F4                          2953  
000033F4  1E05                    2954              MOVE.B  D5,D7
000033F6  1A00                    2955              MOVE.B  D0,D5
000033F8  4EB9 000049A2           2956              JSR     PrintDataReg
000033FE                          2957  
000033FE  1A07                    2958              MOVE.B  D7,D5
00003400  12EE 0025               2959              MOVE.B  37(A6),(A1)+             *,
00003404  4EB9 0000495E           2960              JSR     PrintLong
0000340A  4E75                    2961              RTS                     ; return to input to get more input
0000340C                          2962  
0000340C                          2963  *************************************************                DIVU_W_Opcode              *************************************************
0000340C                          2964  ; first four bit is (1000 #### #### ####)
0000340C                          2965  DIVU_W_Opcode
0000340C  7803                    2966              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
0000340E  4EB9 0000484E           2967              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the register
00003414                          2968  
00003414  2005                    2969              MOVE.L  D5,D0               ; D0 will hold the register
00003416                          2970          ; D0 will hold the register (position 11-9)
00003416                          2971  
00003416  7803                    2972              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00003418  4EB9 0000484E           2973              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the register
0000341E                          2974  
0000341E  BABC 00000003           2975              CMP.L   #3,D5               ; position 8-6 should be 011, else it is invalid
00003424  6600 1420               2976              BNE     InvalidOpcode
00003428                          2977  
00003428  7803                    2978              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000342A  4EB9 0000484E           2979              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003430                          2980  
00003430  BABC 00000000           2981              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00003436  6700 0030               2982              BEQ     DIVU_W_M0
0000343A                          2983  
0000343A  BABC 00000002           2984              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00003440  6700 0054               2985              BEQ     DIVU_W_M2
00003444                          2986  
00003444  BABC 00000003           2987              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
0000344A  6700 0078               2988              BEQ     DIVU_W_M3
0000344E                          2989  
0000344E  BABC 00000004           2990              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00003454  6700 009C               2991              BEQ     DIVU_W_M4
00003458                          2992  
00003458  BABC 00000007           2993              CMP.L   #7,D5               ; if EA mode is 7 if D5 is 7
0000345E  6700 00C0               2994              BEQ     DIVU_W_M7
00003462                          2995  
00003462  4EF9 00004846           2996              JMP     InvalidOpcode       ; not one of the valid EA mode
00003468                          2997  
00003468                          2998  
00003468  7803                    2999  DIVU_W_M0   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000346A  4EB9 0000484E           3000              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
00003470  4EB9 00004A66           3001              JSR     PrintDivu
00003476  4EB9 00004B5A           3002              JSR     LengthW
0000347C  4EB9 00004B88           3003              JSR     PrintSpace
00003482  4EB9 000049A2           3004              JSR     PrintDataReg
00003488                          3005  
00003488  1A00                    3006              MOVE.B  D0,D5
0000348A  12EE 0025               3007              MOVE.B  37(A6),(A1)+             *,
0000348E  4EB9 000049A2           3008              JSR     PrintDataReg
00003494  4E75                    3009              RTS                     ; return to input to get more input
00003496                          3010  
00003496  7803                    3011  DIVU_W_M2   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003498  4EB9 0000484E           3012              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
0000349E  4EB9 00004A66           3013              JSR     PrintDivu
000034A4  4EB9 00004B5A           3014              JSR     LengthW
000034AA  4EB9 00004B88           3015              JSR     PrintSpace
000034B0  4EB9 000049BA           3016              JSR     PrintIndirAddrReg
000034B6                          3017  
000034B6  1A00                    3018              MOVE.B  D0,D5
000034B8  12EE 0025               3019              MOVE.B  37(A6),(A1)+             *,
000034BC  4EB9 000049A2           3020              JSR     PrintDataReg
000034C2  4E75                    3021              RTS                     ; return to input to get more input
000034C4                          3022  
000034C4  7803                    3023  DIVU_W_M3   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000034C6  4EB9 0000484E           3024              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
000034CC  4EB9 00004A66           3025              JSR     PrintDivu
000034D2  4EB9 00004B5A           3026              JSR     LengthW
000034D8  4EB9 00004B88           3027              JSR     PrintSpace
000034DE  4EB9 000049C8           3028              JSR     PrintPostIncAddrReg
000034E4                          3029  
000034E4  1A00                    3030              MOVE.B  D0,D5
000034E6  12EE 0025               3031              MOVE.B  37(A6),(A1)+             *,
000034EA  4EB9 000049A2           3032              JSR     PrintDataReg
000034F0  4E75                    3033              RTS                     ; return to input to get more input
000034F2                          3034  
000034F2  7803                    3035  DIVU_W_M4   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000034F4  4EB9 0000484E           3036              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
000034FA  4EB9 00004A66           3037              JSR     PrintDivu
00003500  4EB9 00004B5A           3038              JSR     LengthW
00003506  4EB9 00004B88           3039              JSR     PrintSpace
0000350C  4EB9 000049D2           3040              JSR     PrintPreDeincAddrReg
00003512                          3041  
00003512  1A00                    3042              MOVE.B  D0,D5
00003514  12EE 0025               3043              MOVE.B  37(A6),(A1)+             *,
00003518  4EB9 000049A2           3044              JSR     PrintDataReg
0000351E  4E75                    3045              RTS                     ; return to input to get more input
00003520                          3046  
00003520  7803                    3047  DIVU_W_M7   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003522  4EB9 0000484E           3048              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
00003528                          3049  
00003528  BABC 00000000           3050              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
0000352E  6700 001C               3051              BEQ     DIVU_W_xxxW
00003532                          3052  
00003532  BABC 00000001           3053              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003538  6700 0038               3054              BEQ     DIVU_W_xxxL
0000353C                          3055  
0000353C  BABC 00000004           3056              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00003542  6700 0054               3057              BEQ     DIVU_W_Data
00003546                          3058  
00003546  4EF9 00004846           3059              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1 or 4, it is invaid
0000354C                          3060  
0000354C  4EB9 00004A66           3061  DIVU_W_xxxW JSR     PrintDivu
00003552  4EB9 00004B5A           3062              JSR     LengthW
00003558  4EB9 00004B88           3063              JSR     PrintSpace
0000355E  4EB9 00004948           3064              JSR     PrintByteOrWord
00003564                          3065  
00003564  1A00                    3066              MOVE.B  D0,D5
00003566  12EE 0025               3067              MOVE.B  37(A6),(A1)+             *,
0000356A  4EB9 000049A2           3068              JSR     PrintDataReg
00003570  4E75                    3069              RTS                     ; return to input to get more input
00003572                          3070  
00003572  4EB9 00004A66           3071  DIVU_W_xxxL JSR     PrintDivu
00003578  4EB9 00004B5A           3072              JSR     LengthW
0000357E  4EB9 00004B88           3073              JSR     PrintSpace
00003584  4EB9 0000495E           3074              JSR     PrintLong
0000358A                          3075  
0000358A  1A00                    3076              MOVE.B  D0,D5
0000358C  12EE 0025               3077              MOVE.B  37(A6),(A1)+             *,
00003590  4EB9 000049A2           3078              JSR     PrintDataReg
00003596  4E75                    3079              RTS                     ; return to input to get more input
00003598                          3080  
00003598  4EB9 00004A66           3081  DIVU_W_Data JSR     PrintDivu
0000359E  4EB9 00004B5A           3082              JSR     LengthW
000035A4  4EB9 00004B88           3083              JSR     PrintSpace
000035AA  4EB9 0000493C           3084              JSR     PrintImmediateData
000035B0                          3085  
000035B0  1A00                    3086              MOVE.B  D0,D5
000035B2  12EE 0025               3087              MOVE.B  37(A6),(A1)+             *,
000035B6  4EB9 000049A2           3088              JSR     PrintDataReg
000035BC  4E75                    3089              RTS                     ; return to input to get more input
000035BE                          3090  
000035BE                          3091  *************************************************                Bcc_Opcode                 *************************************************
000035BE                          3092  ; first four bit is (0110 #### #### ####)
000035BE                          3093  Bcc_Opcode
000035BE  7804                    3094              MOVE.L  #4,D4          ; get the next 4 bit from (A4)(position 11-8) in to D5
000035C0  4EB9 0000484E           3095              JSR     GetNextD4bit   ; D5 hold the next 4 bit of (A4), which tell us which Bcc
000035C6                          3096         ; cmp to see whice Bcc opcode the the next 4 bit(position 11-8) match with
000035C6  BABC 0000000E           3097              CMP.L   #14,D5
000035CC  6700 0026               3098              BEQ     BGT_Opcode
000035D0                          3099  
000035D0  BABC 0000000F           3100              CMP.L   #15,D5
000035D6  6700 0028               3101              BEQ     BLE_Opcode
000035DA                          3102  
000035DA  BABC 00000000           3103              CMP.L   #0,D5
000035E0  6700 002A               3104              BEQ     BRA_Opcode
000035E4                          3105  
000035E4  BABC 00000007           3106              CMP.L   #7,D5
000035EA  6700 002C               3107              BEQ     BEQ_Opcode
000035EE                          3108  
000035EE  4EF9 00004846           3109              JMP     InvalidOpcode   ; (position 11-8) did not match any of the Bcc opcode, so it is invalid
000035F4                          3110  
000035F4                          3111  
000035F4  4EB9 00004A3C           3112  BGT_Opcode  JSR PrintBGT
000035FA  4EF9 00003624           3113              JMP     Bcc_displacement ; take care of output the displacement bit
00003600                          3114  
00003600  4EB9 00004A4A           3115  BLE_Opcode  JSR PrintBLE
00003606  4EF9 00003624           3116              JMP     Bcc_displacement ; take care of output the displacement bit
0000360C                          3117  
0000360C  4EB9 00004A58           3118  BRA_Opcode  JSR PrintBRA
00003612  4EF9 00003624           3119              JMP     Bcc_displacement ; take care of output the displacement bit
00003618                          3120  
00003618  4EB9 00004A2E           3121  BEQ_Opcode  JSR PrintBEQ
0000361E  4EF9 00003624           3122              JMP     Bcc_displacement ; take care of output the displacement bit
00003624                          3123  
00003624                          3124  Bcc_displacement    ;for gettin the next 8 bit for displacement and outputting it
00003624  7808                    3125              MOVE.L  #8,D4          ; get the next 8 bit from (A4)(position 7-0) in to D5
00003626  4EB9 0000484E           3126              JSR     GetNextD4bit   ; D5 hold the next 4 bit of (A4), which tell us the displacement
0000362C                          3127  
0000362C  BABC 00000000           3128              CMP.L   #$00,D5          ; if displacement is $00 than it is a 16bit displacement
00003632  6700 000E               3129              BEQ     Bcc_16bit_Disp
00003636                          3130  
00003636  BABC 000000FF           3131              CMP.L   #$FF,D5
0000363C  6700 000A               3132              BEQ     Bcc_32bit_Disp   ; if displacement is $00 than it is a 32bit displacement
00003640                          3133  
00003640                          3134              ; print 8bit displacemnt address from D5
00003640  4E75                    3135              RTS                     ; return to input to get more input
00003642                          3136  
00003642                          3137  Bcc_16bit_Disp
00003642                          3138              ; print 16bit address
00003642  12EE 0026               3139                  MOVE.B   38(A6),(A1)+        *$
00003646  4E75                    3140              RTS                     ; return to input to get more input
00003648                          3141  
00003648                          3142  Bcc_32bit_Disp
00003648                          3143              ; print 32bit address
00003648  12EE 0026               3144                  MOVE.B   38(A6),(A1)+        *$
0000364C  4E75                    3145              RTS                     ; return to input to get more input
0000364E                          3146  
0000364E                          3147  
0000364E                          3148  *************************************************                NeedMoreBit                *************************************************
0000364E                          3149  ;Could be MOVEM, MULS.L, DIVU.L, JSR, NOT, LEA
0000364E                          3150  ; first four bit is (0100 #### #### ####)
0000364E                          3151  NeedMoreBit
0000364E  7806                    3152              MOVE.L  #6,D4          ; get the next 6 bit from (A4)(position 11-6) in to D5
00003650  4EB9 0000484E           3153              JSR     GetNextD4bit   ; D5 hold the next 6 bit of (A4), which will narrow down the opcode possibility
00003656                          3154  
00003656  BABC 00000022           3155              CMP.L   #34,D5         ; if position 11-6 equal to 34, it is MoveM register to memory size Word
0000365C  6700 011C               3156              BEQ     MoveM_R2M_W
00003660                          3157  
00003660  BABC 00000023           3158              CMP.L   #35,D5         ; if position 11-6 equal to 35, it is MoveM register to memory size Long
00003666  6700 01E8               3159              BEQ     MoveM_R2M_L
0000366A                          3160  
0000366A  BABC 00000032           3161              CMP.L   #50,D5         ; if position 11-6 equal to 50, it is MoveM memory to register size word
00003670  6700 02B4               3162              BEQ     MoveM_M2R_W
00003674                          3163  
00003674  BABC 00000033           3164              CMP.L   #51,D5         ; if position 11-6 equal to 51, it is MoveM memory to register size long
0000367A  6700 0380               3165              BEQ     MoveM_M2R_L
0000367E                          3166  
0000367E  BABC 00000030           3167              CMP.L   #48,D5         ; if position 11-6 equal to 48, it is MULS.L
00003684  6700 044C               3168              BEQ     Muls_L
00003688                          3169  
00003688  BABC 00000031           3170              CMP.L   #49,D5         ; if position 11-6 equal to 49, it is DIVU.L
0000368E  6700 05D8               3171              BEQ     Divu_L
00003692                          3172  
00003692  BABC 0000003A           3173              CMP.L   #58,D5         ; if position 11-6 equal to 58, it is JSR
00003698  6700 0764               3174              BEQ     JSR_Opcode
0000369C                          3175  
0000369C  BABC 00000018           3176              CMP.L   #24,D5         ; if position 11-6 equal to 24, it is NOT size byte
000036A2  6700 07E2               3177              BEQ     Not_B_Opcode
000036A6                          3178  
000036A6  BABC 00000019           3179              CMP.L   #25,D5         ; if position 11-6 equal to 25, it is NOT size word
000036AC  6700 08F6               3180              BEQ     Not_W_Opcode
000036B0                          3181  
000036B0  BABC 0000001A           3182              CMP.L   #26,D5         ; if position 11-6 equal to 26, it is NOT size long
000036B6  6700 0A0A               3183              BEQ     Not_L_Opcode
000036BA                          3184  
000036BA                          3185  
000036BA                          3186  *************************************************                Lea_Opcode                 *************************************************
000036BA                          3187  ; notice there is no line that say jupm to Lea_Opcode, it should be run automatically of after NeedMoreBit, if it doesn't match other opcode
000036BA                          3188  Lea_Opcode  ; the only posible opcode left is LEA, it is LEA if the bit from position 8-6 is all 1
000036BA  E28D                    3189              LSR.L   #1,D5          ; shift left to get carry bit of 6 place
000036BC  6400 1188               3190              BCC     InvalidOpcode  ; if the carry bit is is not 1, it is not a valid opcode
000036C0  E28D                    3191              LSR.L   #1,D5          ; shift left to get carry bit of 5 place
000036C2  6400 1182               3192              BCC     InvalidOpcode  ; if the carry bit is is not 1, it is not a valid opcode
000036C6  E28D                    3193              LSR.L   #1,D5          ; shift left to get carry bit of 4 place
000036C8  6400 117C               3194              BCC     InvalidOpcode  ; if the carry bit is is not 1, it is not a valid opcode
000036CC                          3195  
000036CC                          3196          ; D5 should hold the position 11-9, which is the register, since D5 originaly hold bit from position 11-6 and we shift right 3 times.
000036CC                          3197          ; D0 will hold the register number for LEA opcode
000036CC                          3198  
000036CC  2005                    3199              MOVE.L  D5,D0          ; D0 will hold the register number for LEA opcode
000036CE                          3200  
000036CE  7803                    3201              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
000036D0  4EB9 0000484E           3202              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
000036D6                          3203  
000036D6  BABC 00000002           3204              CMP.L   #2,D5          ; if position 5-3 is two the EA for LEA is (An) mode 2
000036DC  6700 0012               3205              BEQ     Lea_M2_Opcode
000036E0                          3206  
000036E0  BABC 00000007           3207              CMP.L   #7,D5          ; if position 5-3 is 7 the EA for LEA is mode 7
000036E6  6700 0030               3208              BEQ     Lea_M7_Opcode
000036EA                          3209  
000036EA  4EF9 00004846           3210              JMP     InvalidOpcode  ; if it is not mode 7 or mode 2, LEA is invaid
000036F0                          3211  
000036F0                          3212  Lea_M2_Opcode
000036F0  7803                    3213              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000036F2  4EB9 0000484E           3214              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000036F8  4EB9 00004A86           3215              JSR     PrintLEA
000036FE  4EB9 00004B88           3216              JSR     PrintSpace
00003704  4EB9 000049BA           3217              JSR     PrintIndirAddrReg
0000370A                          3218  
0000370A  1A00                    3219              MOVE.B  D0,D5
0000370C  12EE 0025               3220              MOVE.B  37(A6),(A1)+             *,
00003710  4EB9 000049AE           3221              JSR     PrintAddrReg
00003716  4E75                    3222              RTS                     ; return to input to get more input
00003718                          3223  
00003718                          3224  Lea_M7_Opcode
00003718  7803                    3225              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000371A  4EB9 0000484E           3226              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003720                          3227  
00003720  BABC 00000000           3228              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for LEA is (xxx).W
00003726  6700 0012               3229              BEQ     Lea_xxxW_Opcode
0000372A                          3230  
0000372A  BABC 00000001           3231              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for LEA is (xxx).L
00003730  6700 0028               3232              BEQ     Lea_xxxL_Opcode
00003734                          3233  
00003734  4EF9 00004846           3234              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, LEA is invaid
0000373A                          3235  
0000373A                          3236  Lea_xxxW_Opcode
0000373A  4EB9 00004A86           3237              JSR     PrintLEA
00003740  4EB9 00004B88           3238              JSR     PrintSpace
00003746  4EB9 00004948           3239              JSR     PrintByteOrWord
0000374C                          3240  
0000374C  1A00                    3241              MOVE.B  D0,D5
0000374E  12EE 0025               3242              MOVE.B  37(A6),(A1)+             *,
00003752  4EB9 000049AE           3243              JSR     PrintAddrReg
00003758  4E75                    3244              RTS                     ; return to input to get more input
0000375A                          3245  
0000375A                          3246  Lea_xxxL_Opcode
0000375A  4EB9 00004A86           3247              JSR PrintLEA
00003760  4EB9 00004B88           3248              JSR     PrintSpace
00003766  4EB9 0000495E           3249              JSR     PrintLong
0000376C                          3250  
0000376C  1A00                    3251              MOVE.B  D0,D5
0000376E  12EE 0025               3252              MOVE.B  37(A6),(A1)+             *,
00003772  4EB9 000049AE           3253              JSR     PrintAddrReg
00003778  4E75                    3254              RTS                     ; return to input to get more input
0000377A                          3255  
0000377A                          3256  
0000377A                          3257  *************************************************                MoveM_R2M_W                *************************************************
0000377A                          3258  ; MOVEM.W from register to memory
0000377A                          3259  ; first 10 bit is (0100 1000 10## ####)
0000377A                          3260  MoveM_R2M_W
0000377A  7803                    3261              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
0000377C  4EB9 0000484E           3262              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003782                          3263  
00003782  BABC 00000002           3264              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
00003788  6700 001C               3265              BEQ     MoveM_R2M_W_M2
0000378C                          3266  
0000378C  BABC 00000004           3267              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
00003792  6700 0038               3268              BEQ     MoveM_R2M_W_M4
00003796                          3269  
00003796  BABC 00000007           3270              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
0000379C  6700 0054               3271              BEQ     MoveM_R2M_W_M7
000037A0                          3272  
000037A0  4EF9 00004846           3273              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
000037A6                          3274  
000037A6                          3275  MoveM_R2M_W_M2
000037A6  7803                    3276              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000037A8  4EB9 0000484E           3277              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000037AE  4EB9 00004AD6           3278              JSR     PrintMoveM
000037B4  4EB9 00004B5A           3279              JSR     LengthW
000037BA  4EB9 00004B88           3280              JSR     PrintSpace
000037C0                          3281              ;print <list>
000037C0  12EE 0025               3282              MOVE.B  37(A6),(A1)+             *,
000037C4  4EB9 000049BA           3283              JSR     PrintIndirAddrReg
000037CA  4E75                    3284              RTS                     ; return to input to get more input
000037CC                          3285  
000037CC                          3286  MoveM_R2M_W_M4
000037CC  7803                    3287              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000037CE  4EB9 0000484E           3288              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000037D4  4EB9 00004AD6           3289              JSR     PrintMoveM
000037DA  4EB9 00004B5A           3290              JSR     LengthW
000037E0  4EB9 00004B88           3291              JSR     PrintSpace
000037E6                          3292              ;print <list>
000037E6  12EE 0025               3293              MOVE.B  37(A6),(A1)+             *,
000037EA  4EB9 000049D2           3294              JSR     PrintPreDeincAddrReg
000037F0  4E75                    3295              RTS                     ; return to input to get more input
000037F2                          3296  
000037F2                          3297  MoveM_R2M_W_M7
000037F2  7803                    3298              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000037F4  4EB9 0000484E           3299              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000037FA                          3300  
000037FA  BABC 00000000           3301              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
00003800  6700 0012               3302              BEQ     MoveM_R2M_W_xxxW
00003804                          3303  
00003804  BABC 00000001           3304              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
0000380A  6700 0026               3305              BEQ     MoveM_R2M_W_xxxL
0000380E                          3306  
0000380E  4EF9 00004846           3307              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
00003814                          3308  
00003814                          3309  MoveM_R2M_W_xxxW
00003814  4EB9 00004AD6           3310              JSR PrintMoveM
0000381A  4EB9 00004B5A           3311              JSR LengthW
00003820  4EB9 00004B88           3312              JSR     PrintSpace
00003826                          3313              ;print <list>
00003826  12EE 0025               3314              MOVE.B  37(A6),(A1)+             *,
0000382A  4EB9 00004948           3315              JSR     PrintByteOrWord
00003830  4E75                    3316              RTS                     ; return to input to get more input
00003832                          3317  
00003832                          3318  MoveM_R2M_W_xxxL
00003832  4EB9 00004AD6           3319              JSR PrintMoveM
00003838  4EB9 00004B5A           3320              JSR LengthW
0000383E  4EB9 00004B88           3321              JSR     PrintSpace
00003844                          3322              ;print <list>
00003844  12EE 0025               3323              MOVE.B  37(A6),(A1)+             *,
00003848  4EB9 0000495E           3324              JSR     PrintLong
0000384E  4E75                    3325              RTS                     ; return to input to get more input
00003850                          3326  
00003850                          3327  
00003850                          3328  *************************************************                MoveM_R2M_L                *************************************************
00003850                          3329  ; MOVEM.L from register to memory
00003850                          3330  ; first 10 bit is (0100 1000 11## ####)
00003850                          3331  MoveM_R2M_L
00003850  7803                    3332              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003852  4EB9 0000484E           3333              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003858                          3334  
00003858  BABC 00000002           3335              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
0000385E  6700 001C               3336              BEQ     MoveM_R2M_L_M2
00003862                          3337  
00003862  BABC 00000004           3338              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
00003868  6700 0038               3339              BEQ     MoveM_R2M_L_M4
0000386C                          3340  
0000386C  BABC 00000007           3341              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
00003872  6700 0054               3342              BEQ     MoveM_R2M_L_M7
00003876                          3343  
00003876  4EF9 00004846           3344              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
0000387C                          3345  
0000387C                          3346  MoveM_R2M_L_M2
0000387C  7803                    3347              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000387E  4EB9 0000484E           3348              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003884  4EB9 00004AD6           3349              JSR PrintMoveM
0000388A  4EB9 00004B64           3350              JSR LengthL
00003890  4EB9 00004B88           3351              JSR     PrintSpace
00003896                          3352              ;print <list>
00003896  12EE 0025               3353              MOVE.B  37(A6),(A1)+             *,
0000389A  4EB9 000049BA           3354              JSR     PrintIndirAddrReg
000038A0  4E75                    3355              RTS                     ; return to input to get more input
000038A2                          3356  
000038A2                          3357  MoveM_R2M_L_M4
000038A2  7803                    3358              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000038A4  4EB9 0000484E           3359              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000038AA  4EB9 00004AD6           3360              JSR PrintMoveM
000038B0  4EB9 00004B64           3361              JSR LengthL
000038B6  4EB9 00004B88           3362              JSR     PrintSpace
000038BC                          3363              ;print <list>
000038BC  12EE 0025               3364              MOVE.B  37(A6),(A1)+             *,
000038C0  4EB9 000049D2           3365              JSR     PrintPreDeincAddrReg
000038C6  4E75                    3366              RTS                     ; return to input to get more input
000038C8                          3367  
000038C8                          3368  MoveM_R2M_L_M7
000038C8  7803                    3369              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000038CA  4EB9 0000484E           3370              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000038D0                          3371  
000038D0  BABC 00000000           3372              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
000038D6  6700 0012               3373              BEQ     MoveM_R2M_L_xxxW
000038DA                          3374  
000038DA  BABC 00000001           3375              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
000038E0  6700 0026               3376              BEQ     MoveM_R2M_L_xxxL
000038E4                          3377  
000038E4  4EF9 00004846           3378              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
000038EA                          3379  
000038EA                          3380  MoveM_R2M_L_xxxW
000038EA  4EB9 00004AD6           3381              JSR PrintMoveM
000038F0  4EB9 00004B64           3382              JSR LengthL
000038F6  4EB9 00004B88           3383              JSR     PrintSpace
000038FC                          3384              ;print <list>
000038FC  12EE 0025               3385              MOVE.B  37(A6),(A1)+             *,
00003900  4EB9 00004948           3386              JSR     PrintByteOrWord
00003906  4E75                    3387              RTS                     ; return to input to get more input
00003908                          3388  
00003908                          3389  MoveM_R2M_L_xxxL
00003908  4EB9 00004AD6           3390              JSR PrintMoveM
0000390E  4EB9 00004B64           3391              JSR LengthL
00003914  4EB9 00004B88           3392              JSR     PrintSpace
0000391A                          3393              ;print <list>
0000391A  12EE 0025               3394              MOVE.B  37(A6),(A1)+             *,
0000391E  4EB9 0000495E           3395              JSR     PrintLong
00003924  4E75                    3396              RTS                     ; return to input to get more input
00003926                          3397  
00003926                          3398  *************************************************                MoveM_M2R_W                *************************************************
00003926                          3399  ; MOVEM.W from memory to register
00003926                          3400  ; first 10 bit is (0100 1100 10## ####)
00003926                          3401  MoveM_M2R_W
00003926  7803                    3402              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003928  4EB9 0000484E           3403              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
0000392E                          3404  
0000392E  BABC 00000002           3405              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
00003934  6700 001C               3406              BEQ     MoveM_M2R_W_M2
00003938                          3407  
00003938  BABC 00000004           3408              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
0000393E  6700 0038               3409              BEQ     MoveM_M2R_W_M4
00003942                          3410  
00003942  BABC 00000007           3411              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
00003948  6700 0054               3412              BEQ     MoveM_M2R_W_M7
0000394C                          3413  
0000394C  4EF9 00004846           3414              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
00003952                          3415  
00003952                          3416  MoveM_M2R_W_M2
00003952  7803                    3417              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003954  4EB9 0000484E           3418              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000395A  4EB9 00004AD6           3419              JSR     PrintMoveM
00003960  4EB9 00004B5A           3420              JSR     LengthW
00003966  4EB9 00004B88           3421              JSR     PrintSpace
0000396C  4EB9 000049BA           3422              JSR     PrintIndirAddrReg
00003972                          3423  
00003972  12EE 0025               3424              MOVE.B  37(A6),(A1)+             *,
00003976                          3425              ;print <list>
00003976  4E75                    3426              RTS                     ; return to input to get more input
00003978                          3427  
00003978                          3428  MoveM_M2R_W_M4
00003978  7803                    3429              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000397A  4EB9 0000484E           3430              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003980  4EB9 00004AD6           3431              JSR     PrintMoveM
00003986  4EB9 00004B5A           3432              JSR     LengthW
0000398C  4EB9 00004B88           3433              JSR     PrintSpace
00003992  4EB9 000049D2           3434              JSR     PrintPreDeincAddrReg
00003998                          3435  
00003998  12EE 0025               3436              MOVE.B  37(A6),(A1)+             *,
0000399C                          3437              ;print <list>
0000399C  4E75                    3438              RTS                     ; return to input to get more input
0000399E                          3439  
0000399E                          3440  MoveM_M2R_W_M7
0000399E  7803                    3441              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000039A0  4EB9 0000484E           3442              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000039A6                          3443  
000039A6  BABC 00000000           3444              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
000039AC  6700 0012               3445              BEQ     MoveM_M2R_W_xxxW
000039B0                          3446  
000039B0  BABC 00000001           3447              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
000039B6  6700 0026               3448              BEQ     MoveM_M2R_W_xxxL
000039BA                          3449  
000039BA  4EF9 00004846           3450              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
000039C0                          3451  
000039C0                          3452  MoveM_M2R_W_xxxW
000039C0  4EB9 00004AD6           3453              JSR     PrintMoveM
000039C6  4EB9 00004B5A           3454              JSR     LengthW
000039CC  4EB9 00004B88           3455              JSR     PrintSpace
000039D2  4EB9 00004948           3456              JSR     PrintByteOrWord
000039D8                          3457  
000039D8  12EE 0025               3458              MOVE.B  37(A6),(A1)+             *,
000039DC                          3459              ;print <list>
000039DC  4E75                    3460              RTS                     ; return to input to get more input
000039DE                          3461  
000039DE                          3462  MoveM_M2R_W_xxxL
000039DE  4EB9 00004AD6           3463              JSR     PrintMoveM
000039E4  4EB9 00004B5A           3464              JSR     LengthW
000039EA  4EB9 00004B88           3465              JSR     PrintSpace
000039F0  4EB9 0000495E           3466              JSR     PrintLong
000039F6                          3467  
000039F6  12EE 0025               3468              MOVE.B  37(A6),(A1)+             *,
000039FA                          3469              ;print <list>
000039FA  4E75                    3470              RTS                     ; return to input to get more input
000039FC                          3471  
000039FC                          3472  *************************************************                MoveM_M2R_L                *************************************************
000039FC                          3473  ; MOVEM.L from memory to register
000039FC                          3474  ; first 10 bit is (0100 1100 11## ####)
000039FC                          3475  MoveM_M2R_L
000039FC  7803                    3476              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
000039FE  4EB9 0000484E           3477              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003A04                          3478  
00003A04  BABC 00000002           3479              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
00003A0A  6700 001C               3480              BEQ     MoveM_M2R_L_M2
00003A0E                          3481  
00003A0E  BABC 00000004           3482              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
00003A14  6700 0038               3483              BEQ     MoveM_M2R_L_M4
00003A18                          3484  
00003A18  BABC 00000007           3485              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
00003A1E  6700 0054               3486              BEQ     MoveM_M2R_L_M7
00003A22                          3487  
00003A22  4EF9 00004846           3488              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
00003A28                          3489  
00003A28                          3490  MoveM_M2R_L_M2
00003A28  7803                    3491              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003A2A  4EB9 0000484E           3492              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003A30  4EB9 00004AD6           3493              JSR     PrintMoveM
00003A36  4EB9 00004B64           3494              JSR     LengthL
00003A3C  4EB9 00004B88           3495              JSR     PrintSpace
00003A42  4EB9 000049BA           3496              JSR     PrintIndirAddrReg
00003A48                          3497  
00003A48  12EE 0025               3498              MOVE.B  37(A6),(A1)+             *,
00003A4C                          3499              ;print <list>
00003A4C  4E75                    3500              RTS                     ; return to input to get more input
00003A4E                          3501  
00003A4E                          3502  MoveM_M2R_L_M4
00003A4E  7803                    3503              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003A50  4EB9 0000484E           3504              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003A56  4EB9 00004AD6           3505              JSR     PrintMoveM
00003A5C  4EB9 00004B64           3506              JSR     LengthL
00003A62  4EB9 00004B88           3507              JSR     PrintSpace
00003A68  4EB9 000049D2           3508              JSR     PrintPreDeincAddrReg
00003A6E                          3509  
00003A6E  12EE 0025               3510              MOVE.B  37(A6),(A1)+             *,
00003A72                          3511              ;print <list>
00003A72  4E75                    3512              RTS                     ; return to input to get more input
00003A74                          3513  
00003A74                          3514  MoveM_M2R_L_M7
00003A74  7803                    3515              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003A76  4EB9 0000484E           3516              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003A7C                          3517  
00003A7C  BABC 00000000           3518              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
00003A82  6700 0012               3519              BEQ     MoveM_M2R_L_xxxW
00003A86                          3520  
00003A86  BABC 00000001           3521              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
00003A8C  6700 0026               3522              BEQ     MoveM_M2R_L_xxxL
00003A90                          3523  
00003A90  4EF9 00004846           3524              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
00003A96                          3525  
00003A96                          3526  MoveM_M2R_L_xxxW
00003A96  4EB9 00004AD6           3527              JSR     PrintMoveM
00003A9C  4EB9 00004B64           3528              JSR     LengthL
00003AA2  4EB9 00004B88           3529              JSR     PrintSpace
00003AA8  4EB9 00004948           3530              JSR     PrintByteOrWord
00003AAE                          3531  
00003AAE  12EE 0025               3532              MOVE.B  37(A6),(A1)+             *,
00003AB2                          3533              ;print <list>
00003AB2  4E75                    3534              RTS                     ; return to input to get more input
00003AB4                          3535  
00003AB4                          3536  MoveM_M2R_L_xxxL
00003AB4  4EB9 00004AD6           3537              JSR     PrintMoveM
00003ABA  4EB9 00004B64           3538              JSR     LengthL
00003AC0  4EB9 00004B88           3539              JSR     PrintSpace
00003AC6  4EB9 0000495E           3540              JSR     PrintLong
00003ACC                          3541  
00003ACC  12EE 0025               3542              MOVE.B  37(A6),(A1)+             *,
00003AD0                          3543              ;print <list>
00003AD0  4E75                    3544              RTS                     ; return to input to get more input
00003AD2                          3545  
00003AD2                          3546  *************************************************                Muls_L                 *************************************************
00003AD2                          3547  ; first 10 bit is (0100 1100 00## ####)
00003AD2  7803                    3548  Muls_L      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003AD4  4EB9 0000484E           3549              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003ADA                          3550  
00003ADA  BABC 00000000           3551              CMP.L   #0,D5          ; if position 5-3 is 0 the EA for MULS.L is Dn mode 0
00003AE0  6700 0030               3552              BEQ     Muls_L_M0
00003AE4                          3553  
00003AE4  BABC 00000002           3554              CMP.L   #2,D5          ; if position 5-3 is 2 the EA for MULS.L is (An) mode 2
00003AEA  6700 0054               3555              BEQ     Muls_L_M2
00003AEE                          3556  
00003AEE  BABC 00000003           3557              CMP.L   #3,D5          ; if position 5-3 is 3 the EA for MULS.L is (An)+ mode 3
00003AF4  6700 0078               3558              BEQ     Muls_L_M3
00003AF8                          3559  
00003AF8  BABC 00000004           3560              CMP.L   #4,D5          ; if position 5-3 is 4 the EA for MULS.L is -(An) mode 4
00003AFE  6700 009C               3561              BEQ     Muls_L_M4
00003B02                          3562  
00003B02  BABC 00000007           3563              CMP.L   #7,D5          ; if position 5-3 is 7 the EA for MULS.L is mode 7
00003B08  6700 00C0               3564              BEQ     Muls_L_M7
00003B0C                          3565  
00003B0C  4EF9 00004846           3566              JMP     InvalidOpcode  ; if it is not one of the moveM EA mode
00003B12                          3567  
00003B12  7803                    3568  Muls_L_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003B14  4EB9 0000484E           3569              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003B1A  4EB9 00004AE0           3570              JSR     PrintMuls
00003B20  4EB9 00004B64           3571              JSR     LengthL
00003B26  4EB9 00004B88           3572              JSR     PrintSpace
00003B2C  4EB9 000049A2           3573              JSR     PrintDataReg
00003B32                          3574  
00003B32  12EE 0025               3575              MOVE.B  37(A6),(A1)+             *,
00003B36  385C                    3576              MOVE.W  (A4)+,A4
00003B38  4EB9 000048C6           3577              JSR     PrintAddr
00003B3E  4E75                    3578              RTS                     ; return to input to get more input
00003B40                          3579  
00003B40  7803                    3580  Muls_L_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003B42  4EB9 0000484E           3581              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003B48  4EB9 00004AE0           3582              JSR     PrintMuls
00003B4E  4EB9 00004B64           3583              JSR     LengthL
00003B54  4EB9 00004B88           3584              JSR     PrintSpace
00003B5A  4EB9 000049BA           3585              JSR     PrintIndirAddrReg
00003B60                          3586  
00003B60  12EE 0025               3587              MOVE.B  37(A6),(A1)+             *,
00003B64  385C                    3588              MOVE.W  (A4)+,A4
00003B66  4EB9 000048C6           3589              JSR     PrintAddr
00003B6C  4E75                    3590              RTS                     ; return to input to get more input
00003B6E                          3591  
00003B6E  7803                    3592  Muls_L_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003B70  4EB9 0000484E           3593              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003B76  4EB9 00004AE0           3594              JSR     PrintMuls
00003B7C  4EB9 00004B64           3595              JSR     LengthL
00003B82  4EB9 00004B88           3596              JSR     PrintSpace
00003B88  4EB9 000049C8           3597              JSR     PrintPostIncAddrReg
00003B8E                          3598  
00003B8E  12EE 0025               3599              MOVE.B  37(A6),(A1)+             *,
00003B92  385C                    3600              MOVE.W  (A4)+,A4
00003B94  4EB9 000048C6           3601              JSR     PrintAddr
00003B9A  4E75                    3602              RTS                     ; return to input to get more input
00003B9C                          3603  
00003B9C  7803                    3604  Muls_L_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003B9E  4EB9 0000484E           3605              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003BA4  4EB9 00004AE0           3606              JSR     PrintMuls
00003BAA  4EB9 00004B64           3607              JSR     LengthL
00003BB0  4EB9 00004B88           3608              JSR     PrintSpace
00003BB6  4EB9 000049D2           3609              JSR     PrintPreDeincAddrReg
00003BBC                          3610  
00003BBC  12EE 0025               3611              MOVE.B  37(A6),(A1)+             *,
00003BC0  385C                    3612              MOVE.W  (A4)+,A4
00003BC2  4EB9 000048C6           3613              JSR     PrintAddr
00003BC8  4E75                    3614              RTS                     ; return to input to get more input
00003BCA                          3615  
00003BCA  7803                    3616  Muls_L_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003BCC  4EB9 0000484E           3617              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003BD2                          3618  
00003BD2  BABC 00000000           3619              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003BD8  6700 001C               3620              BEQ     Muls_L_xxxW
00003BDC                          3621  
00003BDC  BABC 00000001           3622              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003BE2  6700 0038               3623              BEQ     Muls_L_xxxL
00003BE6                          3624  
00003BE6  BABC 00000004           3625              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00003BEC  6700 0054               3626              BEQ     Muls_L_Data
00003BF0                          3627  
00003BF0  4EF9 00004846           3628              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1 or 4, MULS.L is invaid
00003BF6                          3629  
00003BF6  4EB9 00004AE0           3630  Muls_L_xxxW JSR     PrintMuls
00003BFC  4EB9 00004B64           3631              JSR     LengthL
00003C02  4EB9 00004B88           3632              JSR     PrintSpace
00003C08  4EB9 00004948           3633              JSR     PrintByteOrWord
00003C0E                          3634  
00003C0E  12EE 0025               3635              MOVE.B  37(A6),(A1)+             *,
00003C12                          3636  
00003C12  385C                    3637              MOVE.W  (A4)+,A4
00003C14  4EB9 000048C6           3638              JSR     PrintAddr
00003C1A  4E75                    3639              RTS                     ; return to input to get more input
00003C1C                          3640  
00003C1C  4EB9 00004AE0           3641  Muls_L_xxxL JSR     PrintMuls
00003C22  4EB9 00004B64           3642              JSR     LengthL
00003C28  4EB9 00004B88           3643              JSR     PrintSpace
00003C2E  4EB9 0000495E           3644              JSR     PrintLong
00003C34                          3645  
00003C34  12EE 0025               3646              MOVE.B  37(A6),(A1)+             *,
00003C38  385C                    3647              MOVE.W  (A4)+,A4
00003C3A  4EB9 000048C6           3648              JSR     PrintAddr
00003C40  4E75                    3649              RTS                     ; return to input to get more input
00003C42                          3650  
00003C42  4EB9 00004AE0           3651  Muls_L_Data JSR PrintMuls
00003C48  4EB9 00004B64           3652              JSR LengthL
00003C4E  4EB9 00004B88           3653              JSR     PrintSpace
00003C54  4EB9 0000493C           3654              JSR     PrintImmediateData
00003C5A                          3655  
00003C5A  12EE 0025               3656              MOVE.B  37(A6),(A1)+             *,
00003C5E  385C                    3657              MOVE.W  (A4)+,A4
00003C60  4EB9 000048C6           3658              JSR     PrintAddr
00003C66  4E75                    3659              RTS                     ; return to input to get more input
00003C68                          3660  
00003C68                          3661  *************************************************                Divu_L                 *************************************************
00003C68                          3662  ; first 10 bit is (0100 1100 01## ####)
00003C68  7803                    3663  Divu_L      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003C6A  4EB9 0000484E           3664              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003C70                          3665  
00003C70  BABC 00000000           3666              CMP.L   #0,D5          ; if position 5-3 is 0 the EA for MULS.L is Dn mode 0
00003C76  6700 0030               3667              BEQ     Divu_L_M0
00003C7A                          3668  
00003C7A  BABC 00000002           3669              CMP.L   #2,D5          ; if position 5-3 is 2 the EA for MULS.L is (An) mode 2
00003C80  6700 0054               3670              BEQ     Divu_L_M2
00003C84                          3671  
00003C84  BABC 00000003           3672              CMP.L   #3,D5          ; if position 5-3 is 3 the EA for MULS.L is (An)+ mode 3
00003C8A  6700 0078               3673              BEQ     Divu_L_M3
00003C8E                          3674  
00003C8E  BABC 00000004           3675              CMP.L   #4,D5          ; if position 5-3 is 4 the EA for MULS.L is -(An) mode 4
00003C94  6700 009C               3676              BEQ     Divu_L_M4
00003C98                          3677  
00003C98  BABC 00000007           3678              CMP.L   #7,D5          ; if position 5-3 is 7 the EA for MULS.L is mode 7
00003C9E  6700 00C0               3679              BEQ     Divu_L_M7
00003CA2                          3680  
00003CA2  4EF9 00004846           3681              JMP     InvalidOpcode  ; if it is not one of the moveM EA mode
00003CA8                          3682  
00003CA8  7803                    3683  Divu_L_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003CAA  4EB9 0000484E           3684              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003CB0  4EB9 00004A66           3685              JSR     PrintDivu
00003CB6  4EB9 00004B64           3686              JSR     LengthL
00003CBC  4EB9 00004B88           3687              JSR     PrintSpace
00003CC2  4EB9 000049A2           3688              JSR     PrintDataReg
00003CC8                          3689  
00003CC8  12EE 0025               3690              MOVE.B  37(A6),(A1)+             *,
00003CCC  385C                    3691              MOVE.W  (A4)+,A4
00003CCE  4EB9 000048C6           3692              JSR     PrintAddr
00003CD4  4E75                    3693              RTS                     ; return to input to get more input
00003CD6                          3694  
00003CD6  7803                    3695  Divu_L_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003CD8  4EB9 0000484E           3696              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003CDE  4EB9 00004A66           3697              JSR     PrintDivu
00003CE4  4EB9 00004B64           3698              JSR     LengthL
00003CEA  4EB9 00004B88           3699              JSR     PrintSpace
00003CF0  4EB9 000049BA           3700              JSR     PrintIndirAddrReg
00003CF6                          3701  
00003CF6  12EE 0025               3702              MOVE.B  37(A6),(A1)+             *,
00003CFA  385C                    3703              MOVE.W  (A4)+,A4
00003CFC  4EB9 000048C6           3704              JSR     PrintAddr
00003D02  4E75                    3705              RTS                     ; return to input to get more input
00003D04                          3706  
00003D04  7803                    3707  Divu_L_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003D06  4EB9 0000484E           3708              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003D0C  4EB9 00004A66           3709              JSR     PrintDivu
00003D12  4EB9 00004B64           3710              JSR     LengthL
00003D18  4EB9 00004B88           3711              JSR     PrintSpace
00003D1E  4EB9 000049C8           3712              JSR     PrintPostIncAddrReg
00003D24                          3713  
00003D24  12EE 0025               3714              MOVE.B  37(A6),(A1)+             *,
00003D28  385C                    3715              MOVE.W  (A4)+,A4
00003D2A  4EB9 000048C6           3716              JSR     PrintAddr
00003D30  4E75                    3717              RTS                     ; return to input to get more input
00003D32                          3718  
00003D32  7803                    3719  Divu_L_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003D34  4EB9 0000484E           3720              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003D3A  4EB9 00004A66           3721              JSR     PrintDivu
00003D40  4EB9 00004B64           3722              JSR     LengthL
00003D46  4EB9 00004B88           3723              JSR     PrintSpace
00003D4C  4EB9 000049D2           3724              JSR     PrintPreDeincAddrReg
00003D52                          3725  
00003D52  12EE 0025               3726              MOVE.B  37(A6),(A1)+             *,
00003D56  385C                    3727              MOVE.W  (A4)+,A4
00003D58  4EB9 000048C6           3728              JSR     PrintAddr
00003D5E  4E75                    3729              RTS                     ; return to input to get more input
00003D60                          3730  
00003D60  7803                    3731  Divu_L_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003D62  4EB9 0000484E           3732              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003D68                          3733  
00003D68  BABC 00000000           3734              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003D6E  6700 001C               3735              BEQ     Divu_L_xxxW
00003D72                          3736  
00003D72  BABC 00000001           3737              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003D78  6700 0038               3738              BEQ     Divu_L_xxxL
00003D7C                          3739  
00003D7C  BABC 00000004           3740              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00003D82  6700 0054               3741              BEQ     Divu_L_Data
00003D86                          3742  
00003D86  4EF9 00004846           3743              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1 or 4, Divu.L is invaid
00003D8C                          3744  
00003D8C  4EB9 00004A66           3745  Divu_L_xxxW JSR     PrintDivu
00003D92  4EB9 00004B64           3746              JSR     LengthL
00003D98  4EB9 00004B88           3747              JSR     PrintSpace
00003D9E  4EB9 00004948           3748              JSR     PrintByteOrWord
00003DA4                          3749  
00003DA4  12EE 0025               3750              MOVE.B  37(A6),(A1)+             *,
00003DA8  385C                    3751              MOVE.W  (A4)+,A4
00003DAA  4EB9 000048C6           3752              JSR     PrintAddr
00003DB0  4E75                    3753              RTS                     ; return to input to get more input
00003DB2                          3754  
00003DB2  4EB9 00004A66           3755  Divu_L_xxxL JSR     PrintDivu
00003DB8  4EB9 00004B64           3756              JSR     LengthL
00003DBE  4EB9 00004B88           3757              JSR     PrintSpace
00003DC4  4EB9 0000495E           3758              JSR     PrintLong
00003DCA                          3759  
00003DCA  12EE 0025               3760              MOVE.B  37(A6),(A1)+             *,
00003DCE  385C                    3761              MOVE.W  (A4)+,A4
00003DD0  4EB9 000048C6           3762              JSR     PrintAddr
00003DD6  4E75                    3763              RTS                     ; return to input to get more input
00003DD8                          3764  
00003DD8  4EB9 00004A66           3765  Divu_L_Data JSR     PrintDivu
00003DDE  4EB9 00004B64           3766              JSR     LengthL
00003DE4  4EB9 00004B88           3767              JSR     PrintSpace
00003DEA  4EB9 0000493C           3768              JSR     PrintImmediateData
00003DF0                          3769  
00003DF0  12EE 0025               3770              MOVE.B  37(A6),(A1)+             *,
00003DF4  385C                    3771              MOVE.W  (A4)+,A4
00003DF6  4EB9 000048C6           3772              JSR     PrintAddr
00003DFC  4E75                    3773              RTS                     ; return to input to get more input
00003DFE                          3774  
00003DFE                          3775  
00003DFE                          3776  *************************************************                JSR_Opcode             *************************************************
00003DFE                          3777  ; first 10 bit is (0100 1110 10## ####)
00003DFE  7803                    3778  JSR_Opcode  MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003E00  4EB9 0000484E           3779              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003E06                          3780  
00003E06  BABC 00000002           3781              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An) mode 2
00003E0C  6700 0012               3782              BEQ     JSR_M2
00003E10                          3783  
00003E10  BABC 00000007           3784              CMP.L   #7,D5          ; if position 5-3 is 2 the EA is (An) mode 2
00003E16  6700 0024               3785              BEQ     JSR_M7
00003E1A                          3786  
00003E1A  4EF9 00004846           3787              JMP     InvalidOpcode  ; if it is not a valid JSR EA mode if it is not 2 or 7
00003E20                          3788  
00003E20  7803                    3789  JSR_M2      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003E22  4EB9 0000484E           3790              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003E28  4EB9 00004A78           3791              JSR     PrintJSR
00003E2E  4EB9 00004B88           3792              JSR     PrintSpace
00003E34  4EB9 000049BA           3793              JSR     PrintIndirAddrReg
00003E3A  4E75                    3794              RTS                     ; return to input to get more input
00003E3C                          3795  
00003E3C  7803                    3796  JSR_M7      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003E3E  4EB9 0000484E           3797              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003E44                          3798  
00003E44  BABC 00000000           3799              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003E4A  6700 0012               3800              BEQ     JSR_xxxW
00003E4E                          3801  
00003E4E  BABC 00000001           3802              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003E54  6700 001C               3803              BEQ     JSR_xxxL
00003E58                          3804  
00003E58  4EF9 00004846           3805              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid JSR EA mode
00003E5E                          3806  
00003E5E  4EB9 00004A78           3807  JSR_xxxW    JSR     PrintJSR
00003E64  4EB9 00004B88           3808              JSR     PrintSpace
00003E6A  4EB9 00004948           3809              JSR     PrintByteOrWord
00003E70  4E75                    3810              RTS                     ; return to input to get more input
00003E72                          3811  
00003E72  4EB9 00004A78           3812  JSR_xxxL    JSR     PrintJSR
00003E78  4EB9 00004B88           3813              JSR     PrintSpace
00003E7E  4EB9 0000495E           3814              JSR     PrintLong
00003E84  4E75                    3815              RTS                     ; return to input to get more input
00003E86                          3816  
00003E86                          3817  
00003E86                          3818  *************************************************                Not_B_Opcode           *************************************************
00003E86                          3819  ; first 10 bit is (0100 0110 00## ####)
00003E86                          3820  Not_B_Opcode
00003E86  7803                    3821              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003E88  4EB9 0000484E           3822              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003E8E                          3823  
00003E8E  BABC 00000000           3824              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
00003E94  6700 0030               3825              BEQ     Not_B_M0
00003E98                          3826  
00003E98  BABC 00000002           3827              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
00003E9E  6700 0048               3828              BEQ     Not_B_M2
00003EA2                          3829  
00003EA2  BABC 00000003           3830              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00003EA8  6700 0060               3831              BEQ     Not_B_M3
00003EAC                          3832  
00003EAC  BABC 00000004           3833              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
00003EB2  6700 0078               3834              BEQ     Not_B_M4
00003EB6                          3835  
00003EB6  BABC 00000007           3836              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode is 7
00003EBC  6700 0090               3837              BEQ     Not_B_M7
00003EC0                          3838  
00003EC0  4EF9 00004846           3839              JMP     InvalidOpcode  ; if it is not a valid NOT EA mode if it is not 0 2 3 4 7
00003EC6                          3840  
00003EC6  7803                    3841  Not_B_M0    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003EC8  4EB9 0000484E           3842              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003ECE  4EB9 00004B00           3843              JSR     PrintNot
00003ED4  4EB9 00004B50           3844              JSR     LengthB
00003EDA  4EB9 00004B88           3845              JSR     PrintSpace
00003EE0  4EB9 000049A2           3846              JSR     PrintDataReg
00003EE6  4E75                    3847              RTS                     ; return to input to get more input
00003EE8                          3848  
00003EE8  7803                    3849  Not_B_M2    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003EEA  4EB9 0000484E           3850              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003EF0  4EB9 00004B00           3851              JSR     PrintNot
00003EF6  4EB9 00004B50           3852              JSR     LengthB
00003EFC  4EB9 00004B88           3853              JSR     PrintSpace
00003F02  4EB9 000049BA           3854              JSR     PrintIndirAddrReg
00003F08  4E75                    3855              RTS                     ; return to input to get more input
00003F0A                          3856  
00003F0A  7803                    3857  Not_B_M3    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003F0C  4EB9 0000484E           3858              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003F12  4EB9 00004B00           3859              JSR     PrintNot
00003F18  4EB9 00004B50           3860              JSR     LengthB
00003F1E  4EB9 00004B88           3861              JSR     PrintSpace
00003F24  4EB9 000049C8           3862              JSR     PrintPostIncAddrReg
00003F2A  4E75                    3863              RTS                     ; return to input to get more input
00003F2C                          3864  
00003F2C  7803                    3865  Not_B_M4    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003F2E  4EB9 0000484E           3866              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003F34  4EB9 00004B00           3867              JSR     PrintNot
00003F3A  4EB9 00004B50           3868              JSR     LengthB
00003F40  4EB9 00004B88           3869              JSR     PrintSpace
00003F46  4EB9 000049D2           3870              JSR     PrintPreDeincAddrReg
00003F4C  4E75                    3871              RTS                     ; return to input to get more input
00003F4E                          3872  
00003F4E  7803                    3873  Not_B_M7    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003F50  4EB9 0000484E           3874              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003F56                          3875  
00003F56  BABC 00000000           3876              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003F5C  6700 0012               3877              BEQ     Not_B_xxxW
00003F60                          3878  
00003F60  BABC 00000001           3879              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003F66  6700 0022               3880              BEQ     Not_B_xxxL
00003F6A                          3881  
00003F6A  4EF9 00004846           3882              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid NOT EA mode
00003F70                          3883  
00003F70  4EB9 00004B00           3884  Not_B_xxxW  JSR     PrintNot
00003F76  4EB9 00004B50           3885              JSR     LengthB
00003F7C  4EB9 00004B88           3886              JSR     PrintSpace
00003F82  4EB9 00004948           3887              JSR     PrintByteOrWord
00003F88  4E75                    3888              RTS                     ; return to input to get more input
00003F8A                          3889  
00003F8A  4EB9 00004B00           3890  Not_B_xxxL  JSR     PrintNot
00003F90  4EB9 00004B50           3891              JSR     LengthB
00003F96  4EB9 00004B88           3892              JSR     PrintSpace
00003F9C  4EB9 0000495E           3893              JSR     PrintLong
00003FA2  4E75                    3894              RTS                     ; return to input to get more input
00003FA4                          3895  
00003FA4                          3896  
00003FA4                          3897  *************************************************                Not_W_Opcode           *************************************************
00003FA4                          3898  ; first 10 bit is (0100 0110 01## ####)
00003FA4                          3899  Not_W_Opcode
00003FA4  7803                    3900              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003FA6  4EB9 0000484E           3901              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003FAC                          3902  
00003FAC  BABC 00000000           3903              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
00003FB2  6700 0030               3904              BEQ     Not_W_M0
00003FB6                          3905  
00003FB6  BABC 00000002           3906              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
00003FBC  6700 0048               3907              BEQ     Not_W_M2
00003FC0                          3908  
00003FC0  BABC 00000003           3909              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00003FC6  6700 0060               3910              BEQ     Not_W_M3
00003FCA                          3911  
00003FCA  BABC 00000004           3912              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
00003FD0  6700 0078               3913              BEQ     Not_W_M4
00003FD4                          3914  
00003FD4  BABC 00000007           3915              CMP.L   #7,D5          ; if position 5-3 is 7 the EA mode is 7
00003FDA  6700 0090               3916              BEQ     Not_W_M7
00003FDE                          3917  
00003FDE  4EF9 00004846           3918              JMP     InvalidOpcode  ; if it is not a valid NOT EA mode if it is not 0 2 3 4 7
00003FE4                          3919  
00003FE4  7803                    3920  Not_W_M0    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003FE6  4EB9 0000484E           3921              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003FEC  4EB9 00004B00           3922              JSR     PrintNot
00003FF2  4EB9 00004B5A           3923              JSR     LengthW
00003FF8  4EB9 00004B88           3924              JSR     PrintSpace
00003FFE  4EB9 000049A2           3925              JSR     PrintDataReg
00004004  4E75                    3926              RTS                     ; return to input to get more input
00004006                          3927  
00004006  7803                    3928  Not_W_M2    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004008  4EB9 0000484E           3929              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000400E  4EB9 00004B00           3930              JSR     PrintNot
00004014  4EB9 00004B5A           3931              JSR     LengthW
0000401A  4EB9 00004B88           3932              JSR     PrintSpace
00004020  4EB9 000049BA           3933              JSR     PrintIndirAddrReg
00004026  4E75                    3934              RTS                     ; return to input to get more input
00004028                          3935  
00004028  7803                    3936  Not_W_M3    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000402A  4EB9 0000484E           3937              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004030  4EB9 00004B00           3938              JSR     PrintNot
00004036  4EB9 00004B5A           3939              JSR     LengthW
0000403C  4EB9 00004B88           3940              JSR     PrintSpace
00004042  4EB9 000049C8           3941              JSR     PrintPostIncAddrReg
00004048  4E75                    3942              RTS                     ; return to input to get more input
0000404A                          3943  
0000404A  7803                    3944  Not_W_M4    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000404C  4EB9 0000484E           3945              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004052  4EB9 00004B00           3946              JSR     PrintNot
00004058  4EB9 00004B5A           3947              JSR     LengthW
0000405E  4EB9 00004B88           3948              JSR     PrintSpace
00004064  4EB9 000049D2           3949              JSR     PrintPreDeincAddrReg
0000406A  4E75                    3950              RTS                     ; return to input to get more input
0000406C                          3951  
0000406C  7803                    3952  Not_W_M7    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000406E  4EB9 0000484E           3953              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004074                          3954  
00004074  BABC 00000000           3955              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
0000407A  6700 0012               3956              BEQ     Not_W_xxxW
0000407E                          3957  
0000407E  BABC 00000001           3958              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00004084  6700 0022               3959              BEQ     Not_W_xxxL
00004088                          3960  
00004088  4EF9 00004846           3961              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid NOT EA mode
0000408E                          3962  
0000408E  4EB9 00004B00           3963  Not_W_xxxW  JSR     PrintNot
00004094  4EB9 00004B5A           3964              JSR     LengthW
0000409A  4EB9 00004B88           3965              JSR     PrintSpace
000040A0  4EB9 00004948           3966              JSR     PrintByteOrWord
000040A6  4E75                    3967              RTS                     ; return to input to get more input
000040A8                          3968  
000040A8  4EB9 00004B00           3969  Not_W_xxxL  JSR     PrintNot
000040AE  4EB9 00004B5A           3970              JSR     LengthW
000040B4  4EB9 00004B88           3971              JSR     PrintSpace
000040BA  4EB9 0000495E           3972              JSR     PrintLong
000040C0  4E75                    3973              RTS                     ; return to input to get more input
000040C2                          3974  
000040C2                          3975  
000040C2                          3976  *************************************************                Not_L_Opcode           *************************************************
000040C2                          3977  ; first 10 bit is (0100 0110 10## ####)
000040C2                          3978  Not_L_Opcode
000040C2  7803                    3979              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
000040C4  4EB9 0000484E           3980              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
000040CA                          3981  
000040CA  BABC 00000000           3982              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
000040D0  6700 0030               3983              BEQ     Not_L_M0
000040D4                          3984  
000040D4  BABC 00000002           3985              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
000040DA  6700 0048               3986              BEQ     Not_L_M2
000040DE                          3987  
000040DE  BABC 00000003           3988              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
000040E4  6700 0060               3989              BEQ     Not_L_M3
000040E8                          3990  
000040E8  BABC 00000004           3991              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
000040EE  6700 0078               3992              BEQ     Not_L_M4
000040F2                          3993  
000040F2  BABC 00000007           3994              CMP.L   #7,D5          ; if position 5-3 is 7 the EA mode is 7
000040F8  6700 0090               3995              BEQ     Not_L_M7
000040FC                          3996  
000040FC  4EF9 00004846           3997              JMP     InvalidOpcode  ; if it is not a valid NOT EA mode if it is not 0 2 3 4 7
00004102                          3998  
00004102  7803                    3999  Not_L_M0    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004104  4EB9 0000484E           4000              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000410A  4EB9 00004B00           4001              JSR     PrintNot
00004110  4EB9 00004B64           4002              JSR     LengthL
00004116  4EB9 00004B88           4003              JSR     PrintSpace
0000411C  4EB9 000049A2           4004              JSR     PrintDataReg
00004122  4E75                    4005              RTS                     ; return to input to get more input
00004124                          4006  
00004124  7803                    4007  Not_L_M2    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004126  4EB9 0000484E           4008              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000412C  4EB9 00004B00           4009              JSR     PrintNot
00004132  4EB9 00004B64           4010              JSR     LengthL
00004138  4EB9 00004B88           4011              JSR     PrintSpace
0000413E  4EB9 000049BA           4012              JSR     PrintIndirAddrReg
00004144  4E75                    4013              RTS                     ; return to input to get more input
00004146                          4014  
00004146  7803                    4015  Not_L_M3    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004148  4EB9 0000484E           4016              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000414E  4EB9 00004B00           4017              JSR     PrintNot
00004154  4EB9 00004B64           4018              JSR     LengthL
0000415A  4EB9 00004B88           4019              JSR     PrintSpace
00004160  4EB9 000049C8           4020              JSR     PrintPostIncAddrReg
00004166  4E75                    4021              RTS                     ; return to input to get more input
00004168                          4022  
00004168  7803                    4023  Not_L_M4    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000416A  4EB9 0000484E           4024              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004170  4EB9 00004B00           4025              JSR     PrintNot
00004176  4EB9 00004B64           4026              JSR     LengthL
0000417C  4EB9 00004B88           4027              JSR     PrintSpace
00004182  4EB9 000049D2           4028              JSR     PrintPreDeincAddrReg
00004188  4E75                    4029              RTS                     ; return to input to get more input
0000418A                          4030  
0000418A  7803                    4031  Not_L_M7    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000418C  4EB9 0000484E           4032              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004192                          4033  
00004192  BABC 00000000           4034              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00004198  6700 0012               4035              BEQ     Not_L_xxxW
0000419C                          4036  
0000419C  BABC 00000001           4037              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
000041A2  6700 0022               4038              BEQ     Not_L_xxxL
000041A6                          4039  
000041A6  4EF9 00004846           4040              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid NOT EA mode
000041AC                          4041  
000041AC  4EB9 00004B00           4042  Not_L_xxxW  JSR     PrintNot
000041B2  4EB9 00004B64           4043              JSR     LengthL
000041B8  4EB9 00004B88           4044              JSR     PrintSpace
000041BE  4EB9 00004948           4045              JSR     PrintByteOrWord
000041C4  4E75                    4046              RTS                     ; return to input to get more input
000041C6                          4047  
000041C6  4EB9 00004B00           4048  Not_L_xxxL  JSR     PrintNot
000041CC  4EB9 00004B64           4049              JSR     LengthL
000041D2  4EB9 00004B88           4050              JSR     PrintSpace
000041D8  4EB9 0000495E           4051              JSR     PrintLong
000041DE  4E75                    4052              RTS                     ; return to input to get more input
000041E0                          4053  
000041E0                          4054  
000041E0                          4055  *************************************************                MOVE_W_Opcode          *************************************************
000041E0                          4056  ; first four bit is (0011 #### #### ####)
000041E0                          4057  MOVE_W_Opcode
000041E0  7803                    4058              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
000041E2  4EB9 0000484E           4059              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination register
000041E8                          4060  
000041E8  2005                    4061              MOVE.L  D5,D0               ; D0 will hold the destination register
000041EA                          4062          ; D0 will hold the destination register (position 11-9)
000041EA                          4063  
000041EA  7803                    4064              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
000041EC  4EB9 0000484E           4065              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination mode
000041F2                          4066  
000041F2  BABC 00000001           4067              CMP.L   #1,D5               ; destination mode can't be mode one
000041F8  6700 064C               4068              BEQ     InvalidOpcode
000041FC                          4069  
000041FC  BABC 00000005           4070              CMP.L   #5,D5               ; destination mode can't be mode 5
00004202  6700 0642               4071              BEQ     InvalidOpcode
00004206                          4072  
00004206  BABC 00000006           4073              CMP.L   #6,D5               ; destination mode can't be mode 6
0000420C  6700 0638               4074              BEQ     InvalidOpcode
00004210                          4075  
00004210  BABC 00000007           4076              CMP.L   #7,D5               ; if destination mode is 7, we need to check the register. the lable is in
00004216  6700 0048               4077              BEQ     MOVE_W_DesM7_Check
0000421A                          4078  
0000421A                          4079  Continue_MOVE_W
0000421A  2205                    4080              MOVE.L  D5,D1               ; D1 will hold the destination mode
0000421C                          4081          ; D1 will hold the destination mode (position 8-6)
0000421C                          4082  
0000421C  7803                    4083              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000421E  4EB9 0000484E           4084              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the source mode
00004224                          4085  
00004224  BABC 00000000           4086              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
0000422A  6700 0040               4087              BEQ     MOVE_W_M0
0000422E                          4088  
0000422E  BABC 00000001           4089              CMP.L   #1,D5          ; if position 5-3 is 1 the EA is An
00004234  6700 0062               4090              BEQ     MOVE_W_M1
00004238                          4091  
00004238  BABC 00000002           4092              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
0000423E  6700 0084               4093              BEQ     MOVE_W_M2
00004242                          4094  
00004242  BABC 00000003           4095              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00004248  6700 00A6               4096              BEQ     MOVE_W_M3
0000424C                          4097  
0000424C  BABC 00000004           4098              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
00004252  6700 00C8               4099              BEQ     MOVE_W_M4
00004256                          4100  
00004256  BABC 00000007           4101              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode 7
0000425C  6700 0176               4102              BEQ     MOVE_W_M7
00004260                          4103  
00004260                          4104  MOVE_W_DesM7_Check
00004260  B0BC 00000001           4105              CMP.L   #1,D0               ; if destination mode is 7, and register is bigger than 1 it is invalid
00004266  6E00 05DE               4106              BGT     InvalidOpcode
0000426A                          4107  
0000426A  60AE                    4108              BRA     Continue_MOVE_W     ; if it is good then continue to decode move
0000426C                          4109  
0000426C  7803                    4110  MOVE_W_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000426E  4EB9 0000484E           4111              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004274  4EB9 00004AB0           4112              JSR     PrintMove
0000427A  4EB9 00004B5A           4113              JSR     LengthW
00004280  4EB9 00004B88           4114              JSR     PrintSpace
00004286  4EB9 000049A2           4115              JSR     PrintDataReg
0000428C                          4116  
0000428C  12EE 0025               4117              MOVE.B  37(A6),(A1)+             *,
00004290  4EB9 00004348           4118              JSR CheckDest
00004296  4E75                    4119              RTS                     ; return to input to get more input
00004298                          4120  
00004298  7803                    4121  MOVE_W_M1   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000429A  4EB9 0000484E           4122              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000042A0  4EB9 00004AB0           4123              JSR     PrintMove
000042A6  4EB9 00004B5A           4124              JSR     LengthW
000042AC  4EB9 00004B88           4125              JSR     PrintSpace
000042B2  4EB9 000049AE           4126              JSR     PrintAddrReg
000042B8                          4127  
000042B8  12EE 0025               4128              MOVE.B  37(A6),(A1)+             *,
000042BC  4EB9 00004348           4129              JSR CheckDest
000042C2  4E75                    4130              RTS                     ; return to input to get more input
000042C4                          4131  
000042C4  7803                    4132  MOVE_W_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000042C6  4EB9 0000484E           4133              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000042CC  4EB9 00004AB0           4134              JSR     PrintMove
000042D2  4EB9 00004B5A           4135              JSR     LengthW
000042D8  4EB9 00004B88           4136              JSR     PrintSpace
000042DE  4EB9 000049BA           4137              JSR     PrintIndirAddrReg
000042E4                          4138  
000042E4  12EE 0025               4139              MOVE.B  37(A6),(A1)+             *,
000042E8  4EB9 00004348           4140              JSR CheckDest
000042EE  4E75                    4141              RTS                     ; return to input to get more input
000042F0                          4142  
000042F0  7803                    4143  MOVE_W_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000042F2  4EB9 0000484E           4144              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000042F8  4EB9 00004AB0           4145              JSR     PrintMove
000042FE  4EB9 00004B5A           4146              JSR     LengthW
00004304  4EB9 00004B88           4147              JSR     PrintSpace
0000430A  4EB9 000049C8           4148              JSR     PrintPostIncAddrReg
00004310                          4149  
00004310  12EE 0025               4150              MOVE.B  37(A6),(A1)+             *,
00004314  4EB9 00004348           4151              JSR CheckDest
0000431A  4E75                    4152              RTS                     ; return to input to get more input
0000431C                          4153  
0000431C  7803                    4154  MOVE_W_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000431E  4EB9 0000484E           4155              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004324  4EB9 00004AB0           4156              JSR     PrintMove
0000432A  4EB9 00004B5A           4157              JSR     LengthW
00004330  4EB9 00004B88           4158              JSR     PrintSpace
00004336  4EB9 000049D2           4159              JSR     PrintPreDeincAddrReg
0000433C                          4160  
0000433C  12EE 0025               4161              MOVE.B  37(A6),(A1)+             *,
00004340  4EB9 00004348           4162              JSR CheckDest
00004346  4E75                    4163              RTS                     ; return to input to get more input
00004348                          4164  
00004348                          4165  CheckDest
00004348  B2BC 00000000           4166              CMP.L   #0,D1          ; if position 5-3 is 0 the EA is Dn
0000434E  6700 0036               4167              BEQ     DestDn
00004352                          4168  
00004352  B2BC 00000001           4169              CMP.L   #1,D1          ; if position 5-3 is 1 the EA is An
00004358  6700 04EC               4170              BEQ     InvalidOpcode
0000435C                          4171  
0000435C  B2BC 00000002           4172              CMP.L   #2,D1          ; if position 5-3 is 2 the EA is (An)
00004362  6700 002C               4173              BEQ     DestIndirAn
00004366                          4174  
00004366  B2BC 00000003           4175              CMP.L   #3,D1          ; if position 5-3 is 3 the EA is (An)+
0000436C  6700 002C               4176              BEQ     DestPostIncAn
00004370                          4177  
00004370  B2BC 00000004           4178              CMP.L   #4,D1          ; if position 5-3 is 4 the EA is -(An)
00004376  6700 002C               4179              BEQ     DestPreDeincAn
0000437A                          4180  
0000437A  B2BC 00000007           4181              CMP.L   #7,D1          ; if position 5-3 is 7 the EA is mode 7
00004380  6700 002C               4182              BEQ     DestWL
00004384  4E75                    4183              RTS
00004386                          4184  
00004386                          4185  DestDn
00004386  1A00                    4186              MOVE.B  D0,D5
00004388  4EB9 000049A2           4187              JSR     PrintDataReg
0000438E  4E75                    4188              RTS
00004390                          4189  
00004390                          4190  DestIndirAn
00004390  1A00                    4191              MOVE.B  D0,D5
00004392  4EB9 000049BA           4192              JSR     PrintIndirAddrReg
00004398  4E75                    4193              RTS
0000439A                          4194  
0000439A                          4195  DestPostIncAn
0000439A  1A00                    4196              MOVE.B  D0,D5
0000439C  4EB9 000049C8           4197              JSR     PrintPostIncAddrReg
000043A2  4E75                    4198              RTS
000043A4                          4199  
000043A4                          4200  DestPreDeincAn
000043A4  1A00                    4201              MOVE.B  D0,D5
000043A6  4EB9 000049D2           4202              JSR     PrintPreDeincAddrReg
000043AC  4E75                    4203              RTS
000043AE                          4204  
000043AE                          4205  DestWL
000043AE  B0BC 00000000           4206              CMP.L   #0,D0
000043B4  6700 000E               4207              BEQ     DestW
000043B8                          4208  
000043B8  B0BC 00000001           4209              CMP.L   #1,D0
000043BE  6700 000C               4210              BEQ     DestL
000043C2                          4211  
000043C2  4E75                    4212              RTS
000043C4                          4213  
000043C4                          4214  DestW
000043C4  4EB9 00004948           4215              JSR     PrintByteOrWord
000043CA  4E75                    4216              RTS
000043CC                          4217  
000043CC                          4218  DestL
000043CC  4EB9 0000495E           4219              JSR     PrintLong
000043D2  4E75                    4220              RTS
000043D4                          4221  
000043D4  7803                    4222  MOVE_W_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000043D6  4EB9 0000484E           4223              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000043DC                          4224  
000043DC  BABC 00000000           4225              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
000043E2  6700 001C               4226              BEQ     MOVE_W_xxxW
000043E6                          4227  
000043E6  BABC 00000001           4228              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
000043EC  6700 0034               4229              BEQ     MOVE_W_xxxL
000043F0                          4230  
000043F0  BABC 00000004           4231              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
000043F6  6700 004C               4232              BEQ     MOVE_W_data
000043FA                          4233  
000043FA  4EF9 00004846           4234              JMP     InvalidOpcode  ; for mode 7 if Source register is not 0 or 1 or 4, it is not a vaid NOT EA mode
00004400                          4235  
00004400  4EB9 00004AB0           4236  MOVE_W_xxxW JSR     PrintMove
00004406  4EB9 00004B5A           4237              JSR     LengthW
0000440C  4EB9 00004B88           4238              JSR     PrintSpace
00004412  4EB9 00004948           4239              JSR     PrintByteOrWord
00004418                          4240  
00004418  12EE 0025               4241              MOVE.B  37(A6),(A1)+             *,
0000441C  4EB8 4348               4242              JSR CheckDest
00004420  4E75                    4243              RTS                     ; return to input to get more input
00004422                          4244  
00004422  4EB9 00004AB0           4245  MOVE_W_xxxL JSR     PrintMove
00004428  4EB9 00004B5A           4246              JSR     LengthW
0000442E  4EB9 00004B88           4247              JSR     PrintSpace
00004434  4EB9 0000495E           4248              JSR     PrintLong
0000443A                          4249  
0000443A  12EE 0025               4250              MOVE.B  37(A6),(A1)+             *,
0000443E  4EB8 4348               4251              JSR CheckDest
00004442  4E75                    4252              RTS                     ; return to input to get more input
00004444                          4253  
00004444  4EB9 00004AB0           4254  MOVE_W_data JSR     PrintMove
0000444A  4EB9 00004B5A           4255              JSR     LengthW
00004450  4EB9 00004B88           4256              JSR     PrintSpace
00004456  4EB9 0000493C           4257              JSR     PrintImmediateData
0000445C                          4258  
0000445C  12EE 0025               4259              MOVE.B  37(A6),(A1)+             *,
00004460  4EB8 4348               4260              JSR CheckDest
00004464  4E75                    4261              RTS                     ; return to input to get more input
00004466                          4262  
00004466                          4263  *************************************************                MOVE_L_Opcode          *************************************************
00004466                          4264  ; first four bit is (0010 #### #### ####)
00004466                          4265  MOVE_L_Opcode
00004466  7803                    4266              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00004468  4EB9 0000484E           4267              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination register
0000446E                          4268  
0000446E  2005                    4269              MOVE.L  D5,D0               ; D0 will hold the destination register
00004470                          4270          ; D0 will hold the destination register (position 11-9)
00004470                          4271  
00004470  7803                    4272              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00004472  4EB9 0000484E           4273              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination mode
00004478                          4274  
00004478  BABC 00000001           4275              CMP.L   #1,D5               ; destination mode can't be mode one
0000447E  6700 03C6               4276              BEQ     InvalidOpcode
00004482                          4277  
00004482  BABC 00000005           4278              CMP.L   #5,D5               ; destination mode can't be mode 5
00004488  6700 03BC               4279              BEQ     InvalidOpcode
0000448C                          4280  
0000448C  BABC 00000006           4281              CMP.L   #6,D5               ; destination mode can't be mode 6
00004492  6700 03B2               4282              BEQ     InvalidOpcode
00004496                          4283  
00004496  BABC 00000007           4284              CMP.L   #7,D5               ; if destination mode is 7, we need to check the register. the lable is in
0000449C  6700 0048               4285              BEQ     MOVE_L_DesM7_Check
000044A0                          4286  
000044A0                          4287  Continue_MOVE_L
000044A0  2205                    4288              MOVE.L  D5,D1               ; D1 will hold the destination mode
000044A2                          4289          ; D1 will hold the destination mode (position 8-6)
000044A2                          4290  
000044A2  7803                    4291              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000044A4  4EB9 0000484E           4292              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the source mode
000044AA                          4293  
000044AA  BABC 00000000           4294              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
000044B0  6700 0040               4295              BEQ     MOVE_L_M0
000044B4                          4296  
000044B4  BABC 00000001           4297              CMP.L   #1,D5          ; if position 5-3 is 1 the EA is An
000044BA  6700 0060               4298              BEQ     MOVE_L_M1
000044BE                          4299  
000044BE  BABC 00000002           4300              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
000044C4  6700 0080               4301              BEQ     MOVE_L_M2
000044C8                          4302  
000044C8  BABC 00000003           4303              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
000044CE  6700 00A0               4304              BEQ     MOVE_L_M3
000044D2                          4305  
000044D2  BABC 00000004           4306              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
000044D8  6700 00C0               4307              BEQ     MOVE_L_M4
000044DC                          4308  
000044DC  BABC 00000007           4309              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode 7
000044E2  6700 00E0               4310              BEQ     MOVE_L_M7
000044E6                          4311  
000044E6                          4312  MOVE_L_DesM7_Check
000044E6  B0BC 00000001           4313              CMP.L   #1,D0               ; if destination mode is 7, and register is bigger than 1 it is invalid
000044EC  6E00 0358               4314              BGT     InvalidOpcode
000044F0                          4315  
000044F0  60AE                    4316              BRA     Continue_MOVE_L     ; if it is good then continue to decode move
000044F2                          4317  
000044F2  7803                    4318  MOVE_L_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000044F4  4EB9 0000484E           4319              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000044FA  4EB9 00004AB0           4320              JSR     PrintMove
00004500  4EB9 00004B64           4321              JSR     LengthL
00004506  4EB9 00004B88           4322              JSR     PrintSpace
0000450C  4EB9 000049A2           4323              JSR     PrintDataReg
00004512                          4324  
00004512  12EE 0025               4325              MOVE.B  37(A6),(A1)+             *,
00004516  4EB8 4348               4326              JSR CheckDest
0000451A  4E75                    4327              RTS                     ; return to input to get more input
0000451C                          4328  
0000451C  7803                    4329  MOVE_L_M1   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000451E  4EB9 0000484E           4330              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004524  4EB9 00004AB0           4331              JSR     PrintMove
0000452A  4EB9 00004B64           4332              JSR     LengthL
00004530  4EB9 00004B88           4333              JSR     PrintSpace
00004536  4EB9 000049AE           4334              JSR     PrintAddrReg
0000453C                          4335  
0000453C  12EE 0025               4336              MOVE.B  37(A6),(A1)+             *,
00004540  4EB8 4348               4337              JSR CheckDest
00004544  4E75                    4338              RTS                     ; return to input to get more input
00004546                          4339  
00004546  7803                    4340  MOVE_L_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004548  4EB9 0000484E           4341              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000454E  4EB9 00004AB0           4342              JSR     PrintMove
00004554  4EB9 00004B64           4343              JSR     LengthL
0000455A  4EB9 00004B88           4344              JSR     PrintSpace
00004560  4EB9 000049BA           4345              JSR     PrintIndirAddrReg
00004566                          4346  
00004566  12EE 0025               4347              MOVE.B  37(A6),(A1)+             *,
0000456A  4EB8 4348               4348              JSR CheckDest
0000456E  4E75                    4349              RTS                     ; return to input to get more input
00004570                          4350  
00004570  7803                    4351  MOVE_L_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004572  4EB9 0000484E           4352              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004578  4EB9 00004AB0           4353              JSR     PrintMove
0000457E  4EB9 00004B64           4354              JSR     LengthL
00004584  4EB9 00004B88           4355              JSR     PrintSpace
0000458A  4EB9 000049C8           4356              JSR     PrintPostIncAddrReg
00004590                          4357  
00004590  12EE 0025               4358              MOVE.B  37(A6),(A1)+             *,
00004594  4EB8 4348               4359              JSR CheckDest
00004598  4E75                    4360              RTS                     ; return to input to get more input
0000459A                          4361  
0000459A  7803                    4362  MOVE_L_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000459C  4EB9 0000484E           4363              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000045A2  4EB9 00004AB0           4364              JSR     PrintMove
000045A8  4EB9 00004B64           4365              JSR     LengthL
000045AE  4EB9 00004B88           4366              JSR     PrintSpace
000045B4  4EB9 000049D2           4367              JSR     PrintPreDeincAddrReg
000045BA                          4368  
000045BA  12EE 0025               4369              MOVE.B  37(A6),(A1)+             *,
000045BE  4EB8 4348               4370              JSR CheckDest
000045C2  4E75                    4371              RTS                     ; return to input to get more input
000045C4                          4372  
000045C4  7803                    4373  MOVE_L_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000045C6  4EB9 0000484E           4374              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000045CC                          4375  
000045CC  BABC 00000000           4376              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
000045D2  6700 001C               4377              BEQ     MOVE_L_xxxW
000045D6                          4378  
000045D6  BABC 00000001           4379              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
000045DC  6700 0034               4380              BEQ     MOVE_L_xxxL
000045E0                          4381  
000045E0  BABC 00000004           4382              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
000045E6  6700 004C               4383              BEQ     MOVE_L_data
000045EA                          4384  
000045EA  4EF9 00004846           4385              JMP     InvalidOpcode  ; for mode 7 if Source register is not 0 or 1 or 4, it is not a vaid NOT EA mode
000045F0                          4386  
000045F0  4EB9 00004AB0           4387  MOVE_L_xxxW JSR PrintMove
000045F6  4EB9 00004B64           4388              JSR LengthL
000045FC  4EB9 00004B88           4389              JSR     PrintSpace
00004602  4EB9 00004948           4390              JSR     PrintByteOrWord
00004608                          4391  
00004608  12EE 0025               4392              MOVE.B  37(A6),(A1)+             *,
0000460C  4EB8 4348               4393              JSR CheckDest
00004610  4E75                    4394              RTS                     ; return to input to get more input
00004612                          4395  
00004612  4EB9 00004AB0           4396  MOVE_L_xxxL JSR     PrintMove
00004618  4EB9 00004B64           4397              JSR     LengthL
0000461E  4EB9 00004B88           4398              JSR     PrintSpace
00004624  4EB9 0000495E           4399              JSR     PrintLong
0000462A                          4400  
0000462A  12EE 0025               4401              MOVE.B  37(A6),(A1)+             *,
0000462E  4EB8 4348               4402              JSR CheckDest
00004632  4E75                    4403              RTS                     ; return to input to get more input
00004634                          4404  
00004634  4EB9 00004AB0           4405  MOVE_L_data JSR     PrintMove
0000463A  4EB9 00004B64           4406              JSR     LengthL
00004640  4EB9 00004B88           4407              JSR     PrintSpace
00004646  4EB9 0000493C           4408              JSR     PrintImmediateData
0000464C                          4409  
0000464C  12EE 0025               4410              MOVE.B  37(A6),(A1)+             *,
00004650  4EB8 4348               4411              JSR CheckDest
00004654  4E75                    4412              RTS                     ; return to input to get more input
00004656                          4413  
00004656                          4414  
00004656                          4415  *************************************************                MOVE_B_Opcode          *************************************************
00004656                          4416  ; first four bit is (0001 #### #### ####)
00004656                          4417  MOVE_B_Opcode
00004656  7803                    4418              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00004658  4EB9 0000484E           4419              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination register
0000465E                          4420  
0000465E  2005                    4421              MOVE.L  D5,D0               ; D0 will hold the destination register
00004660                          4422          ; D0 will hold the destination register (position 11-9)
00004660                          4423  
00004660  7803                    4424              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00004662  4EB9 0000484E           4425              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination mode
00004668                          4426  
00004668  BABC 00000001           4427              CMP.L   #1,D5               ; destination mode can't be mode one
0000466E  6700 01D6               4428              BEQ     InvalidOpcode
00004672                          4429  
00004672  BABC 00000005           4430              CMP.L   #5,D5               ; destination mode can't be mode 5
00004678  6700 01CC               4431              BEQ     InvalidOpcode
0000467C                          4432  
0000467C  BABC 00000006           4433              CMP.L   #6,D5               ; destination mode can't be mode 6
00004682  6700 01C2               4434              BEQ     InvalidOpcode
00004686                          4435  
00004686  BABC 00000007           4436              CMP.L   #7,D5               ; if destination mode is 7, we need to check the register. the lable is in
0000468C  6700 0048               4437              BEQ     MOVE_B_DesM7_Check
00004690                          4438  
00004690                          4439  Continue_MOVE_B
00004690  2205                    4440              MOVE.L  D5,D1               ; D1 will hold the destination mode
00004692                          4441          ; D1 will hold the destination mode (position 8-6)
00004692                          4442  
00004692  7803                    4443              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00004694  4EB9 0000484E           4444              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the source mode
0000469A                          4445  
0000469A  BABC 00000000           4446              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
000046A0  6700 0040               4447              BEQ     MOVE_B_M0
000046A4                          4448  
000046A4  BABC 00000001           4449              CMP.L   #1,D5          ; if position 5-3 is 1 the EA is An
000046AA  6700 0060               4450              BEQ     MOVE_B_M1
000046AE                          4451  
000046AE  BABC 00000002           4452              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
000046B4  6700 0080               4453              BEQ     MOVE_B_M2
000046B8                          4454  
000046B8  BABC 00000003           4455              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
000046BE  6700 00A0               4456              BEQ     MOVE_B_M3
000046C2                          4457  
000046C2  BABC 00000004           4458              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
000046C8  6700 00C0               4459              BEQ     MOVE_B_M4
000046CC                          4460  
000046CC  BABC 00000007           4461              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode 7
000046D2  6700 00E0               4462              BEQ     MOVE_B_M7
000046D6                          4463  
000046D6                          4464  MOVE_B_DesM7_Check
000046D6  B0BC 00000001           4465              CMP.L   #1,D0               ; if destination mode is 7, and register is bigger than 1 it is invalid
000046DC  6E00 0168               4466              BGT     InvalidOpcode
000046E0                          4467  
000046E0  60AE                    4468              BRA     Continue_MOVE_B     ; if it is good then continue to decode move
000046E2                          4469  
000046E2  7803                    4470  MOVE_B_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000046E4  4EB9 0000484E           4471              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000046EA  4EB9 00004AB0           4472              JSR     PrintMove
000046F0  4EB9 00004B50           4473              JSR     LengthB
000046F6  4EB9 00004B88           4474              JSR     PrintSpace
000046FC  4EB9 000049A2           4475              JSR     PrintDataReg
00004702                          4476  
00004702  12EE 0025               4477              MOVE.B  37(A6),(A1)+             *,
00004706  4EB8 4348               4478              JSR CheckDest
0000470A  4E75                    4479              RTS                     ; return to input to get more input
0000470C                          4480  
0000470C  7803                    4481  MOVE_B_M1   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000470E  4EB9 0000484E           4482              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004714  4EB9 00004AB0           4483              JSR     PrintMove
0000471A  4EB9 00004B50           4484              JSR     LengthB
00004720  4EB9 00004B88           4485              JSR     PrintSpace
00004726  4EB9 000049AE           4486              JSR     PrintAddrReg
0000472C                          4487  
0000472C  12EE 0025               4488              MOVE.B  37(A6),(A1)+             *,
00004730  4EB8 4348               4489              JSR CheckDest
00004734  4E75                    4490              RTS                     ; return to input to get more input
00004736                          4491  
00004736  7803                    4492  MOVE_B_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004738  4EB9 0000484E           4493              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000473E  4EB9 00004AB0           4494              JSR     PrintMove
00004744  4EB9 00004B50           4495              JSR     LengthB
0000474A  4EB9 00004B88           4496              JSR     PrintSpace
00004750  4EB9 000049BA           4497              JSR     PrintIndirAddrReg
00004756                          4498  
00004756  12EE 0025               4499              MOVE.B  37(A6),(A1)+             *,
0000475A  4EB8 4348               4500              JSR CheckDest
0000475E  4E75                    4501              RTS                     ; return to input to get more input
00004760                          4502  
00004760  7803                    4503  MOVE_B_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004762  4EB9 0000484E           4504              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004768  4EB9 00004AB0           4505              JSR     PrintMove
0000476E  4EB9 00004B50           4506              JSR     LengthB
00004774  4EB9 00004B88           4507              JSR     PrintSpace
0000477A  4EB9 000049C8           4508              JSR     PrintPostIncAddrReg
00004780                          4509  
00004780  12EE 0025               4510              MOVE.B  37(A6),(A1)+             *,
00004784  4EB8 4348               4511              JSR CheckDest
00004788  4E75                    4512              RTS                     ; return to input to get more input
0000478A                          4513  
0000478A  7803                    4514  MOVE_B_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000478C  4EB9 0000484E           4515              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004792  4EB9 00004AB0           4516              JSR     PrintMove
00004798  4EB9 00004B50           4517              JSR     LengthB
0000479E  4EB9 00004B88           4518              JSR     PrintSpace
000047A4  4EB9 000049D2           4519              JSR     PrintPreDeincAddrReg
000047AA                          4520  
000047AA  12EE 0025               4521              MOVE.B  37(A6),(A1)+             *,
000047AE  4EB8 4348               4522              JSR CheckDest
000047B2  4E75                    4523              RTS                     ; return to input to get more input
000047B4                          4524  
000047B4  7803                    4525  MOVE_B_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000047B6  4EB9 0000484E           4526              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000047BC                          4527  
000047BC  BABC 00000000           4528              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
000047C2  6700 001C               4529              BEQ     MOVE_B_xxxW
000047C6                          4530  
000047C6  BABC 00000001           4531              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
000047CC  6700 0034               4532              BEQ     MOVE_B_xxxL
000047D0                          4533  
000047D0  BABC 00000004           4534              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
000047D6  6700 004C               4535              BEQ     MOVE_B_data
000047DA                          4536  
000047DA  4EF9 00004846           4537              JMP     InvalidOpcode  ; for mode 7 if Source register is not 0 or 1 or 4, it is not a vaid NOT EA mode
000047E0                          4538  
000047E0  4EB9 00004AB0           4539  MOVE_B_xxxW JSR     PrintMove
000047E6  4EB9 00004B50           4540              JSR     LengthB
000047EC  4EB9 00004B88           4541              JSR     PrintSpace
000047F2  4EB9 00004948           4542              JSR     PrintByteOrWord
000047F8                          4543  
000047F8  12EE 0025               4544              MOVE.B  37(A6),(A1)+             *,
000047FC  4EB8 4348               4545              JSR CheckDest
00004800  4E75                    4546              RTS                     ; return to input to get more input
00004802                          4547  
00004802  4EB9 00004AB0           4548  MOVE_B_xxxL JSR     PrintMove
00004808  4EB9 00004B50           4549              JSR     LengthB
0000480E  4EB9 00004B88           4550              JSR     PrintSpace
00004814  4EB9 00004948           4551              JSR     PrintByteOrWord
0000481A                          4552  
0000481A  12EE 0025               4553              MOVE.B  37(A6),(A1)+             *,
0000481E  4EB8 4348               4554              JSR CheckDest
00004822  4E75                    4555              RTS                     ; return to input to get more input
00004824                          4556  
00004824  4EB9 00004AB0           4557  MOVE_B_data JSR     PrintMove
0000482A  4EB9 00004B50           4558              JSR     LengthB
00004830  4EB9 00004B88           4559              JSR     PrintSpace
00004836  4EB9 0000493C           4560              JSR     PrintImmediateData
0000483C                          4561  
0000483C  12EE 0025               4562              MOVE.B  37(A6),(A1)+             *,
00004840  4EB8 4348               4563              JSR CheckDest
00004844  4E75                    4564              RTS                     ; return to input to get more input
00004846                          4565  
00004846                          4566  
00004846                          4567  *************************************************                Invalid Handle          *************************************************
00004846                          4568  
00004846                          4569  InvalidOpcode  ; don't use JSR to get here. Use JMP. If use JSR, RTS will not go back to input
00004846  4EB9 00004986           4570              JSR     NotFound        ; Call Output NotFound subroutine to print, since it did not match with any posible opcode
0000484C  4E75                    4571              RTS                     ; Return to input to get more input
0000484E                          4572  
0000484E                          4573  *************************************************                Subroutine             *************************************************
0000484E                          4574  
0000484E                          4575  GetNextD4bit ; Subroutine for get the next (D4) bit from (A4) into D5
0000484E                          4576               ; D4 should contain the number of loop you want to do
0000484E  7600                    4577              MOVE.L  #0,D3          ; initialize D3 to 0
00004850  7A00                    4578              MOVE.L  #0,D5          ; initialize D5 to 0, for storing result of bit from (A4)
00004852                          4579  
00004852  B803                    4580  LOOP        CMP.B   D3,D4          ; for number of iterations
00004854  6700 0012               4581              BEQ     next_code      ; if equal to each other, move on to next
00004858  5283                    4582              ADDQ.L  #1,D3          ; D3++, increment D3
0000485A                          4583  
0000485A  E38D                    4584              LSL.L   #1,D5          ; Shift left one
0000485C                          4585  
0000485C  E34A                    4586              LSL.W   #1,D2          ; shift left one
0000485E  6500 0004               4587              BCS     ADD1           ; If there is a carry bit add one to D5
00004862  60EE                    4588              BRA     LOOP
00004864                          4589  
00004864  5285                    4590  ADD1        ADDQ.L  #1,D5          ; add 1 to D5
00004866  60EA                    4591              BRA     LOOP           ; The goal is for D5 to hold the same bit as the first 4 bit of A4
00004868                          4592  
00004868  4E75                    4593  next_code   RTS         ; return from subroutine
0000486A                          4594  
0000486A                          4595  *-----------------------------------------------------------
0000486A                          4596  * Title      : Output
0000486A                          4597  * Written by :
0000486A                          4598  * Date       :
0000486A                          4599  * Description: output data
0000486A                          4600  *-----------------------------------------------------------
0000486A                          4601  *******     Using A6 for a list of alphabetical characters              ********
0000486A                          4602  
0000486A                          4603  Print
0000486A  12BC 0000               4604      MOVE.B   #$00,(A1)               *Terminator for trap 14 - "hey! stop printing!"
0000486E  2279 00004E18           4605      MOVE.L   PrintPointer,A1
00004874  103C 000E               4606      MOVE.B   #14,D0
00004878  4E4F                    4607      TRAP     #15
0000487A  4E75                    4608      RTS
0000487C                          4609  
0000487C                          4610  PrintLine
0000487C                          4611  
0000487C  12BC 0000               4612      MOVE.B   #$00,(A1)               *Terminator for trap 13 - "hey! stop printing!"
00004880  5239 00004E1C           4613      ADD.B    #1,PrintLines
00004886  1039 00004E1C           4614      MOVE.B   PrintLines,D0
0000488C  6000 0002               4615      BRA      TestWaited
00004890                          4616  
00004890                          4617  TestWaited
00004890  0400 001E               4618      SUB.B    #30,D0
00004894  B03C 0000               4619      CMP.B    #0,D0
00004898  6700 0008               4620      BEQ      WaitMore
0000489C  6D00 001A               4621      BLT      GoAheadAndPrint
000048A0  6EEE                    4622      BGT      TestWaited
000048A2                          4623  
000048A2                          4624  WaitMore
000048A2  43F9 00004DA2           4625      LEA      WaitForMore,A1
000048A8  103C 000E               4626      MOVE.B   #14,D0
000048AC  4E4F                    4627      TRAP     #15
000048AE  103C 0005               4628      MOVE.B   #5,D0
000048B2  4E4F                    4629      TRAP     #15
000048B4  6000 0002               4630      BRA      GoAheadAndPrint
000048B8                          4631  
000048B8                          4632  GoAheadAndPrint
000048B8  2279 00004E18           4633      MOVE.L   PrintPointer,A1
000048BE  103C 000D               4634      MOVE.B   #13,D0
000048C2  4E4F                    4635      TRAP     #15
000048C4  4E75                    4636      RTS
000048C6                          4637  
000048C6                          4638  ** Address
000048C6                          4639  PrintAddr
000048C6  2C0C                    4640      MOVE.L   A4,D6
000048C8  12EE 0000               4641      MOVE.B   0(A6),(A1)+             *68K always has address of 00XXXXXX, so we print 2 zeros
000048CC  12EE 0000               4642      MOVE.B   0(A6),(A1)+
000048D0                          4643  
000048D0  4EB9 0000497E           4644      JSR      RightTwenty             *3rd digit
000048D6  12F6 6000               4645      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
000048DA  2C0C                    4646      MOVE.L   A4,D6                   *Re-set the address
000048DC                          4647  
000048DC  E18E                    4648      LSL.L    #8,D6                   *4th digit
000048DE  E98E                    4649      LSL.L    #4,D6
000048E0  4EB9 00004974           4650      JSR      RightTwentyEight
000048E6  12F6 6000               4651      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
000048EA  2C0C                    4652      MOVE.L   A4,D6                   *Re-set the address
000048EC                          4653  
000048EC  E18E                    4654      LSL.L    #8,D6                   *5th digit
000048EE  E18E                    4655      LSL.L    #8,D6
000048F0  4EB9 00004974           4656      JSR      RightTwentyEight
000048F6  12F6 6000               4657      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
000048FA  2C0C                    4658      MOVE.L   A4,D6                   *Re-set the address
000048FC                          4659  
000048FC  E18E                    4660      LSL.L    #8,D6                   *6th digit
000048FE  E18E                    4661      LSL.L    #8,D6
00004900  E98E                    4662      LSL.L    #4,D6
00004902  4EB9 00004974           4663      JSR      RightTwentyEight
00004908  12F6 6000               4664      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
0000490C  2C0C                    4665      MOVE.L   A4,D6                   *Re-set the address
0000490E                          4666  
0000490E  E18E                    4667      LSL.L    #8,D6                   *7th digit
00004910  E18E                    4668      LSL.L    #8,D6
00004912  E18E                    4669      LSL.L    #8,D6
00004914  4EB9 00004974           4670      JSR      RightTwentyEight
0000491A  12F6 6000               4671      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
0000491E  2C0C                    4672      MOVE.L   A4,D6                   *Re-set the address
00004920                          4673  
00004920  E18E                    4674      LSL.L    #8,D6                   *8th digit
00004922  E18E                    4675      LSL.L    #8,D6
00004924  E18E                    4676      LSL.L    #8,D6
00004926  E98E                    4677      LSL.L    #4,D6
00004928  4EB9 00004974           4678      JSR      RightTwentyEight
0000492E  12F6 6000               4679      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
00004932                          4680  
00004932  4EB9 00004B6E           4681      JSR      PrintTab                *Add tab
00004938  4286                    4682      CLR.L    D6
0000493A  4E75                    4683      RTS
0000493C                          4684  
0000493C                          4685  PrintImmediateData
0000493C  12EE 0029               4686              MOVE.B  41(A6),(A1)+             *#
00004940  4EB9 0000495E           4687              JSR     PrintLong
00004946  4E75                    4688              RTS
00004948                          4689  
00004948                          4690  PrintByteOrWord
00004948  12EE 0026               4691      MOVE.B   38(A6),(A1)+        *$
0000494C  4EB8 486A               4692              JSR     Print
00004950                          4693  
00004950  321C                    4694              MOVE.W  (A4)+,D1
00004952  143C 0010               4695              MOVE.B  #16,D2
00004956  103C 000F               4696              MOVE.B  #15,D0
0000495A  4E4F                    4697              TRAP    #15
0000495C  4E75                    4698              RTS
0000495E                          4699  
0000495E                          4700  PrintLong
0000495E  12EE 0026               4701      MOVE.B   38(A6),(A1)+        *$
00004962  4EB8 486A               4702              JSR     Print
00004966                          4703  
00004966  321C                    4704              MOVE.W  (A4)+,D1
00004968  143C 0010               4705              MOVE.B  #16,D2
0000496C  103C 000F               4706              MOVE.B  #15,D0
00004970  4E4F                    4707              TRAP    #15
00004972  4E75                    4708              RTS
00004974                          4709  
00004974                          4710  RightTwentyEight
00004974  E08E                    4711      LSR.L    #8,D6
00004976  4EB9 0000497E           4712      JSR      RightTwenty
0000497C  4E75                    4713      RTS
0000497E                          4714  
0000497E                          4715  RightTwenty
0000497E  E08E                    4716      LSR.L    #8,D6
00004980  E08E                    4717      LSR.L    #8,D6
00004982  E88E                    4718      LSR.L    #4,D6
00004984  4E75                    4719      RTS
00004986                          4720  
00004986                          4721  ** General
00004986                          4722  NotFound
00004986  12EE 000D               4723      MOVE.B   13(A6),(A1)+        *D
0000498A  12EE 000A               4724      MOVE.B   10(A6),(A1)+        *A
0000498E  12EE 001D               4725      MOVE.B   29(A6),(A1)+        *T
00004992  12EE 000A               4726      MOVE.B   10(A6),(A1)+        *A
00004996  4EB9 00004B6E           4727              JSR      PrintTab
0000499C  12EE 0026               4728      MOVE.B   38(A6),(A1)+        *$
000049A0  4E75                    4729      RTS
000049A2                          4730  
000049A2                          4731  PrintDataReg
000049A2  12EE 000D               4732      MOVE.B   13(A6),(A1)+        *D
000049A6  4EB9 000049DC           4733      JSR      PrintRegNum
000049AC  4E75                    4734      RTS
000049AE                          4735  
000049AE                          4736  PrintAddrReg
000049AE  12EE 000A               4737      MOVE.B   10(A6),(A1)+        *A
000049B2  4EB9 000049DC           4738      JSR      PrintRegNum
000049B8  4E75                    4739      RTS
000049BA                          4740  
000049BA                          4741  PrintIndirAddrReg
000049BA  12EE 0027               4742              MOVE.B  39(A6),(A1)+             *(
000049BE  4EB8 49AE               4743              JSR     PrintAddrReg             *Ax
000049C2  12EE 0028               4744              MOVE.B  40(A6),(A1)+             *)
000049C6  4E75                    4745              RTS
000049C8                          4746  
000049C8                          4747  PrintPostIncAddrReg
000049C8  4EB8 49BA               4748              JSR     PrintIndirAddrReg        *(Ax)
000049CC  12EE 002A               4749              MOVE.B  42(A6),(A1)+             *+
000049D0  4E75                    4750              RTS
000049D2                          4751  
000049D2                          4752  PrintPreDeincAddrReg
000049D2  12EE 002B               4753              MOVE.B  43(A6),(A1)+             *-
000049D6  4EB8 49BA               4754              JSR     PrintIndirAddrReg        *(Ax)
000049DA  4E75                    4755              RTS
000049DC                          4756  
000049DC                          4757  PrintRegNum
000049DC  12F6 5000               4758      MOVE.B   (A6,D5),(A1)+
000049E0  4E75                    4759      RTS
000049E2                          4760  
000049E2                          4761  ** OPCodes
000049E2                          4762  PrintAdd
000049E2  12EE 000A               4763      MOVE.B   10(A6),(A1)+        *A
000049E6  12EE 000D               4764      MOVE.B   13(A6),(A1)+        *D
000049EA  12EE 000D               4765      MOVE.B   13(A6),(A1)+        *D
000049EE  4E75                    4766      RTS
000049F0                          4767  
000049F0                          4768  PrintAddA
000049F0  4EB8 49E2               4769      JSR      PrintAdd            *ADD
000049F4  12EE 000A               4770      MOVE.B   10(A6),(A1)+        *A
000049F8  4E75                    4771      RTS
000049FA                          4772  
000049FA                          4773  PrintAddQ
000049FA  4EB8 49E2               4774      JSR      PrintAdd            *ADD
000049FE  12EE 001A               4775      MOVE.B   26(A6),(A1)+        *Q
00004A02  4E75                    4776      RTS
00004A04                          4777  
00004A04                          4778  PrintAnd
00004A04  12EE 000A               4779      MOVE.B   10(A6),(A1)+        *A
00004A08  12EE 0017               4780      MOVE.B   23(A6),(A1)+        *N
00004A0C  12EE 000D               4781      MOVE.B   13(A6),(A1)+        *D
00004A10  4E75                    4782      RTS
00004A12                          4783  
00004A12                          4784  PrintASL
00004A12  12EE 000A               4785      MOVE.B   10(A6),(A1)+        *A
00004A16  12EE 001C               4786      MOVE.B   28(A6),(A1)+        *S
00004A1A  12EE 0015               4787      MOVE.B   21(A6),(A1)+        *L
00004A1E  4E75                    4788      RTS
00004A20                          4789  
00004A20                          4790  PrintASR
00004A20  12EE 000A               4791      MOVE.B   10(A6),(A1)+        *A
00004A24  12EE 001C               4792      MOVE.B   28(A6),(A1)+        *S
00004A28  12EE 001B               4793      MOVE.B   27(A6),(A1)+        *R
00004A2C  4E75                    4794      RTS
00004A2E                          4795  
00004A2E                          4796  PrintBEQ
00004A2E  12EE 000B               4797      MOVE.B   11(A6),(A1)+        *B
00004A32  12EE 000E               4798      MOVE.B   14(A6),(A1)+        *E
00004A36  12EE 001A               4799      MOVE.B   26(A6),(A1)+        *Q
00004A3A  4E75                    4800      RTS
00004A3C                          4801  
00004A3C                          4802  PrintBGT
00004A3C  12EE 000B               4803      MOVE.B   11(A6),(A1)+        *B
00004A40  12EE 0010               4804      MOVE.B   16(A6),(A1)+        *G
00004A44  12EE 001D               4805      MOVE.B   29(A6),(A1)+        *T
00004A48  4E75                    4806      RTS
00004A4A                          4807  
00004A4A                          4808  PrintBLE
00004A4A  12EE 000B               4809      MOVE.B   11(A6),(A1)+        *B
00004A4E  12EE 0015               4810      MOVE.B   21(A6),(A1)+        *L
00004A52  12EE 000E               4811      MOVE.B   14(A6),(A1)+        *E
00004A56  4E75                    4812      RTS
00004A58                          4813  
00004A58                          4814  PrintBRA
00004A58  12EE 000B               4815      MOVE.B   11(A6),(A1)+        *B
00004A5C  12EE 001B               4816      MOVE.B   27(A6),(A1)+        *R
00004A60  12EE 000A               4817      MOVE.B   10(A6),(A1)+        *A
00004A64  4E75                    4818      RTS
00004A66                          4819  
00004A66                          4820  PrintDivu
00004A66  12EE 000D               4821              MOVE.B   13(A6),(A1)+            *D
00004A6A  12EE 0012               4822              MOVE.B   18(A6),(A1)+            *I
00004A6E  12EE 001F               4823              MOVE.B   31(A6),(A1)+            *V
00004A72  12EE 001E               4824              MOVE.B   30(A6),(A1)+            *U
00004A76  4E75                    4825              RTS
00004A78                          4826  
00004A78                          4827  PrintJSR
00004A78  12EE 0013               4828      MOVE.B   19(A6),(A1)+        *J
00004A7C  12EE 001C               4829      MOVE.B   28(A6),(A1)+        *S
00004A80  12EE 001B               4830      MOVE.B   27(A6),(A1)+        *R
00004A84  4E75                    4831      RTS
00004A86                          4832  
00004A86                          4833  PrintLEA
00004A86  12EE 0015               4834      MOVE.B   21(A6),(A1)+        *L
00004A8A  12EE 000E               4835      MOVE.B   14(A6),(A1)+        *E
00004A8E  12EE 000A               4836      MOVE.B   10(A6),(A1)+        *A
00004A92  4E75                    4837      RTS
00004A94                          4838  
00004A94                          4839  PrintLSL
00004A94  12EE 0015               4840      MOVE.B   21(A6),(A1)+        *L
00004A98  12EE 001C               4841      MOVE.B   28(A6),(A1)+        *S
00004A9C  12EE 0015               4842      MOVE.B   21(A6),(A1)+        *L
00004AA0  4E75                    4843      RTS
00004AA2                          4844  
00004AA2                          4845  PrintLSR
00004AA2  12EE 0015               4846      MOVE.B   21(A6),(A1)+        *L
00004AA6  12EE 001C               4847      MOVE.B   28(A6),(A1)+        *S
00004AAA  12EE 001B               4848      MOVE.B   27(A6),(A1)+        *R
00004AAE  4E75                    4849      RTS
00004AB0                          4850  
00004AB0                          4851  PrintMove
00004AB0  12EE 0016               4852      MOVE.B   22(A6),(A1)+        *M
00004AB4  12EE 0018               4853      MOVE.B   24(A6),(A1)+        *O
00004AB8  12EE 001F               4854      MOVE.B   31(A6),(A1)+        *V
00004ABC  12EE 000E               4855      MOVE.B   14(A6),(A1)+        *E
00004AC0  4E75                    4856      RTS
00004AC2                          4857  
00004AC2                          4858  PrintMoveA
00004AC2  4EB8 4AB0               4859      JSR      PrintMove           *MOVE
00004AC6  12EE 000A               4860      MOVE.B   10(A6),(A1)+        *A
00004ACA  4E75                    4861      RTS
00004ACC                          4862  
00004ACC                          4863  PrintMoveQ
00004ACC  4EB8 4AB0               4864      JSR      PrintMove           *MOVE
00004AD0  12EE 001A               4865      MOVE.B   26(A6),(A1)+        *Q
00004AD4  4E75                    4866      RTS
00004AD6                          4867  
00004AD6                          4868  PrintMoveM
00004AD6  4EB8 4AB0               4869      JSR      PrintMove           *MOVE
00004ADA  12EE 0016               4870      MOVE.B   22(A6),(A1)+        *M
00004ADE  4E75                    4871      RTS
00004AE0                          4872  
00004AE0                          4873  PrintMuls
00004AE0  12EE 0016               4874              MOVE.B  22(A6),(A1)+             *M
00004AE4  12EE 001E               4875              MOVE.B  30(A6),(A1)+             *U
00004AE8  12EE 0015               4876              MOVE.B  21(A6),(A1)+             *L
00004AEC  12EE 001C               4877              MOVE.B  28(A6),(A1)+             *S
00004AF0  4E75                    4878              RTS
00004AF2                          4879  
00004AF2                          4880  PrintNOP
00004AF2  12EE 0017               4881      MOVE.B   23(A6),(A1)+        *N
00004AF6  12EE 0018               4882      MOVE.B   24(A6),(A1)+        *O
00004AFA  12EE 0019               4883      MOVE.B   25(A6),(A1)+        *P
00004AFE  4E75                    4884      RTS
00004B00                          4885  
00004B00                          4886  PrintNot
00004B00  12EE 0017               4887      MOVE.B   23(A6),(A1)+         *N
00004B04  12EE 0018               4888      MOVE.B   24(A6),(A1)+         *O
00004B08  12EE 001D               4889      MOVE.B   29(A6),(A1)+         *T
00004B0C  4E75                    4890      RTS
00004B0E                          4891  
00004B0E                          4892  PrintOr
00004B0E  12EE 0018               4893      MOVE.B   24(A6),(A1)+        *O
00004B12  12EE 001B               4894      MOVE.B   27(A6),(A1)+        *R
00004B16  4E75                    4895      RTS
00004B18                          4896  
00004B18                          4897  PrintROL
00004B18  12EE 001B               4898      MOVE.B   27(A6),(A1)+        *R
00004B1C  12EE 0018               4899      MOVE.B   24(A6),(A1)+        *O
00004B20  12EE 0015               4900      MOVE.B   21(A6),(A1)+        *L
00004B24  4E75                    4901      RTS
00004B26                          4902  
00004B26                          4903  PrintROR
00004B26  12EE 001B               4904      MOVE.B   27(A6),(A1)+        *R
00004B2A  12EE 0018               4905      MOVE.B   24(A6),(A1)+        *O
00004B2E  12EE 001B               4906      MOVE.B   27(A6),(A1)+        *R
00004B32  4E75                    4907      RTS
00004B34                          4908  
00004B34                          4909  PrintRTS
00004B34  12EE 001B               4910      MOVE.B   27(A6),(A1)+        *R
00004B38  12EE 001D               4911      MOVE.B   29(A6),(A1)+        *T
00004B3C  12EE 001C               4912      MOVE.B   28(A6),(A1)+        *S
00004B40  4E75                    4913      RTS
00004B42                          4914  
00004B42                          4915  PrintSub
00004B42  12EE 001C               4916      MOVE.B   28(A6),(A1)+        *S
00004B46  12EE 001E               4917      MOVE.B   30(A6),(A1)+        *U
00004B4A  12EE 000B               4918      MOVE.B   11(A6),(A1)+        *B
00004B4E  4E75                    4919      RTS
00004B50                          4920  
00004B50                          4921  ** Sizes
00004B50                          4922  LengthB                          *Prints .B
00004B50  12EE 0024               4923      MOVE.B   36(A6),(A1)+        *.
00004B54  12EE 000B               4924      MOVE.B   11(A6),(A1)+        *B
00004B58  4E75                    4925      RTS
00004B5A                          4926  
00004B5A                          4927  LengthW                          *Prints .W
00004B5A  12EE 0024               4928      MOVE.B   36(A6),(A1)+        *.
00004B5E  12EE 0020               4929      MOVE.B   32(A6),(A1)+        *W
00004B62  4E75                    4930      RTS
00004B64                          4931  
00004B64                          4932  LengthL                          *Prints .L
00004B64  12EE 0024               4933      MOVE.B   36(A6),(A1)+        *.
00004B68  12EE 0015               4934      MOVE.B   21(A6),(A1)+        *L
00004B6C  4E75                    4935      RTS
00004B6E                          4936  
00004B6E                          4937  ** Other
00004B6E                          4938  PrintTab
00004B6E  4EB9 00004B88           4939      JSR      PrintSpace
00004B74  4EB9 00004B88           4940      JSR      PrintSpace
00004B7A  4EB9 00004B88           4941      JSR      PrintSpace
00004B80  4EB9 00004B88           4942      JSR      PrintSpace
00004B86  4E75                    4943      RTS
00004B88                          4944  
00004B88                          4945  PrintSpace
00004B88  12EE 002C               4946      MOVE.B   44(A6),(A1)+
00004B8C  4E75                    4947      RTS
00004B8E                          4948  
00004B8E  FFFF FFFF               4949      SIMHALT             ; halt simulator
00004B92                          4950  
00004B92                          4951  * Put variables and constants here
00004B92  =0000000D               4952  CR           EQU     $0D
00004B92  =0000000A               4953  LF           EQU     $0A
00004B92                          4954  
00004B92                          4955  ;EmptyChar    DC.W    '', 0
00004B92                          4956  ;SpaceChar    DC.W ' ', 0
00004B92                          4957  
00004B92  =00000500               4958  EndAddr      EQU     $500                        ; store end address, avoid overwriting
00004B92  =00000600               4959  StartAddr    EQU     $600                        ; store start address, avoid overwriting
00004B92  =00000400               4960  Cur4bits     EQU     $400                        ; store first four bits
00004B92                          4961  
00004B92                          4962  * introduction message
00004B92= 2A 2A 2A 2A 2A 2A ...   4963  IntroMsg     DC.B    '**************************************************************',CR,LF
00004BD2= 2A 20 20 54 45 41 ...   4964               DC.B    '*  TEAM 9 DISASSEMBLER',CR,LF,CR,LF
00004BEC= 2A 20 20 4D 65 6D ...   4965               DC.B    '*  Members: MARIANA HUYNH, HANNY LONG, ALEX VAN MATRE',CR,LF,CR,LF
00004C25= 2A 2A 2A 2A 2A 2A ...   4966               DC.B    '*************************************************************',CR,LF,CR,LF,0
00004C67                          4967  
00004C67= 45 6E 74 65 72 20 ...   4968  AskStartAddr DC.B 'Enter starting address in hexadecimal:', CR, LF, 0
00004C90                          4969  
00004C90= 45 6E 74 65 72 20 ...   4970  AskEndAddr   DC.B 'Enter ending address in hexadecimal:', CR, LF, 0
00004CB7                          4971  
00004CB7= 45 6E 74 65 72 20 ...   4972  AskRestartOrExitMsg DC.B 'Enter 0 to exit program or 1 to restart the program: ', 0
00004CED                          4973  
00004CED                          4974  * Error message
00004CED= 49 6E 76 61 6C 69 ...   4975  InvalidStartMessage  DC.B 'Invalid Start Address: input not valid hex value', CR, LF, 0
00004D20= 49 6E 76 61 6C 69 ...   4976  InvalidEndMessage  DC.B 'Invalid End Address: input not valid hex value or End <= Start', CR, LF, 0
00004D61                          4977  
00004D61                          4978  
00004D61                          4979  * Hex Srting Numbers
00004D62= 3000 0000               4980  Str0                       DC.W '0', 0
00004D66= 3100 0000               4981  Str1                       DC.W '1', 0
00004D6A= 3200 0000               4982  Str2                       DC.W '2', 0
00004D6E= 3300 0000               4983  Str3                       DC.W '3', 0
00004D72= 3400 0000               4984  Str4                       DC.W '4', 0
00004D76= 3500 0000               4985  Str5                       DC.W '5', 0
00004D7A= 3600 0000               4986  Str6                       DC.W '6', 0
00004D7E= 3700 0000               4987  Str7                       DC.W '7', 0
00004D82= 3800 0000               4988  Str8                       DC.W '8', 0
00004D86= 3900 0000               4989  Str9                       DC.W '9', 0
00004D8A                          4990  
00004D8A                          4991  * Hex String Letters
00004D8A= 4100 0000               4992  StrA                       DC.W 'A', 0
00004D8E= 4200 0000               4993  StrB                       DC.W 'B', 0
00004D92= 4300 0000               4994  StrC                       DC.W 'C', 0
00004D96= 4400 0000               4995  StrD                       DC.W 'D', 0
00004D9A= 4500 0000               4996  StrE                       DC.W 'E', 0
00004D9E= 4600 0000               4997  StrF                       DC.W 'F', 0
00004DA2                          4998  
00004DA2                          4999  
00004DA2= 4D 61 78 20 6E 75 ...   5000  WaitForMore     DC.B   'Max number of lines on screen. Press enter to continue dissassembling', CR, LF, 0
00004DEA= 30 31 32 33 34 35 ...   5001  Values          DC.B   '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','.',',','$','(',')','#','+','-',' '
00004E17                          5002  *                       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44
00004E18= 00003500                5003  PrintPointer    DC.L   $3500
00004E1C= 00004500                5004  PrintLines      DC.L   $4500
00004E20= 00005500                5005  CurDecode   DC.L   $5500
00004E24                          5006  
00004E24                          5007                END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD1                4864
ADD_B_DESEA         1C3E
ADD_B_DESEA_M2      1C74
ADD_B_DESEA_M3      1CA6
ADD_B_DESEA_M4      1CD4
ADD_B_DESEA_M7      1D06
ADD_B_DESEA_XXXL    1D52
ADD_B_DESEA_XXXW    1D28
ADD_B_SRCEA         16D4
ADD_B_SRCEA_DATA    187C
ADD_B_SRCEA_M0      171E
ADD_B_SRCEA_M1      174C
ADD_B_SRCEA_M2      177A
ADD_B_SRCEA_M3      17A8
ADD_B_SRCEA_M4      17D6
ADD_B_SRCEA_M7      1804
ADD_B_SRCEA_XXXL    1856
ADD_B_SRCEA_XXXW    1830
ADD_L_DESEA         1EBA
ADD_L_DESEA_M2      1EF0
ADD_L_DESEA_M3      1F22
ADD_L_DESEA_M4      1F50
ADD_L_DESEA_M7      1F82
ADD_L_DESEA_XXXL    1FCE
ADD_L_DESEA_XXXW    1FA4
ADD_L_SRCEA         1A70
ADD_L_SRCEA_DATA    1C18
ADD_L_SRCEA_M0      1ABA
ADD_L_SRCEA_M1      1AE8
ADD_L_SRCEA_M2      1B16
ADD_L_SRCEA_M3      1B44
ADD_L_SRCEA_M4      1B72
ADD_L_SRCEA_M7      1BA0
ADD_L_SRCEA_XXXL    1BF2
ADD_L_SRCEA_XXXW    1BCC
ADD_OPCODE          1680
ADD_W_DESEA         1D7C
ADD_W_DESEA_M2      1DB2
ADD_W_DESEA_M3      1DE4
ADD_W_DESEA_M4      1E12
ADD_W_DESEA_M7      1E44
ADD_W_DESEA_XXXL    1E90
ADD_W_DESEA_XXXW    1E66
ADD_W_SRCEA         18A2
ADD_W_SRCEA_DATA    1A4A
ADD_W_SRCEA_M0      18EC
ADD_W_SRCEA_M1      191A
ADD_W_SRCEA_M2      1948
ADD_W_SRCEA_M3      1976
ADD_W_SRCEA_M4      19A4
ADD_W_SRCEA_M7      19D2
ADD_W_SRCEA_XXXL    1A24
ADD_W_SRCEA_XXXW    19FE
AND_B_DESEA         2518
AND_B_DESEA_M2      254E
AND_B_DESEA_M3      2580
AND_B_DESEA_M4      25B2
AND_B_DESEA_M7      25E4
AND_B_DESEA_XXXL    2630
AND_B_DESEA_XXXW    2606
AND_B_SRCEA         2056
AND_B_SRCEA_DATA    21C6
AND_B_SRCEA_M0      2096
AND_B_SRCEA_M2      20C4
AND_B_SRCEA_M3      20F2
AND_B_SRCEA_M4      2120
AND_B_SRCEA_M7      214E
AND_B_SRCEA_XXXL    21A0
AND_B_SRCEA_XXXW    217A
AND_L_DESEA         279C
AND_L_DESEA_M2      27D2
AND_L_DESEA_M3      2804
AND_L_DESEA_M4      2836
AND_L_DESEA_M7      2868
AND_L_DESEA_XXXL    28B4
AND_L_DESEA_XXXW    288A
AND_L_SRCEA         2382
AND_L_SRCEA_DATA    24F2
AND_L_SRCEA_M0      23C2
AND_L_SRCEA_M2      23F0
AND_L_SRCEA_M3      241E
AND_L_SRCEA_M4      244C
AND_L_SRCEA_M7      247A
AND_L_SRCEA_XXXL    24CC
AND_L_SRCEA_XXXW    24A6
AND_W_DESEA         265A
AND_W_DESEA_M2      2690
AND_W_DESEA_M3      26C2
AND_W_DESEA_M4      26F4
AND_W_DESEA_M7      2726
AND_W_DESEA_XXXL    2772
AND_W_DESEA_XXXW    2748
AND_W_SRCEA         21EC
AND_W_SRCEA_DATA    235C
AND_W_SRCEA_M0      222C
AND_W_SRCEA_M2      225A
AND_W_SRCEA_M3      2288
AND_W_SRCEA_M4      22B6
AND_W_SRCEA_M7      22E4
AND_W_SRCEA_XXXL    2336
AND_W_SRCEA_XXXW    2310
ASCIITOHEX          1088
ASKENDADDR          4C90
ASKEXITORRESTART    11A4
ASKRESTARTOREXITMSG  4CB7
ASKSTARTADDR        4C67
ASL_COUNT_OPCODE    130C
ASL_MEMSHIFT        158E
ASL_MEMSHIFT_MODE_2  15C4
ASL_MEMSHIFT_MODE_3  15E6
ASL_MEMSHIFT_MODE_4  1608
ASL_MEMSHIFT_MODE_7  162A
ASL_MEMSHIFT_XXXL   1666
ASL_MEMSHIFT_XXXW   164C
ASL_OUTPUT_BYTE     1360
ASL_OUTPUT_LONG     1388
ASL_OUTPUT_SIZE     133C
ASL_OUTPUT_WORD     1374
ASL_REGISTER_OPCODE  143C
BCC_16BIT_DISP      3642
BCC_32BIT_DISP      3648
BCC_DISPLACEMENT    3624
BCC_OPCODE          35BE
BEQ_OPCODE          3618
BGT_OPCODE          35F4
BLE_OPCODE          3600
BRA_OPCODE          360C
CHECKCOUNT          142C
CHECKDEST           4348
CLEAREVERYTHING     11C8
CONTINUE_MOVE_B     4690
CONTINUE_MOVE_L     44A0
CONTINUE_MOVE_W     421A
CONVERTFORLOOP      108E
CONVERTLOWERCASE    10D4
CONVERTNUM          10CA
CONVERTUPPERCASE    10DE
CR                  D
CUR4BITS            400
CURDECODE           4E20
D0_TO_8             1438
DECODINGMACHINECODE  121E
DESTDN              4386
DESTINDIRAN         4390
DESTL               43CC
DESTPOSTINCAN       439A
DESTPREDEINCAN      43A4
DESTW               43C4
DESTWL              43AE
DISPINVALIDENDERROR  1178
DISPINVALIDSTARTERROR  116A
DIVU_L              3C68
DIVU_L_DATA         3DD8
DIVU_L_M0           3CA8
DIVU_L_M2           3CD6
DIVU_L_M3           3D04
DIVU_L_M4           3D32
DIVU_L_M7           3D60
DIVU_L_XXXL         3DB2
DIVU_L_XXXW         3D8C
DIVU_W_DATA         3598
DIVU_W_M0           3468
DIVU_W_M2           3496
DIVU_W_M3           34C4
DIVU_W_M4           34F2
DIVU_W_M7           3520
DIVU_W_OPCODE       340C
DIVU_W_XXXL         3572
DIVU_W_XXXW         354C
ENDADDR             500
GETENDADDR          105E
GETNEXTD4BIT        484E
GETSTARTADDR        1032
GOAHEADANDPRINT     48B8
INTROMSG            4B92
INVALIDADDRHANDLER  113A
INVALIDENDHANDLER   1158
INVALIDENDMESSAGE   4D20
INVALIDOPCODE       4846
INVALIDSTARTHANDLER  1146
INVALIDSTARTMESSAGE  4CED
JSR_M2              3E20
JSR_M7              3E3C
JSR_OPCODE          3DFE
JSR_XXXL            3E72
JSR_XXXW            3E5E
LEA_M2_OPCODE       36F0
LEA_M7_OPCODE       3718
LEA_OPCODE          36BA
LEA_XXXL_OPCODE     375A
LEA_XXXW_OPCODE     373A
LENGTHB             4B50
LENGTHL             4B64
LENGTHW             4B5A
LF                  A
LOADADDR            1126
LOOP                4852
LSL_ASL_OPCODE      12A4
LSL_COUNT_OPCODE    139C
LSL_MEMSHIFT        1496
LSL_MEMSHIFT_MODE_2  14CC
LSL_MEMSHIFT_MODE_3  14EE
LSL_MEMSHIFT_MODE_4  1510
LSL_MEMSHIFT_MODE_7  1532
LSL_MEMSHIFT_XXXL   1574
LSL_MEMSHIFT_XXXW   1554
LSL_OUTPUT_BYTE     13F0
LSL_OUTPUT_LONG     1418
LSL_OUTPUT_SIZE     13CC
LSL_OUTPUT_WORD     1404
LSL_REGISTER_OPCODE  145C
MEMSHIFT            147C
MOVEM_M2R_L         39FC
MOVEM_M2R_L_M2      3A28
MOVEM_M2R_L_M4      3A4E
MOVEM_M2R_L_M7      3A74
MOVEM_M2R_L_XXXL    3AB4
MOVEM_M2R_L_XXXW    3A96
MOVEM_M2R_W         3926
MOVEM_M2R_W_M2      3952
MOVEM_M2R_W_M4      3978
MOVEM_M2R_W_M7      399E
MOVEM_M2R_W_XXXL    39DE
MOVEM_M2R_W_XXXW    39C0
MOVEM_R2M_L         3850
MOVEM_R2M_L_M2      387C
MOVEM_R2M_L_M4      38A2
MOVEM_R2M_L_M7      38C8
MOVEM_R2M_L_XXXL    3908
MOVEM_R2M_L_XXXW    38EA
MOVEM_R2M_W         377A
MOVEM_R2M_W_M2      37A6
MOVEM_R2M_W_M4      37CC
MOVEM_R2M_W_M7      37F2
MOVEM_R2M_W_XXXL    3832
MOVEM_R2M_W_XXXW    3814
MOVE_B_DATA         4824
MOVE_B_DESM7_CHECK  46D6
MOVE_B_M0           46E2
MOVE_B_M1           470C
MOVE_B_M2           4736
MOVE_B_M3           4760
MOVE_B_M4           478A
MOVE_B_M7           47B4
MOVE_B_OPCODE       4656
MOVE_B_XXXL         4802
MOVE_B_XXXW         47E0
MOVE_L_DATA         4634
MOVE_L_DESM7_CHECK  44E6
MOVE_L_M0           44F2
MOVE_L_M1           451C
MOVE_L_M2           4546
MOVE_L_M3           4570
MOVE_L_M4           459A
MOVE_L_M7           45C4
MOVE_L_OPCODE       4466
MOVE_L_XXXL         4612
MOVE_L_XXXW         45F0
MOVE_W_DATA         4444
MOVE_W_DESM7_CHECK  4260
MOVE_W_M0           426C
MOVE_W_M1           4298
MOVE_W_M2           42C4
MOVE_W_M3           42F0
MOVE_W_M4           431C
MOVE_W_M7           43D4
MOVE_W_OPCODE       41E0
MOVE_W_XXXL         4422
MOVE_W_XXXW         4400
MULS_L              3AD2
MULS_L_DATA         3C42
MULS_L_M0           3B12
MULS_L_M2           3B40
MULS_L_M3           3B6E
MULS_L_M4           3B9C
MULS_L_M7           3BCA
MULS_L_XXXL         3C1C
MULS_L_XXXW         3BF6
MULS_W              28DE
MULS_W_AND_OPCODE   1FF8
MULS_W_DATA         2A4E
MULS_W_M0           291E
MULS_W_M2           294C
MULS_W_M3           297A
MULS_W_M4           29A8
MULS_W_M7           29D6
MULS_W_XXXL         2A28
MULS_W_XXXW         2A02
NEEDMOREBIT         364E
NEXT_CODE           4868
NOTFOUND            4986
NOT_B_M0            3EC6
NOT_B_M2            3EE8
NOT_B_M3            3F0A
NOT_B_M4            3F2C
NOT_B_M7            3F4E
NOT_B_OPCODE        3E86
NOT_B_XXXL          3F8A
NOT_B_XXXW          3F70
NOT_L_M0            4102
NOT_L_M2            4124
NOT_L_M3            4146
NOT_L_M4            4168
NOT_L_M7            418A
NOT_L_OPCODE        40C2
NOT_L_XXXL          41C6
NOT_L_XXXW          41AC
NOT_W_M0            3FE4
NOT_W_M2            4006
NOT_W_M3            4028
NOT_W_M4            404A
NOT_W_M7            406C
NOT_W_OPCODE        3FA4
NOT_W_XXXL          40A8
NOT_W_XXXW          408E
PRINT               486A
PRINTADD            49E2
PRINTADDA           49F0
PRINTADDQ           49FA
PRINTADDR           48C6
PRINTADDRREG        49AE
PRINTAND            4A04
PRINTASL            4A12
PRINTASR            4A20
PRINTBEQ            4A2E
PRINTBGT            4A3C
PRINTBLE            4A4A
PRINTBRA            4A58
PRINTBYTEORWORD     4948
PRINTDATAREG        49A2
PRINTDIVU           4A66
PRINTIMMEDIATEDATA  493C
PRINTINDIRADDRREG   49BA
PRINTJSR            4A78
PRINTLEA            4A86
PRINTLINE           487C
PRINTLINES          4E1C
PRINTLONG           495E
PRINTLSL            4A94
PRINTLSR            4AA2
PRINTMOVE           4AB0
PRINTMOVEA          4AC2
PRINTMOVEM          4AD6
PRINTMOVEQ          4ACC
PRINTMULS           4AE0
PRINTNOP            4AF2
PRINTNOT            4B00
PRINTOR             4B0E
PRINTPOINTER        4E18
PRINTPOSTINCADDRREG  49C8
PRINTPREDEINCADDRREG  49D2
PRINTREGNUM         49DC
PRINTROL            4B18
PRINTROR            4B26
PRINTRTS            4B34
PRINTSPACE          4B88
PRINTSUB            4B42
PRINTTAB            4B6E
PUTENDTOMEMORY      111E
PUTSTARTTOMEMORY    1116
QUIT                1218
READNEXTLOOP        1188
READNEXTLOOPSTART   1186
RIGHTTWENTY         497E
RIGHTTWENTYEIGHT    4974
SAVESTART           10E8
START               1000
STARTADDR           600
STR0                4D62
STR1                4D66
STR2                4D6A
STR3                4D6E
STR4                4D72
STR5                4D76
STR6                4D7A
STR7                4D7E
STR8                4D82
STR9                4D86
STRA                4D8A
STRB                4D8E
STRC                4D92
STRD                4D96
STRE                4D9A
STRF                4D9E
SUB_B_DESEA         3032
SUB_B_DESEA_M2      3068
SUB_B_DESEA_M3      309A
SUB_B_DESEA_M4      30CC
SUB_B_DESEA_M7      30FE
SUB_B_DESEA_XXXL    3154
SUB_B_DESEA_XXXW    312A
SUB_B_SRCEA         2AC8
SUB_B_SRCEA_DATA    2C70
SUB_B_SRCEA_M0      2B12
SUB_B_SRCEA_M1      2B40
SUB_B_SRCEA_M2      2B6E
SUB_B_SRCEA_M3      2B9C
SUB_B_SRCEA_M4      2BCA
SUB_B_SRCEA_M7      2BF8
SUB_B_SRCEA_XXXL    2C4A
SUB_B_SRCEA_XXXW    2C24
SUB_L_DESEA         32CA
SUB_L_DESEA_M2      3300
SUB_L_DESEA_M3      3332
SUB_L_DESEA_M4      3364
SUB_L_DESEA_M7      3396
SUB_L_DESEA_XXXL    33E2
SUB_L_DESEA_XXXW    33B8
SUB_L_SRCEA         2E64
SUB_L_SRCEA_DATA    300C
SUB_L_SRCEA_M0      2EAE
SUB_L_SRCEA_M1      2EDC
SUB_L_SRCEA_M2      2F0A
SUB_L_SRCEA_M3      2F38
SUB_L_SRCEA_M4      2F66
SUB_L_SRCEA_M7      2F94
SUB_L_SRCEA_XXXL    2FE6
SUB_L_SRCEA_XXXW    2FC0
SUB_OPCODE          2A74
SUB_W_DESEA         317E
SUB_W_DESEA_M2      31B4
SUB_W_DESEA_M3      31E6
SUB_W_DESEA_M4      3218
SUB_W_DESEA_M7      324A
SUB_W_DESEA_XXXL    32A0
SUB_W_DESEA_XXXW    3276
SUB_W_SRCEA         2C96
SUB_W_SRCEA_DATA    2E3E
SUB_W_SRCEA_M0      2CE0
SUB_W_SRCEA_M1      2D0E
SUB_W_SRCEA_M2      2D3C
SUB_W_SRCEA_M3      2D6A
SUB_W_SRCEA_M4      2D98
SUB_W_SRCEA_M7      2DC6
SUB_W_SRCEA_XXXL    2E18
SUB_W_SRCEA_XXXW    2DF2
TESTWAITED          4890
VALIDATEEND         10FE
VALUES              4DEA
WAITFORMORE         4DA2
WAITMORE            48A2
