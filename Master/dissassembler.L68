00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 8/18/2020 9:20:41 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Team 9 Disassembler
00000000                             3  * Written by : Mariana Huynh, Hanny Long, Alex Van Matre
00000000                             4  * Date       : 07/20/20
00000000                             5  * Description: Disassmbles a program that is loaded into
00000000                             6  *              memory
00000000                             7  *-----------------------------------------------------------
00001000                             8                ORG    $1000
00001000                             9  START:                                           ; first instruction of program
00001000  4DF9 00004E72             10      LEA      Values,A6
00001006  4EB9 000048CC             11      JSR      Print
0000100C  2279 00004EA0             12      MOVE.L   PrintPointer,A1
00001012  13FC 0000 00004EA4        13      MOVE.B   #0,PrintLines
0000101A  4EB9 00004C10             14      JSR      PrintSpace
00001020                            15  
00001020                            16  * Put program code here
00001020                            17  
00001020                            18  * I/O
00001020  227C 00000000             19               MOVEA.L #0, A1                      ; Clear A1
00001026  43F9 00004C1A             20               LEA IntroMsg, A1
0000102C  103C 000E                 21               MOVE.B #14, D0                      ; print contents of A1
00001030  4E4F                      22               TRAP #15
00001032                            23  
00001032                            24  * Get start address
00001032                            25  GetStartAddr
00001032  43F9 00004CEF             26               LEA     AskStartAddr,A1             ; load asking for start address message
00001038  103C 000E                 27               MOVE.B  #14,D0
0000103C  4E4F                      28               TRAP    #15                         ; print to screen
0000103E                            29  
0000103E  227C 00000000             30               MOVEA.L #0,A1                       ; Clear A1
00001044  43F9 00000600             31               LEA     StartAddr,A1                ; Move variable StartAddr for storing
0000104A                            32  
0000104A  103C 0002                 33               MOVE.B  #2,D0                       ; trap task 2: takes in input from keyboard and stores into A1
0000104E  4E4F                      34               TRAP    #15
00001050                            35  
00001050  B27C 0008                 36               CMP     #8,D1                       ; check if input is 8 chars long
00001054  6600 00E4                 37               BNE     InvalidAddrHandler
00001058                            38  
00001058  4242                      39               CLR     D2                          ; clear toggle for if validated start/end address
0000105A                            40  
0000105A  6000 002C                 41               BRA     AsciiToHex                  ; convert input to hex
0000105E                            42  
0000105E                            43  * Get end address
0000105E                            44  GetEndAddr
0000105E  43F9 00004D18             45               LEA     AskEndAddr,A1               ; load asking for end address message
00001064  103C 000E                 46               MOVE.B  #14,D0
00001068  4E4F                      47               TRAP    #15
0000106A                            48  
0000106A  227C 00000000             49               MOVEA.L #0,A1                       ; Clear A1
00001070  43F9 00000500             50               LEA     EndAddr,A1                  ; move variable EndAddr for storing
00001076                            51  
00001076  103C 0002                 52               MOVE.B  #2,D0                       ; trap task 2: takes in input from keyboard and stores into A1
0000107A  4E4F                      53               TRAP    #15
0000107C                            54  
0000107C  B27C 0008                 55               CMP     #8,D1                       ; Check if the given value was 8 characters long, if not it needs to be given again
00001080  6600 00B8                 56               BNE     InvalidAddrHandler
00001084                            57  
00001084  6000 0002                 58               BRA     AsciiToHex                  ; convert input to hex
00001088                            59  
00001088                            60  * Convert from ASCII to hex
00001088                            61  AsciiToHex
00001088  7600                      62               MOVE.L  #0,D3                       ; initialize D3 to 0
0000108A  7808                      63               MOVE.L  #8,D4                       ; initialize D4 to 8, for number of iterations in for_loop1
0000108C  7A00                      64               MOVE.L  #0,D5                       ; initialize D5 to 0, for storing result of converted input to hex
0000108E                            65  
0000108E                            66  ConvertForLoop
0000108E  B803                      67               CMP.B   D3,D4                       ; for number of iterations
00001090  6700 0056                 68               BEQ     SaveStart                   ; if equal to each other, move on to validate start address
00001094  5283                      69               ADDQ.L  #1,D3                       ; D3++
00001096                            70  
00001096  E985                      71               ASL.L    #4,D5                      ; shift to the left 4 bits (1 hex character)
00001098  1219                      72               MOVE.B  (A1)+,D1                    ; read one char into D1
0000109A                            73  
0000109A  B23C 0030                 74               CMP.B   #$30,D1                     ; check the char, "A-F", "0-9", "a-f"
0000109E  6D00 009A                 75               BLT     InvalidAddrHandler          ; D1 < 0x30
000010A2  B23C 0039                 76               CMP.B   #$39,D1
000010A6  6F00 0022                 77               BLE     ConvertNum                  ; 0x30 (0) <= D1 <= 0x39 (9)  <-- see ASCII chart
000010AA  B23C 0041                 78               CMP.B   #$41,D1
000010AE  6D00 008A                 79               BLT     InvalidAddrHandler          ; 0x39 < D1 < 0x41
000010B2                            80  
000010B2  B23C 0046                 81               CMP.B   #$46,D1
000010B6  6F00 0026                 82               BLE     ConvertUppercase            ; 0x41 (A) <= D1 <= 0x46 (F)
000010BA  B23C 0061                 83               CMP.B   #$61,D1
000010BE  6D00 007A                 84               BLT     InvalidAddrHandler          ; 0x47 < D1 < 0x61
000010C2  B23C 0066                 85               CMP.B   #$66,D1
000010C6  6F00 000C                 86               BLE     ConvertLowercase            ; 0x66 (f) < D1
000010CA                            87  
000010CA                            88  ConvertNum
000010CA  0481 00000030             89               SUB.L   #$30,D1                     ; convert char (0-9) to number
000010D0  DA81                      90               ADD.L   D1,D5
000010D2  60BA                      91               BRA     ConvertForLoop              ; go back and do next character
000010D4                            92  
000010D4                            93  ConvertLowercase
000010D4  0481 00000057             94               SUB.L   #$57,D1                     ; convert char (a-f) to number
000010DA  DA81                      95               ADD.L   D1,D5
000010DC  60B0                      96               BRA     ConvertForLoop              ; go back and do next character
000010DE                            97  
000010DE                            98  ConvertUppercase
000010DE  0481 00000037             99               SUB.L   #$37,D1                     ; convert char (A-F) to number
000010E4  DA81                     100               ADD.L   D1,D5
000010E6  60A6                     101               BRA     ConvertForLoop              ; go back and do next character
000010E8                           102  
000010E8                           103  * Save start and end (and validate end) addresses
000010E8                           104  SaveStart
000010E8  B47C 0001                105               CMP         #1,D2
000010EC  6700 0010                106               BEQ         ValidateEnd             ; if D2 = 1, already validated start address
000010F0  5242                     107               ADDI        #1,D2                   ; if initially 0, add 1 to toggle to ValidateEnd
000010F2                           108  
000010F2  4EB9 00001116            109               JSR         PutStartToMemory        ; move converted starting address from D3 to defined memory location
000010F8  4245                     110               CLR         D5
000010FA  6000 FF62                111               BRA         GetEndAddr              ; ask user for new end address
000010FE                           112  
000010FE                           113  ValidateEnd
000010FE  BAB9 00000600            114               CMP.L       StartAddr,D5            ; check if starting address is less than or equal to ending address
00001104  6F00 0052                115               BLE         InvalidEndHandler       ; if yes, = error (start must be less than end)
00001108                           116  
00001108  4242                     117               CLR.W       D2
0000110A  4EB9 0000111E            118               JSR         PutEndToMemory          ; move ending address in D3 to defined memory location
00001110  4245                     119               CLR.W       D5
00001112                           120  
00001112  6000 0012                121               BRA         LoadAddr
00001116                           122  
00001116                           123  PutStartToMemory
00001116  23C5 00000600            124               MOVE.L      D5,StartAddr
0000111C  4E75                     125               RTS
0000111E                           126  
0000111E                           127  PutEndToMemory
0000111E  23C5 00000500            128               MOVE.L      D5,EndAddr
00001124  4E75                     129               RTS
00001126                           130  
00001126                           131  LoadAddr
00001126  4282                     132               CLR.L       D2
00001128  2479 00000600            133               MOVE.L      StartAddr,A2
0000112E  2679 00000500            134               MOVE.L      EndAddr,A3
00001134  4EB9 00001186            135               JSR         ReadNextLoopStart
0000113A                           136  
0000113A                           137  * Invalid input handlers
0000113A                           138  InvalidAddrHandler
0000113A  B47C 0001                139               CMP         #1,D2                   ; if toggle at D2 = 1 then end address error
0000113E  6700 0018                140               BEQ         InvalidEndHandler
00001142  6000 0002                141               BRA         InvalidStartHandler ; else starting address error
00001146                           142  
00001146                           143  InvalidStartHandler
00001146  227C 00000000            144               MOVEA.L     #0,A1                   ; clear A1
0000114C  4EB9 0000116A            145               JSR         DispInvalidStartError
00001152  4245                     146               CLR         D5
00001154  6000 FEDC                147               BRA         GetStartAddr            ; ask for starting address again
00001158                           148  
00001158                           149  InvalidEndHandler
00001158  227C 00000000            150               MOVEA.L     #0,A1                   ; clear A1
0000115E  4EB9 00001178            151               JSR         DispInvalidEndError
00001164  4245                     152               CLR         D5
00001166  6000 FEF6                153               BRA         GetEndAddr
0000116A                           154  
0000116A                           155  DispInvalidStartError
0000116A  43F9 00004D75            156               LEA         InvalidStartMessage,A1  ; load error message
00001170  103C 000D                157               MOVE.B      #13,D0                  ; print contents of A1
00001174  4E4F                     158               TRAP        #15
00001176  4E75                     159               RTS
00001178                           160  
00001178                           161  DispInvalidEndError
00001178  43F9 00004DA8            162               LEA         InvalidEndMessage,A1    ; load error message
0000117E  103C 000D                163               MOVE.B      #13,D0                  ; print contents of A1
00001182  4E4F                     164               TRAP        #15
00001184  4E75                     165               RTS
00001186                           166  
00001186                           167  * Opcode Parsing
00001186                           168  ReadNextLoopStart
00001186  284A                     169               MOVE.L      A2,A4
00001188                           170  
00001188                           171  ReadNextLoop
00001188  B9CB                     172               CMPA.L      A3,A4
0000118A  6C00 0018                173               BGE         AskExitOrRestart
0000118E                           174  
0000118E                           175               ;MOVE.B     -(A4),A4
0000118E                           176  
0000118E  4EB9 000048DE            177               JSR         PrintLine
00001194                           178  
00001194  4EB9 00004928            179               JSR         PrintAddr
0000119A                           180  
0000119A  4EB9 0000121E            181               JSR         DecodingMachineCode
000011A0                           182               ;MOVE.W      (A4)+,D7                   ; read one word at a time and store in D7
000011A0  4EF8 1188                183               JMP         ReadNextLoop
000011A4                           184  
000011A4                           185  AskExitOrRestart
000011A4  43F9 00004D3F            186               LEA         AskRestartOrExitMsg,A1 ; ask user to restart or exit program
000011AA  103C 000E                187               MOVE.B      #14,D0
000011AE  4E4F                     188               TRAP        #15
000011B0                           189  
000011B0  103C 0004                190               MOVE.B      #4,D0                  ; trap task #4: get user input (digit)
000011B4  4E4F                     191               TRAP        #15
000011B6                           192  
000011B6  B23C 0001                193               CMP.B       #1,D1                  ; if user inputs 1, restart program
000011BA  6700 000C                194               BEQ         ClearEverything
000011BE  B23C 0000                195               CMP.B       #0,D1                  ; if 0, terminate program
000011C2  66E0                     196               BNE         AskExitOrRestart       ; if not 0 nor 1, prompt again
000011C4  6000 0052                197               BRA         quit
000011C8                           198  
000011C8                           199  ClearEverything
000011C8                           200  * Clear data registers
000011C8  4280                     201               CLR.L       D0
000011CA  4281                     202               CLR.L       D1
000011CC  4282                     203               CLR.L       D2
000011CE  4283                     204               CLR.L       D3
000011D0  4284                     205               CLR.L       D4
000011D2  4285                     206               CLR.L       D5
000011D4  4286                     207               CLR.L       D6
000011D6  4287                     208               CLR.L       D7
000011D8                           209  
000011D8                           210  * Clear address registers
000011D8  207C 00000000            211               MOVEA.L     #0, A0
000011DE  227C 00000000            212               MOVEA.L     #0, A1
000011E4  247C 00000000            213               MOVEA.L     #0, A2
000011EA  267C 00000000            214               MOVEA.L     #0, A3
000011F0  287C 00000000            215               MOVEA.L     #0, A4
000011F6  2A7C 00000000            216               MOVEA.L     #0, A5
000011FC  2C7C 00000000            217               MOVEA.L     #0, A6
00001202  2E7C 00000000            218               MOVEA.L     #0, A7
00001208                           219  
00001208                           220  * Clear memory locations that variables used
00001208  42B9 00000600            221               CLR.L       StartAddr
0000120E  42B9 00000500            222               CLR.L       EndAddr
00001214                           223  
00001214  6000 FDEA                224               BRA         START
00001218                           225  
00001218                           226  quit
00001218  103C 0009                227               MOVE.B      #9, D0
0000121C  4E4F                     228               TRAP        #15
0000121E                           229  
0000121E                           230  *-----------------------------------------------------------
0000121E                           231  * Title      : Opcode decoding
0000121E                           232  * Written by :
0000121E                           233  * Date       :
0000121E                           234  * Description: decoding opcode from machine code by looking at the bit and narrowing down the possibility
0000121E                           235  *-----------------------------------------------------------
0000121E                           236  *******     ASSUME (A4) IS ALREADY is the MACHINE CODE                  ********
0000121E                           237  *******     NOTE: MACHINE CODE ARE WORD SIZE                            ********
0000121E                           238  *******     The code narrow down the opcode posibility by               ********
0000121E                           239  *******     looking at the bit and branch                               ********
0000121E                           240  *******     Using D3,D4 for loop and,D5 result                          ********
0000121E                           241  *******     Using D0, D1 to hold temperary data                         ********
0000121E                           242  *******     POSTCONDITION: (A4) will hold 0 after RTS from this SR      ********
0000121E                           243  *******                    except for if the opcode is NOP or RTS       ********
0000121E                           244  ;Ctrl+F "Print" to see where all the print is
0000121E                           245  ;If nothing work BUG is in GetNextD4bit subroutine or InvalidOpcode subroutine, both is at the bottom of the file
0000121E                           246  
0000121E                           247  DecodingMachineCode
0000121E  4242                     248              CLR     D2
00001220  341C                     249              MOVE.W  (A4)+,D2        ; create copy of data in A4 to fix restart
00001222                           250  
00001222  0C42 4E71                251              CMPI.W  #20081,D2    ; NOP if equal
00001226  6700 3952                252              BEQ     PrintNOP       ; Call Output PrintNOP subroutine
0000122A                           253              ;RTS                    ; Return to get more input
0000122A                           254  
0000122A  0C42 4E75                255              CMPI.W  #20085,D2    ; RTS if equal
0000122E  6700 398C                256              BEQ     PrintRTS       ; Call Output PrintRTS subroutine
00001232                           257              ;RTS                    ; Return to get more input
00001232                           258  
00001232  7804                     259              MOVE.L  #4,D4          ; get the next 4 bit from (A4) in to D5
00001234  4EB9 000048B0            260              JSR     GetNextD4bit   ; D5 hold the first 4 bit of (A4)
0000123A                           261  
0000123A                           262      ; cmp to see whice opcode the frist 4 bit match with
0000123A  BABC 0000000E            263              CMP.L   #14,D5
00001240  6700 0062                264              BEQ     LSL_ASL_Opcode
00001244                           265  
00001244  BABC 0000000D            266              CMP.L   #13,D5
0000124A  6700 0434                267              BEQ     ADD_Opcode
0000124E                           268  
0000124E  BABC 0000000C            269              CMP.L   #12,D5
00001254  6700 0DA2                270              BEQ     MULS_W_AND_Opcode
00001258                           271  
00001258  BABC 00000009            272              CMP.L   #9,D5
0000125E  6700 1814                273              BEQ     SUB_Opcode
00001262                           274  
00001262  BABC 00000008            275              CMP.L   #8,D5
00001268  6700 21A2                276              BEQ     DIVU_W_Opcode
0000126C                           277  
0000126C  BABC 00000006            278              CMP.L   #6,D5
00001272  6700 234A                279              BEQ     Bcc_Opcode
00001276                           280  
00001276  BABC 00000004            281              CMP.L   #4,D5
0000127C  6700 23D8                282              BEQ     NeedMoreBit
00001280                           283  
00001280  BABC 00000003            284              CMP.L   #3,D5
00001286  6700 2FBA                285              BEQ     MOVE_W_Opcode
0000128A                           286  
0000128A  BABC 00000002            287              CMP.L   #2,D5
00001290  6700 3236                288              BEQ     MOVE_L_Opcode
00001294                           289  
00001294  BABC 00000001            290              CMP.L   #1,D5
0000129A  6700 341C                291              BEQ     MOVE_B_Opcode
0000129E                           292  
0000129E  4EF9 000048A8            293              JMP     InvalidOpcode  ; Call Output NotFound subroutine, since it did not match with any first 4 bit of the opcode
000012A4                           294  
000012A4                           295  
000012A4                           296  *************************************************                LSL_ASL_Opcode                  *************************************************
000012A4                           297  ; first four bit is (1110 #### #### ####)
000012A4                           298  LSL_ASL_Opcode
000012A4  7803                     299              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 11-9) in to D5
000012A6  4EB9 000048B0            300              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which is count or register it is
000012AC                           301  
000012AC  2005                     302              MOVE.L  D5,D0          ; D0 will hold the count or register
000012AE                           303         ; D0 will hold the count or register (position 11-9)
000012AE                           304  
000012AE  7801                     305              MOVE.L  #1,D4          ; get the next 1 bit from (A4)(position 8) in to D5
000012B0  4EB9 000048B0            306              JSR     GetNextD4bit   ; D5 hold the next 1 bit of (A4), which tell us the direction
000012B6                           307  
000012B6  BABC 00000001            308              CMP.L   #1,D5          ; D5 should be 1 since we are shifting left
000012BC  6600 35EA                309              BNE     InvalidOpcode  ; if D5 doesn't equal 1 it is not a valid machine code
000012C0                           310  
000012C0  7802                     311              MOVE.L  #2,D4          ; get the next 2 bit from (A4)(position 7-6) in to D5
000012C2  4EB9 000048B0            312              JSR     GetNextD4bit   ; D5 hold the next 2 bit of (A4), which tell us the size
000012C8                           313  
000012C8  BABC 00000003            314              CMP.L   #3,D5          ; if size is 3 then it is a memory shift
000012CE  4EF9 0000147C            315              JMP     MemShift
000012D4                           316  
000012D4  2205                     317              MOVE.L  D5,D1          ; D1 will hold the size
000012D6                           318         ; D1 will hold the size (position 7-6)
000012D6                           319  
000012D6  7803                     320              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
000012D8  4EB9 000048B0            321              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us immediate shift count or register shift count
000012DE                           322  
000012DE  BABC 00000000            323              CMP.L   #0,D5          ; D5 is 3 bit from (A4)(position 5-3), if 0 mean it is a ASL by count
000012E4  6700 0026                324              BEQ     ASL_Count_Opcode
000012E8                           325  
000012E8  BABC 00000001            326              CMP.L   #1,D5           ; D5 is 3 bit from (A4)(position 5-3), if 1 mean it is a LSL by count
000012EE  6700 00AC                327              BEQ     LSL_Count_Opcode
000012F2                           328  
000012F2  BABC 00000004            329              CMP.L   #4,D5           ; D5 is 3 bit from (A4)(position 5-3), if 4 mean it is a ASL by Register
000012F8  6700 0142                330              BEQ     ASL_Register_Opcode
000012FC                           331  
000012FC  BABC 00000005            332              CMP.L   #5,D5           ; D5 is 3 bit from (A4)(position 5-3), if 5 mean it is a LSL by Register
00001302  6700 0158                333              BEQ     LSL_Register_Opcode
00001306                           334  
00001306  4EF9 000048A8            335              JMP     InvalidOpcode       ; if it is not invalid because position 5-3 did not match any posibility
0000130C                           336  
0000130C                           337  ASL_Count_Opcode
0000130C  7803                     338              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000130E  4EB9 000048B0            339              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
00001314                           340  
00001314  4EB9 0000133C            341              JSR     ASL_Output_Size    ;output ASL and size from D1
0000131A                           342  
0000131A  4EB9 0000142C            343              JSR     CheckCount     ; change D0 to 8 if D0 equal to 0
00001320                           344  
00001320  1E05                     345              MOVE.B  D5,D7
00001322  1A00                     346              MOVE.B  D0,D5
00001324                           347  
00001324  12EE 0029                348              MOVE.B  41(A6),(A1)+             *#
00001328  4EB9 00004A64            349              JSR     PrintRegNum
0000132E                           350  
0000132E  1A07                     351              MOVE.B  D7,D5
00001330  12EE 0025                352              MOVE.B  37(A6),(A1)+             *,
00001334  4EB9 00004A2A            353              JSR     PrintDataReg
0000133A                           354  
0000133A  4E75                     355              RTS                    ; Return to get more input
0000133C                           356  
0000133C                           357  ASL_Output_Size    ; subroutine for outputting size from D1
0000133C  B2BC 00000000            358              CMP.L   #0,D1           ; if D1 is 0 it is byte size
00001342  6700 001C                359              BEQ     ASL_Output_Byte
00001346                           360  
00001346  B2BC 00000001            361              CMP.L   #1,D1           ; if D1 is 1 it is word size
0000134C  6700 0026                362              BEQ     ASL_Output_Word
00001350                           363  
00001350  B2BC 00000002            364              CMP.L   #2,D1           ; if D1 is 2 it is long size
00001356  6700 0030                365              BEQ     ASL_Output_Long
0000135A                           366  
0000135A  4EF9 000048A8            367              JMP     InvalidOpcode    ; if it is not 0,1,2 it is not a valid size
00001360                           368  
00001360                           369  ASL_Output_Byte
00001360  4EB9 00004A9A            370              JSR     PrintASL
00001366  4EB9 00004BD8            371              JSR     LengthB
0000136C  4EB9 00004C10            372              JSR     PrintSpace
00001372  4E75                     373              RTS                     ; return from subroutine
00001374                           374  
00001374                           375  ASL_Output_Word
00001374  4EB9 00004A9A            376              JSR     PrintASL
0000137A  4EB9 00004BE2            377              JSR     LengthW
00001380  4EB9 00004C10            378              JSR     PrintSpace
00001386  4E75                     379              RTS                     ; return from subroutine
00001388                           380  
00001388                           381  ASL_Output_Long
00001388  4EB9 00004A9A            382              JSR     PrintASL
0000138E  4EB9 00004BEC            383              JSR     LengthL
00001394  4EB9 00004C10            384              JSR     PrintSpace
0000139A  4E75                     385              RTS                     ; return from subroutine
0000139C                           386  
0000139C                           387  
0000139C                           388  LSL_Count_Opcode
0000139C  7803                     389              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000139E  4EB9 000048B0            390              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
000013A4                           391  
000013A4  4EB9 000013CC            392              JSR     LSL_Output_Size    ;output LSL and size from D1
000013AA                           393  
000013AA  4EB9 0000142C            394              JSR     CheckCount     ; change D0 to 8 if D0 equal to 0
000013B0                           395  
000013B0  1E05                     396              MOVE.B  D5,D7
000013B2  1A00                     397              MOVE.B  D0,D5
000013B4                           398  
000013B4  12EE 0029                399              MOVE.B  41(A6),(A1)+             *#
000013B8  4EB9 00004A64            400              JSR     PrintRegNum
000013BE                           401  
000013BE  1A07                     402              MOVE.B  D7,D5
000013C0  12EE 0025                403              MOVE.B  37(A6),(A1)+             *,
000013C4  4EB9 00004A2A            404              JSR     PrintDataReg
000013CA                           405  
000013CA  4E75                     406              RTS                    ; Return to get more input
000013CC                           407  
000013CC                           408  LSL_Output_Size    ; subroutine for outputting size from D1
000013CC  B2BC 00000000            409              CMP.L   #0,D1           ; if D1 is 0 it is byte size
000013D2  6700 001C                410              BEQ     LSL_Output_Byte
000013D6                           411  
000013D6  B2BC 00000001            412              CMP.L   #1,D1           ; if D1 is 1 it is word size
000013DC  6700 0026                413              BEQ     LSL_Output_Word
000013E0                           414  
000013E0  B2BC 00000002            415              CMP.L   #2,D1           ; if D1 is 2 it is long size
000013E6  6700 0030                416              BEQ     LSL_Output_Long
000013EA                           417  
000013EA  4EF9 000048A8            418              JMP     InvalidOpcode    ; if it is not 0,1,2 it is not a valid size
000013F0                           419  
000013F0                           420  LSL_Output_Byte
000013F0  4EB9 00004B1C            421              JSR     PrintLSL
000013F6  4EB9 00004BD8            422              JSR     LengthB
000013FC  4EB9 00004C10            423              JSR     PrintSpace
00001402  4E75                     424              RTS                     ; return from subroutine
00001404                           425  
00001404                           426  LSL_Output_Word
00001404  4EB9 00004B1C            427              JSR     PrintLSL
0000140A  4EB9 00004BE2            428              JSR     LengthW
00001410  4EB9 00004C10            429              JSR     PrintSpace
00001416  4E75                     430              RTS                     ; return from subroutine
00001418                           431  
00001418                           432  LSL_Output_Long
00001418  4EB9 00004B1C            433              JSR     PrintLSL
0000141E  4EB9 00004BEC            434              JSR     LengthL
00001424  4EB9 00004C10            435              JSR     PrintSpace
0000142A  4E75                     436              RTS                     ; return from subroutine
0000142C                           437  
0000142C                           438  CheckCount  ; Subroutine for change D0 to 8 if D0 equal to 0
0000142C  B0BC 00000000            439              CMP.L   #0,D0
00001432  6700 0004                440              BEQ     D0_to_8
00001436  4E75                     441              RTS                     ; return from subroutine
00001438                           442  
00001438  7008                     443  D0_to_8     MOVE.L  #8,D0
0000143A  4E75                     444              RTS                     ; return from subroutine
0000143C                           445  
0000143C                           446  ASL_Register_Opcode
0000143C  7803                     447              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000143E  4EB9 000048B0            448              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
00001444                           449  
00001444  4EB8 133C                450              JSR     ASL_Output_Size    ;output ASL and size from D1
00001448                           451  
00001448  1E05                     452              MOVE.B  D5,D7
0000144A  1A00                     453              MOVE.B  D0,D5
0000144C  4EB9 00004A2A            454              JSR     PrintDataReg
00001452                           455  
00001452  1A07                     456              MOVE.B  D7,D5
00001454  4EB9 00004A2A            457              JSR     PrintDataReg
0000145A                           458  
0000145A  4E75                     459              RTS                    ; Return to get more input
0000145C                           460  
0000145C                           461  
0000145C                           462  LSL_Register_Opcode
0000145C  7803                     463              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000145E  4EB9 000048B0            464              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us which register
00001464                           465  
00001464  4EB8 13CC                466              JSR     LSL_Output_Size    ;output ASL and size from D1
00001468                           467  
00001468  1E05                     468              MOVE.B  D5,D7
0000146A  1A00                     469              MOVE.B  D0,D5
0000146C  4EB9 00004A2A            470              JSR     PrintDataReg
00001472                           471  
00001472  1A07                     472              MOVE.B  D7,D5
00001474  4EB9 00004A2A            473              JSR     PrintDataReg
0000147A                           474  
0000147A  4E75                     475              RTS                    ; Return to get more input
0000147C                           476  
0000147C                           477  MemShift    ; D0 will hold the count or register (position 11-9)
0000147C  B0BC 00000001            478              CMP.L   #1,D0
00001482  6700 0012                479              BEQ     LSL_MemShift
00001486  B0BC 00000000            480              CMP.L   #0,D0
0000148C  6700 0100                481              BEQ     ASL_MemShift
00001490  4EF9 000048A8            482              JMP     InvalidOpcode  ; for memory shift (position 11-9)need to be 0 or 1
00001496                           483  
00001496                           484  LSL_MemShift     ; D5 should hold the value of position 5-3
00001496  7803                     485              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00001498  4EB9 000048B0            486              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us mode
0000149E                           487  
0000149E  BABC 00000002            488              CMP.L   #2,D5               ; if position 5-3 is 2 then it is mode 2
000014A4  6700 0026                489              BEQ     LSL_MemShift_Mode_2
000014A8                           490  
000014A8  BABC 00000003            491              CMP.L   #3,D5               ; if position 5-3 is 3 then it is mode 3
000014AE  6700 003E                492              BEQ     LSL_MemShift_Mode_3
000014B2                           493  
000014B2  BABC 00000004            494              CMP.L   #4,D5               ; if position 5-3 is 4 then it is mode 4
000014B8  6700 0056                495              BEQ     LSL_MemShift_Mode_4
000014BC                           496  
000014BC  BABC 00000007            497              CMP.L   #7,D5               ; if position 5-3 is 7 then it is mode 7
000014C2  6700 006E                498              BEQ     LSL_MemShift_Mode_7
000014C6                           499  
000014C6  4EF9 000048A8            500              JMP     InvalidOpcode       ; if it is not Addressing mode 2,3,4,7 it is invalid
000014CC                           501  
000014CC                           502  LSL_MemShift_Mode_2
000014CC  7803                     503              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000014CE  4EB9 000048B0            504              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000014D4  4EB9 00004B1C            505              JSR     PrintLSL
000014DA  4EB9 00004BE2            506              JSR     LengthW
000014E0  4EB9 00004C10            507              JSR     PrintSpace
000014E6  4EB9 00004A42            508              JSR     PrintIndirAddrReg
000014EC  4E75                     509              RTS                    ; Return to get more input
000014EE                           510  
000014EE                           511  LSL_MemShift_Mode_3
000014EE  7803                     512              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000014F0  4EB9 000048B0            513              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000014F6  4EB9 00004B1C            514              JSR     PrintLSL
000014FC  4EB9 00004BE2            515              JSR     LengthW
00001502  4EB9 00004C10            516              JSR     PrintSpace
00001508  4EB9 00004A50            517              JSR     PrintPostIncAddrReg
0000150E  4E75                     518              RTS                    ; Return to get more input
00001510                           519  
00001510                           520  LSL_MemShift_Mode_4
00001510  7803                     521              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001512  4EB9 000048B0            522              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001518  4EB9 00004B1C            523              JSR     PrintLSL
0000151E  4EB9 00004BE2            524              JSR     LengthW
00001524  4EB9 00004C10            525              JSR     PrintSpace
0000152A  4EB9 00004A5A            526              JSR     PrintPreDeincAddrReg
00001530  4E75                     527              RTS                    ; Return to get more input
00001532                           528  
00001532                           529  LSL_MemShift_Mode_7
00001532  7803                     530              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001534  4EB9 000048B0            531              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
0000153A                           532  
0000153A  BABC 00000001            533              CMP.L   #1,D5               ; check if the register is 1
00001540  6700 0032                534              BEQ     LSL_MemShift_xxxL   ; if mode is 7 and register is 1, it is <xxx>.L
00001544                           535  
00001544  BABC 00000000            536              CMP.L   #0,D5               ; check if the register is 0
0000154A  6700 0008                537              BEQ     LSL_MemShift_xxxW   ; if mode is 7 and register is 1, it is <xxx>.W
0000154E                           538  
0000154E  4EF9 000048A8            539              JMP     InvalidOpcode       ; if it is not <xxx>.W or <xxx>.L
00001554                           540  
00001554                           541  LSL_MemShift_xxxW
00001554  4EB9 00004B1C            542              JSR     PrintLSL
0000155A  4EB9 00004BE2            543              JSR     LengthW
00001560  4EB9 00004C10            544              JSR     PrintSpace
00001566  4EB9 000049AA            545              JSR     PrintByteOrWord
0000156C  4EB9 00004BE2            546              JSR     LengthW
00001572  4E75                     547              RTS                    ; Return to get more input
00001574                           548  
00001574                           549  LSL_MemShift_xxxL
00001574  4EB9 00004B1C            550              JSR     PrintLSL
0000157A  4EB9 00004BE2            551              JSR     LengthW
00001580  4EB9 00004C10            552              JSR     PrintSpace
00001586  4EB9 000049C0            553              JSR     PrintLong
0000158C  4E75                     554              RTS                    ; Return to get more input
0000158E                           555  
0000158E                           556  ASL_MemShift    ; D5 should hold the value of position 5-3
0000158E  7803                     557              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001590  4EB9 000048B0            558              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us mode
00001596                           559  
00001596  BABC 00000002            560              CMP.L   #2,D5               ; if position 5-3 is 2 then it is mode 2
0000159C  6700 0026                561              BEQ     ASL_MemShift_Mode_2
000015A0                           562  
000015A0  BABC 00000003            563              CMP.L   #3,D5               ; if position 5-3 is 3 then it is mode 3
000015A6  6700 003E                564              BEQ     ASL_MemShift_Mode_3
000015AA                           565  
000015AA  BABC 00000004            566              CMP.L   #4,D5               ; if position 5-3 is 4 then it is mode 4
000015B0  6700 0056                567              BEQ     ASL_MemShift_Mode_4
000015B4                           568  
000015B4  BABC 00000007            569              CMP.L   #7,D5               ; if position 5-3 is 7 then it is mode 7
000015BA  6700 006E                570              BEQ     ASL_MemShift_Mode_7
000015BE                           571  
000015BE  4EF9 000048A8            572              JMP     InvalidOpcode       ; if it is not Addressing mode 2,3,4,7 it is invalid
000015C4                           573  
000015C4                           574  ASL_MemShift_Mode_2
000015C4  7803                     575              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000015C6  4EB9 000048B0            576              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000015CC  4EB9 00004A9A            577              JSR     PrintASL
000015D2  4EB9 00004BE2            578              JSR     LengthW
000015D8  4EB9 00004C10            579              JSR     PrintSpace
000015DE  4EB9 00004A42            580              JSR     PrintIndirAddrReg
000015E4  4E75                     581              RTS                    ; Return to get more input
000015E6                           582  
000015E6                           583  ASL_MemShift_Mode_3
000015E6  7803                     584              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000015E8  4EB9 000048B0            585              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
000015EE  4EB9 00004A9A            586              JSR     PrintASL
000015F4  4EB9 00004BE2            587              JSR     LengthW
000015FA  4EB9 00004C10            588              JSR     PrintSpace
00001600  4EB9 00004A50            589              JSR     PrintPostIncAddrReg
00001606  4E75                     590              RTS                    ; Return to get more input
00001608                           591  
00001608                           592  ASL_MemShift_Mode_4
00001608  7803                     593              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000160A  4EB9 000048B0            594              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001610  4EB9 00004A9A            595              JSR     PrintASL
00001616  4EB9 00004BE2            596              JSR     LengthW
0000161C  4EB9 00004C10            597              JSR     PrintSpace
00001622  4EB9 00004A5A            598              JSR     PrintPreDeincAddrReg
00001628  4E75                     599              RTS                    ; Return to get more input
0000162A                           600  
0000162A                           601  ASL_MemShift_Mode_7
0000162A  7803                     602              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000162C  4EB9 000048B0            603              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001632                           604  
00001632  BABC 00000001            605              CMP.L   #1,D5               ; check if the register is 1
00001638  6700 002C                606              BEQ     ASL_MemShift_xxxL   ; if mode is 7 and register is 1, it is <xxx>.L
0000163C                           607  
0000163C  BABC 00000000            608              CMP.L   #0,D5               ; check if the register is 0
00001642  6700 0008                609              BEQ     ASL_MemShift_xxxW   ; if mode is 7 and register is 1, it is <xxx>.W
00001646                           610  
00001646  4EF9 000048A8            611              JMP     InvalidOpcode  ; if it is not <xxx>.W or <xxx>.L
0000164C                           612  
0000164C                           613  ASL_MemShift_xxxW
0000164C  4EB9 00004A9A            614              JSR     PrintASL
00001652  4EB9 00004BE2            615              JSR     LengthW
00001658  4EB9 00004C10            616              JSR     PrintSpace
0000165E  4EB9 000049AA            617              JSR     PrintByteOrWord
00001664  4E75                     618              RTS                    ; Return to get more input
00001666                           619  
00001666                           620  ASL_MemShift_xxxL
00001666  4EB9 00004A9A            621              JSR     PrintASL
0000166C  4EB9 00004BE2            622              JSR     LengthW
00001672  4EB9 00004C10            623              JSR     PrintSpace
00001678  4EB9 000049C0            624              JSR     PrintLong
0000167E  4E75                     625              RTS                    ; Return to get more input
00001680                           626  
00001680                           627  
00001680                           628  *************************************************                ADD_Opcode                 *************************************************
00001680                           629  ; first four bit is (1101 #### #### ####)
00001680  7803                     630  ADD_Opcode  MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00001682  4EB9 000048B0            631              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00001688                           632  
00001688  2005                     633              MOVE.L  D5,D0               ; D0 will hold the register
0000168A                           634          ; D0 will hold the register (position 11-9)
0000168A                           635  
0000168A  7803                     636              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
0000168C  4EB9 000048B0            637              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the opmode
00001692                           638  
00001692  BABC 00000000            639              CMP.L   #0,D5               ; if opmode is 0, it is a byte with location specified is a source  (<ea> + Dn -> Dn)
00001698  6700 003A                640              BEQ     ADD_B_SrcEA
0000169C                           641  
0000169C  BABC 00000001            642              CMP.L   #1,D5               ; if opmode is 1, it is a word with location specified is a source  (<ea> + Dn -> Dn)
000016A2  6700 01FE                643              BEQ     ADD_W_SrcEA
000016A6                           644  
000016A6  BABC 00000002            645              CMP.L   #2,D5               ; if opmode is 2, it is a long with location specified is a source  (<ea> + Dn -> Dn)
000016AC  6700 03C2                646              BEQ     ADD_L_SrcEA
000016B0                           647  
000016B0  BABC 00000004            648              CMP.L   #4,D5               ; if opmode is 4, it is a byte with location specified is a Destination (Dn + <ea> -> <ea>)
000016B6  6700 0586                649              BEQ     ADD_B_DesEA
000016BA                           650  
000016BA  BABC 00000005            651              CMP.L   #5,D5               ; if opmode is 5, it is a word with location specified is a Destination (Dn + <ea> -> <ea>)
000016C0  6700 06BA                652              BEQ     ADD_W_DesEA
000016C4                           653  
000016C4  BABC 00000006            654              CMP.L   #6,D5               ; if opmode is 6, it is a long with location specified is a Destination (Dn + <ea> -> <ea>)
000016CA  6700 07EE                655              BEQ     ADD_L_DesEA
000016CE                           656  
000016CE  4EF9 000048A8            657              JMP     InvalidOpcode       ; if it is not one of the opmode the opcode is invalid
000016D4                           658  
000016D4  7803                     659  ADD_B_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000016D6  4EB9 000048B0            660              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000016DC                           661  
000016DC  BABC 00000000            662              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000016E2  6700 003A                663              BEQ     ADD_B_SrcEA_M0
000016E6                           664  
000016E6  BABC 00000001            665              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
000016EC  6700 005E                666              BEQ     ADD_B_SrcEA_M1
000016F0                           667  
000016F0  BABC 00000002            668              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000016F6  6700 0082                669              BEQ     ADD_B_SrcEA_M2
000016FA                           670  
000016FA  BABC 00000003            671              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001700  6700 00A6                672              BEQ     ADD_B_SrcEA_M3
00001704                           673  
00001704  BABC 00000004            674              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000170A  6700 00CA                675              BEQ     ADD_B_SrcEA_M4
0000170E                           676  
0000170E  BABC 00000007            677              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001714  6700 00EE                678              BEQ     ADD_B_SrcEA_M7
00001718                           679  
00001718  4EF9 000048A8            680              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000171E                           681  
0000171E                           682  ADD_B_SrcEA_M0
0000171E  7803                     683              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001720  4EB9 000048B0            684              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001726  4EB9 00004A6A            685              JSR     PrintAdd
0000172C  4EB9 00004BD8            686              JSR     LengthB
00001732  4EB9 00004C10            687              JSR     PrintSpace
00001738  4EB9 00004A2A            688              JSR     PrintDataReg
0000173E                           689  
0000173E  1A00                     690              MOVE.B  D0,D5
00001740  12EE 0025                691              MOVE.B  37(A6),(A1)+             *,
00001744  4EB9 00004A2A            692              JSR     PrintDataReg
0000174A                           693  
0000174A  4E75                     694              RTS                     ; return to input to get more input
0000174C                           695  
0000174C                           696  ADD_B_SrcEA_M1
0000174C  7803                     697              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000174E  4EB9 000048B0            698              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001754  4EB9 00004A6A            699              JSR     PrintAdd
0000175A  4EB9 00004BD8            700              JSR     LengthB
00001760  4EB9 00004C10            701              JSR     PrintSpace
00001766  4EB9 00004A36            702              JSR     PrintAddrReg
0000176C                           703  
0000176C  1A00                     704              MOVE.B  D0,D5
0000176E  12EE 0025                705              MOVE.B  37(A6),(A1)+             *,
00001772  4EB9 00004A2A            706              JSR     PrintDataReg
00001778  4E75                     707              RTS                     ; return to input to get more input
0000177A                           708  
0000177A                           709  ADD_B_SrcEA_M2
0000177A  7803                     710              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000177C  4EB9 000048B0            711              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001782  4EB9 00004A6A            712              JSR     PrintAdd
00001788  4EB9 00004BD8            713              JSR     LengthB
0000178E  4EB9 00004C10            714              JSR     PrintSpace
00001794  4EB9 00004A42            715              JSR     PrintIndirAddrReg
0000179A                           716  
0000179A  1A00                     717              MOVE.B  D0,D5
0000179C  12EE 0025                718              MOVE.B  37(A6),(A1)+             *,
000017A0  4EB9 00004A2A            719              JSR     PrintDataReg
000017A6                           720  
000017A6  4E75                     721              RTS                     ; return to input to get more input
000017A8                           722  
000017A8                           723  ADD_B_SrcEA_M3
000017A8  7803                     724              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000017AA  4EB9 000048B0            725              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000017B0  4EB9 00004A6A            726              JSR     PrintAdd
000017B6  4EB9 00004BD8            727              JSR     LengthB
000017BC  4EB9 00004C10            728              JSR     PrintSpace
000017C2  4EB9 00004A50            729              JSR     PrintPostIncAddrReg
000017C8                           730  
000017C8  1A00                     731              MOVE.B  D0,D5
000017CA  12EE 0025                732              MOVE.B  37(A6),(A1)+             *,
000017CE  4EB9 00004A2A            733              JSR     PrintDataReg
000017D4  4E75                     734              RTS                     ; return to input to get more input
000017D6                           735  
000017D6                           736  ADD_B_SrcEA_M4
000017D6  7803                     737              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000017D8  4EB9 000048B0            738              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000017DE  4EB9 00004A6A            739              JSR     PrintAdd
000017E4  4EB9 00004BD8            740              JSR     LengthB
000017EA  4EB9 00004C10            741              JSR     PrintSpace
000017F0  4EB9 00004A5A            742              JSR     PrintPreDeincAddrReg
000017F6                           743  
000017F6  1A00                     744              MOVE.B  D0,D5
000017F8  12EE 0025                745              MOVE.B  37(A6),(A1)+             *,
000017FC  4EB9 00004A2A            746              JSR     PrintDataReg
00001802  4E75                     747              RTS                     ; return to input to get more input
00001804                           748  
00001804                           749  ADD_B_SrcEA_M7
00001804  7803                     750              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001806  4EB9 000048B0            751              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000180C                           752  
0000180C  BABC 00000000            753              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001812  6700 001C                754              BEQ     ADD_B_SrcEA_xxxW
00001816                           755  
00001816  BABC 00000001            756              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
0000181C  6700 0038                757              BEQ     ADD_B_SrcEA_xxxL
00001820                           758  
00001820  BABC 00000004            759              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00001826  6700 0054                760              BEQ     ADD_B_SrcEA_Data
0000182A                           761  
0000182A  4EF9 000048A8            762              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001830                           763  
00001830                           764  ADD_B_SrcEA_xxxW
00001830  4EB9 00004A6A            765              JSR     PrintAdd
00001836  4EB9 00004BD8            766              JSR     LengthB
0000183C  4EB9 00004C10            767              JSR     PrintSpace
00001842  4EB9 000049AA            768              JSR     PrintByteOrWord
00001848                           769  
00001848  1A00                     770              MOVE.B  D0,D5
0000184A  12EE 0025                771              MOVE.B  37(A6),(A1)+             *,
0000184E  4EB9 00004A2A            772              JSR     PrintDataReg
00001854  4E75                     773              RTS                     ; return to input to get more input
00001856                           774  
00001856                           775  ADD_B_SrcEA_xxxL
00001856  4EB9 00004A6A            776              JSR     PrintAdd
0000185C  4EB9 00004BD8            777              JSR     LengthB
00001862  4EB9 00004C10            778              JSR     PrintSpace
00001868  4EB9 000049C0            779              JSR     PrintLong
0000186E                           780  
0000186E  1A00                     781              MOVE.B  D0,D5
00001870  12EE 0025                782              MOVE.B  37(A6),(A1)+             *,
00001874  4EB9 00004A2A            783              JSR     PrintDataReg
0000187A  4E75                     784              RTS                     ; return to input to get more input
0000187C                           785  
0000187C                           786  ADD_B_SrcEA_Data
0000187C  4EB9 00004A6A            787              JSR     PrintAdd
00001882  4EB9 00004BD8            788              JSR     LengthB
00001888  4EB9 00004C10            789              JSR     PrintSpace
0000188E  4EB9 0000499E            790              JSR     PrintImmediateData
00001894                           791  
00001894  1A00                     792              MOVE.B  D0,D5
00001896  12EE 0025                793              MOVE.B  37(A6),(A1)+             *,
0000189A  4EB9 00004A2A            794              JSR     PrintDataReg
000018A0  4E75                     795              RTS                     ; return to input to get more input
000018A2                           796  
000018A2  7803                     797  ADD_W_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000018A4  4EB9 000048B0            798              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000018AA                           799  
000018AA  BABC 00000000            800              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000018B0  6700 003A                801              BEQ     ADD_W_SrcEA_M0
000018B4                           802  
000018B4  BABC 00000001            803              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
000018BA  6700 005E                804              BEQ     ADD_W_SrcEA_M1
000018BE                           805  
000018BE  BABC 00000002            806              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000018C4  6700 0082                807              BEQ     ADD_W_SrcEA_M2
000018C8                           808  
000018C8  BABC 00000003            809              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000018CE  6700 00A6                810              BEQ     ADD_W_SrcEA_M3
000018D2                           811  
000018D2  BABC 00000004            812              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000018D8  6700 00CA                813              BEQ     ADD_W_SrcEA_M4
000018DC                           814  
000018DC  BABC 00000007            815              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000018E2  6700 00EE                816              BEQ     ADD_W_SrcEA_M7
000018E6                           817  
000018E6  4EF9 000048A8            818              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000018EC                           819  
000018EC                           820  ADD_W_SrcEA_M0
000018EC  7803                     821              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000018EE  4EB9 000048B0            822              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000018F4  4EB9 00004A6A            823              JSR     PrintAdd
000018FA  4EB9 00004BE2            824              JSR     LengthW
00001900  4EB9 00004C10            825              JSR     PrintSpace
00001906  4EB9 00004A2A            826              JSR     PrintDataReg
0000190C                           827  
0000190C  1A00                     828              MOVE.B  D0,D5
0000190E  12EE 0025                829              MOVE.B  37(A6),(A1)+             *,
00001912  4EB9 00004A2A            830              JSR     PrintDataReg
00001918  4E75                     831              RTS                     ; return to input to get more input
0000191A                           832  
0000191A                           833  ADD_W_SrcEA_M1
0000191A  7803                     834              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000191C  4EB9 000048B0            835              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001922  4EB9 00004A6A            836              JSR     PrintAdd
00001928  4EB9 00004BE2            837              JSR     LengthW
0000192E  4EB9 00004C10            838              JSR     PrintSpace
00001934  4EB9 00004A36            839              JSR     PrintAddrReg
0000193A                           840  
0000193A  1A00                     841              MOVE.B  D0,D5
0000193C  12EE 0025                842              MOVE.B  37(A6),(A1)+             *,
00001940  4EB9 00004A2A            843              JSR     PrintDataReg
00001946  4E75                     844              RTS                     ; return to input to get more input
00001948                           845  
00001948                           846  ADD_W_SrcEA_M2
00001948  7803                     847              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000194A  4EB9 000048B0            848              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001950  4EB9 00004A6A            849              JSR     PrintAdd
00001956  4EB9 00004BE2            850              JSR     LengthW
0000195C  4EB9 00004C10            851              JSR     PrintSpace
00001962  4EB9 00004A42            852              JSR     PrintIndirAddrReg
00001968                           853  
00001968  1A00                     854              MOVE.B  D0,D5
0000196A  12EE 0025                855              MOVE.B  37(A6),(A1)+             *,
0000196E  4EB9 00004A2A            856              JSR     PrintDataReg
00001974  4E75                     857              RTS                     ; return to input to get more input
00001976                           858  
00001976                           859  ADD_W_SrcEA_M3
00001976  7803                     860              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001978  4EB9 000048B0            861              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000197E  4EB9 00004A6A            862              JSR     PrintAdd
00001984  4EB9 00004BE2            863              JSR     LengthW
0000198A  4EB9 00004C10            864              JSR     PrintSpace
00001990  4EB9 00004A50            865              JSR     PrintPostIncAddrReg
00001996                           866  
00001996  1A00                     867              MOVE.B  D0,D5
00001998  12EE 0025                868              MOVE.B  37(A6),(A1)+             *,
0000199C  4EB9 00004A2A            869              JSR     PrintDataReg
000019A2  4E75                     870              RTS                     ; return to input to get more input
000019A4                           871  
000019A4                           872  ADD_W_SrcEA_M4
000019A4  7803                     873              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000019A6  4EB9 000048B0            874              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000019AC  4EB9 00004A6A            875              JSR     PrintAdd
000019B2  4EB9 00004BE2            876              JSR     LengthW
000019B8  4EB9 00004C10            877              JSR     PrintSpace
000019BE  4EB9 00004A5A            878              JSR     PrintPreDeincAddrReg
000019C4                           879  
000019C4  1A00                     880              MOVE.B  D0,D5
000019C6  12EE 0025                881              MOVE.B  37(A6),(A1)+             *,
000019CA  4EB9 00004A2A            882              JSR     PrintDataReg
000019D0  4E75                     883              RTS                     ; return to input to get more input
000019D2                           884  
000019D2                           885  ADD_W_SrcEA_M7
000019D2  7803                     886              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000019D4  4EB9 000048B0            887              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000019DA                           888  
000019DA  BABC 00000000            889              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000019E0  6700 001C                890              BEQ     ADD_W_SrcEA_xxxW
000019E4                           891  
000019E4  BABC 00000001            892              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000019EA  6700 0038                893              BEQ     ADD_W_SrcEA_xxxL
000019EE                           894  
000019EE  BABC 00000004            895              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
000019F4  6700 0054                896              BEQ     ADD_W_SrcEA_Data
000019F8                           897  
000019F8  4EF9 000048A8            898              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000019FE                           899  
000019FE                           900  ADD_W_SrcEA_xxxW
000019FE  4EB9 00004A6A            901              JSR     PrintAdd
00001A04  4EB9 00004BE2            902              JSR     LengthW
00001A0A  4EB9 00004C10            903              JSR     PrintSpace
00001A10  4EB9 000049AA            904              JSR     PrintByteOrWord
00001A16                           905  
00001A16  1A00                     906              MOVE.B  D0,D5
00001A18  12EE 0025                907              MOVE.B  37(A6),(A1)+             *,
00001A1C  4EB9 00004A2A            908              JSR     PrintDataReg
00001A22  4E75                     909              RTS                     ; return to input to get more input
00001A24                           910  
00001A24                           911  ADD_W_SrcEA_xxxL
00001A24  4EB9 00004A6A            912              JSR     PrintAdd
00001A2A  4EB9 00004BE2            913              JSR     LengthW
00001A30  4EB9 00004C10            914              JSR     PrintSpace
00001A36  4EB9 000049C0            915              JSR     PrintLong
00001A3C                           916  
00001A3C  1A00                     917              MOVE.B  D0,D5
00001A3E  12EE 0025                918              MOVE.B  37(A6),(A1)+             *,
00001A42  4EB9 00004A2A            919              JSR     PrintDataReg
00001A48  4E75                     920              RTS                     ; return to input to get more input
00001A4A                           921  
00001A4A                           922  ADD_W_SrcEA_Data
00001A4A  4EB9 00004A6A            923              JSR     PrintAdd
00001A50  4EB9 00004BE2            924              JSR     LengthW
00001A56  4EB9 00004C10            925              JSR     PrintSpace
00001A5C  4EB9 0000499E            926              JSR     PrintImmediateData
00001A62                           927  
00001A62  1A00                     928              MOVE.B  D0,D5
00001A64  12EE 0025                929              MOVE.B  37(A6),(A1)+             *,
00001A68  4EB9 00004A2A            930              JSR     PrintDataReg
00001A6E  4E75                     931              RTS                     ; return to input to get more input
00001A70                           932  
00001A70  7803                     933  ADD_L_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001A72  4EB9 000048B0            934              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001A78                           935  
00001A78  BABC 00000000            936              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00001A7E  6700 003A                937              BEQ     ADD_L_SrcEA_M0
00001A82                           938  
00001A82  BABC 00000001            939              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00001A88  6700 005E                940              BEQ     ADD_L_SrcEA_M1
00001A8C                           941  
00001A8C  BABC 00000002            942              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001A92  6700 0082                943              BEQ     ADD_L_SrcEA_M2
00001A96                           944  
00001A96  BABC 00000003            945              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001A9C  6700 00A6                946              BEQ     ADD_L_SrcEA_M3
00001AA0                           947  
00001AA0  BABC 00000004            948              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001AA6  6700 00CA                949              BEQ     ADD_L_SrcEA_M4
00001AAA                           950  
00001AAA  BABC 00000007            951              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001AB0  6700 00EE                952              BEQ     ADD_L_SrcEA_M7
00001AB4                           953  
00001AB4  4EF9 000048A8            954              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001ABA                           955  
00001ABA                           956  ADD_L_SrcEA_M0
00001ABA  7803                     957              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001ABC  4EB9 000048B0            958              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001AC2  4EB9 00004A6A            959              JSR     PrintAdd
00001AC8  4EB9 00004BEC            960              JSR     LengthL
00001ACE  4EB9 00004C10            961              JSR     PrintSpace
00001AD4  4EB9 00004A2A            962              JSR     PrintDataReg
00001ADA                           963  
00001ADA  1A00                     964              MOVE.B  D0,D5
00001ADC  12EE 0025                965              MOVE.B  37(A6),(A1)+             *,
00001AE0  4EB9 00004A2A            966              JSR     PrintDataReg
00001AE6  4E75                     967              RTS                     ; return to input to get more input
00001AE8                           968  
00001AE8                           969  ADD_L_SrcEA_M1
00001AE8  7803                     970              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001AEA  4EB9 000048B0            971              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001AF0  4EB9 00004A6A            972              JSR     PrintAdd
00001AF6  4EB9 00004BEC            973              JSR     LengthL
00001AFC  4EB9 00004C10            974              JSR     PrintSpace
00001B02  4EB9 00004A36            975              JSR     PrintAddrReg
00001B08                           976  
00001B08  1A00                     977              MOVE.B  D0,D5
00001B0A  12EE 0025                978              MOVE.B  37(A6),(A1)+             *,
00001B0E  4EB9 00004A2A            979              JSR     PrintDataReg
00001B14  4E75                     980              RTS                     ; return to input to get more input
00001B16                           981  
00001B16                           982  ADD_L_SrcEA_M2
00001B16  7803                     983              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001B18  4EB9 000048B0            984              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001B1E  4EB9 00004A6A            985              JSR     PrintAdd
00001B24  4EB9 00004BEC            986              JSR     LengthL
00001B2A  4EB9 00004C10            987              JSR     PrintSpace
00001B30  4EB9 00004A42            988              JSR     PrintIndirAddrReg
00001B36                           989  
00001B36  1A00                     990              MOVE.B  D0,D5
00001B38  12EE 0025                991              MOVE.B  37(A6),(A1)+             *,
00001B3C  4EB9 00004A2A            992              JSR     PrintDataReg
00001B42  4E75                     993              RTS                     ; return to input to get more input
00001B44                           994  
00001B44                           995  ADD_L_SrcEA_M3
00001B44  7803                     996              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001B46  4EB9 000048B0            997              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001B4C  4EB9 00004A6A            998              JSR     PrintAdd
00001B52  4EB9 00004BEC            999              JSR     LengthL
00001B58  4EB9 00004C10           1000              JSR     PrintSpace
00001B5E  4EB9 00004A50           1001              JSR     PrintPostIncAddrReg
00001B64                          1002  
00001B64  1A00                    1003              MOVE.B  D0,D5
00001B66  12EE 0025               1004              MOVE.B  37(A6),(A1)+             *,
00001B6A  4EB9 00004A2A           1005              JSR     PrintDataReg
00001B70  4E75                    1006              RTS                     ; return to input to get more input
00001B72                          1007  
00001B72                          1008  ADD_L_SrcEA_M4
00001B72  7803                    1009              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001B74  4EB9 000048B0           1010              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001B7A  4EB9 00004A6A           1011              JSR     PrintAdd
00001B80  4EB9 00004BEC           1012              JSR     LengthL
00001B86  4EB9 00004C10           1013              JSR     PrintSpace
00001B8C  4EB9 00004A5A           1014              JSR     PrintPreDeincAddrReg
00001B92                          1015  
00001B92  1A00                    1016              MOVE.B  D0,D5
00001B94  12EE 0025               1017              MOVE.B  37(A6),(A1)+             *,
00001B98  4EB9 00004A2A           1018              JSR     PrintDataReg
00001B9E  4E75                    1019              RTS                     ; return to input to get more input
00001BA0                          1020  
00001BA0                          1021  ADD_L_SrcEA_M7
00001BA0  7803                    1022              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001BA2  4EB9 000048B0           1023              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001BA8                          1024  
00001BA8  BABC 00000000           1025              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001BAE  6700 001C               1026              BEQ     ADD_L_SrcEA_xxxW
00001BB2                          1027  
00001BB2  BABC 00000001           1028              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001BB8  6700 0038               1029              BEQ     ADD_L_SrcEA_xxxL
00001BBC                          1030  
00001BBC  BABC 00000004           1031              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00001BC2  6700 0054               1032              BEQ     ADD_L_SrcEA_Data
00001BC6                          1033  
00001BC6  4EF9 000048A8           1034              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001BCC                          1035  
00001BCC                          1036  ADD_L_SrcEA_xxxW
00001BCC  4EB9 00004A6A           1037              JSR     PrintAdd
00001BD2  4EB9 00004BEC           1038              JSR     LengthL
00001BD8  4EB9 00004C10           1039              JSR     PrintSpace
00001BDE  4EB9 000049AA           1040              JSR     PrintByteOrWord
00001BE4                          1041  
00001BE4  1A00                    1042              MOVE.B  D0,D5
00001BE6  12EE 0025               1043              MOVE.B  37(A6),(A1)+             *,
00001BEA  4EB9 00004A2A           1044              JSR     PrintDataReg
00001BF0  4E75                    1045              RTS                     ; return to input to get more input
00001BF2                          1046  
00001BF2                          1047  ADD_L_SrcEA_xxxL
00001BF2  4EB9 00004A6A           1048              JSR     PrintAdd
00001BF8  4EB9 00004BEC           1049              JSR     LengthL
00001BFE  4EB9 00004C10           1050              JSR     PrintSpace
00001C04  4EB9 000049C0           1051              JSR     PrintLong
00001C0A                          1052  
00001C0A  1A00                    1053              MOVE.B  D0,D5
00001C0C  12EE 0025               1054              MOVE.B  37(A6),(A1)+             *,
00001C10  4EB9 00004A2A           1055              JSR     PrintDataReg
00001C16  4E75                    1056              RTS                     ; return to input to get more input
00001C18                          1057  
00001C18                          1058  ADD_L_SrcEA_Data
00001C18  4EB9 00004A6A           1059              JSR     PrintAdd
00001C1E  4EB9 00004BEC           1060              JSR     LengthL
00001C24  4EB9 00004C10           1061              JSR     PrintSpace
00001C2A  4EB9 0000499E           1062              JSR     PrintImmediateData
00001C30                          1063  
00001C30  1A00                    1064              MOVE.B  D0,D5
00001C32  12EE 0025               1065              MOVE.B  37(A6),(A1)+             *,
00001C36  4EB9 00004A2A           1066              JSR     PrintDataReg
00001C3C  4E75                    1067              RTS                     ; return to input to get more input
00001C3E                          1068  
00001C3E  7803                    1069  ADD_B_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001C40  4EB9 000048B0           1070              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001C46                          1071  
00001C46  BABC 00000002           1072              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001C4C  6700 0026               1073              BEQ     ADD_B_DesEA_M2
00001C50                          1074  
00001C50  BABC 00000003           1075              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001C56  6700 004E               1076              BEQ     ADD_B_DesEA_M3
00001C5A                          1077  
00001C5A  BABC 00000004           1078              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001C60  6700 0072               1079              BEQ     ADD_B_DesEA_M4
00001C64                          1080  
00001C64  BABC 00000007           1081              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001C6A  6700 009A               1082              BEQ     ADD_B_DesEA_M7
00001C6E                          1083  
00001C6E  4EF9 000048A8           1084              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001C74                          1085  
00001C74                          1086  ADD_B_DesEA_M2
00001C74  7803                    1087              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001C76  4EB9 000048B0           1088              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001C7C  4EB9 00004A6A           1089              JSR     PrintAdd
00001C82  4EB9 00004BD8           1090              JSR     LengthB
00001C88  4EB9 00004C10           1091              JSR     PrintSpace
00001C8E                          1092  
00001C8E  1E05                    1093              MOVE.B  D5,D7
00001C90  1A00                    1094              MOVE.B  D0,D5
00001C92  4EB9 00004A2A           1095              JSR     PrintDataReg
00001C98                          1096  
00001C98  1A07                    1097              MOVE.B  D7,D5
00001C9A  12EE 0025               1098              MOVE.B  37(A6),(A1)+             *,
00001C9E  4EB9 00004A42           1099              JSR     PrintIndirAddrReg
00001CA4  4E75                    1100              RTS                     ; return to input to get more input
00001CA6                          1101  
00001CA6                          1102  ADD_B_DesEA_M3
00001CA6  7803                    1103              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001CA8  4EB9 000048B0           1104              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001CAE  4EB9 00004A6A           1105              JSR     PrintAdd
00001CB4  4EB9 00004BD8           1106              JSR     LengthB
00001CBA  4EB9 00004C10           1107              JSR     PrintSpace
00001CC0  4EB9 00004A50           1108              JSR     PrintPostIncAddrReg
00001CC6                          1109  
00001CC6  1A00                    1110              MOVE.B  D0,D5
00001CC8  12EE 0025               1111              MOVE.B  37(A6),(A1)+             *,
00001CCC  4EB9 00004A2A           1112              JSR     PrintDataReg
00001CD2  4E75                    1113              RTS                     ; return to input to get more input
00001CD4                          1114  
00001CD4                          1115  ADD_B_DesEA_M4
00001CD4  7803                    1116              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001CD6  4EB9 000048B0           1117              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001CDC  4EB9 00004A6A           1118              JSR     PrintAdd
00001CE2  4EB9 00004BD8           1119              JSR     LengthB
00001CE8  4EB9 00004C10           1120              JSR     PrintSpace
00001CEE                          1121  
00001CEE  1E05                    1122              MOVE.B  D5,D7
00001CF0  1A00                    1123              MOVE.B  D0,D5
00001CF2  4EB9 00004A2A           1124              JSR     PrintDataReg
00001CF8                          1125  
00001CF8  1A07                    1126              MOVE.B  D7,D5
00001CFA  12EE 0025               1127              MOVE.B  37(A6),(A1)+             *,
00001CFE  4EB9 00004A5A           1128              JSR     PrintPreDeincAddrReg
00001D04  4E75                    1129              RTS                     ; return to input to get more input
00001D06                          1130  
00001D06                          1131  ADD_B_DesEA_M7
00001D06  7803                    1132              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001D08  4EB9 000048B0           1133              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001D0E                          1134  
00001D0E  BABC 00000000           1135              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001D14  6700 0012               1136              BEQ     ADD_B_DesEA_xxxW
00001D18                          1137  
00001D18  BABC 00000001           1138              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001D1E  6700 0032               1139              BEQ     ADD_B_DesEA_xxxL
00001D22                          1140  
00001D22  4EF9 000048A8           1141              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001D28                          1142  
00001D28                          1143  ADD_B_DesEA_xxxW
00001D28  4EB9 00004A6A           1144              JSR     PrintAdd
00001D2E  4EB9 00004BD8           1145              JSR     LengthB
00001D34  4EB9 00004C10           1146              JSR     PrintSpace
00001D3A                          1147  
00001D3A  1E05                    1148              MOVE.B  D5,D7
00001D3C  1A00                    1149              MOVE.B  D0,D5
00001D3E  4EB9 00004A2A           1150              JSR     PrintDataReg
00001D44                          1151  
00001D44  1A07                    1152              MOVE.B  D7,D5
00001D46  12EE 0025               1153              MOVE.B  37(A6),(A1)+             *,
00001D4A  4EB9 000049AA           1154              JSR     PrintByteOrWord
00001D50  4E75                    1155              RTS                     ; return to input to get more input
00001D52                          1156  
00001D52                          1157  ADD_B_DesEA_xxxL
00001D52  4EB9 00004A6A           1158              JSR     PrintAdd
00001D58  4EB9 00004BD8           1159              JSR     LengthB
00001D5E  4EB9 00004C10           1160              JSR     PrintSpace
00001D64                          1161  
00001D64  1E05                    1162              MOVE.B  D5,D7
00001D66  1A00                    1163              MOVE.B  D0,D5
00001D68  4EB9 00004A2A           1164              JSR     PrintDataReg
00001D6E                          1165  
00001D6E  1A07                    1166              MOVE.B  D7,D5
00001D70  12EE 0025               1167              MOVE.B  37(A6),(A1)+             *,
00001D74  4EB9 000049C0           1168              JSR     PrintLong
00001D7A  4E75                    1169              RTS                     ; return to input to get more input
00001D7C                          1170  
00001D7C  7803                    1171  ADD_W_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001D7E  4EB9 000048B0           1172              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001D84                          1173  
00001D84  BABC 00000002           1174              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001D8A  6700 0026               1175              BEQ     ADD_W_DesEA_M2
00001D8E                          1176  
00001D8E  BABC 00000003           1177              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001D94  6700 004E               1178              BEQ     ADD_W_DesEA_M3
00001D98                          1179  
00001D98  BABC 00000004           1180              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001D9E  6700 0072               1181              BEQ     ADD_W_DesEA_M4
00001DA2                          1182  
00001DA2  BABC 00000007           1183              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001DA8  6700 009A               1184              BEQ     ADD_W_DesEA_M7
00001DAC                          1185  
00001DAC  4EF9 000048A8           1186              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001DB2                          1187  
00001DB2                          1188  ADD_W_DesEA_M2
00001DB2  7803                    1189              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001DB4  4EB9 000048B0           1190              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001DBA  4EB9 00004A6A           1191              JSR     PrintAdd
00001DC0  4EB9 00004BE2           1192              JSR     LengthW
00001DC6  4EB9 00004C10           1193              JSR     PrintSpace
00001DCC                          1194  
00001DCC  1E05                    1195              MOVE.B  D5,D7
00001DCE  1A00                    1196              MOVE.B  D0,D5
00001DD0  4EB9 00004A2A           1197              JSR     PrintDataReg
00001DD6                          1198  
00001DD6  1A07                    1199              MOVE.B  D7,D5
00001DD8  12EE 0025               1200              MOVE.B  37(A6),(A1)+             *,
00001DDC  4EB9 00004A42           1201              JSR     PrintIndirAddrReg
00001DE2  4E75                    1202              RTS                     ; return to input to get more input
00001DE4                          1203  
00001DE4                          1204  ADD_W_DesEA_M3
00001DE4  7803                    1205              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001DE6  4EB9 000048B0           1206              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001DEC  4EB9 00004A6A           1207              JSR     PrintAdd
00001DF2  4EB9 00004BE2           1208              JSR     LengthW
00001DF8  4EB9 00004C10           1209              JSR     PrintSpace
00001DFE  4EB9 00004A50           1210              JSR     PrintPostIncAddrReg
00001E04                          1211  
00001E04  1A00                    1212              MOVE.B  D0,D5
00001E06  12EE 0025               1213              MOVE.B  37(A6),(A1)+             *,
00001E0A  4EB9 00004A2A           1214              JSR     PrintDataReg
00001E10  4E75                    1215              RTS                     ; return to input to get more input
00001E12                          1216  
00001E12                          1217  ADD_W_DesEA_M4
00001E12  7803                    1218              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001E14  4EB9 000048B0           1219              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001E1A  4EB9 00004A6A           1220              JSR     PrintAdd
00001E20  4EB9 00004BE2           1221              JSR     LengthW
00001E26  4EB9 00004C10           1222              JSR     PrintSpace
00001E2C                          1223  
00001E2C  1E05                    1224              MOVE.B  D5,D7
00001E2E  1A00                    1225              MOVE.B  D0,D5
00001E30  4EB9 00004A2A           1226              JSR     PrintDataReg
00001E36                          1227  
00001E36  1A07                    1228              MOVE.B  D7,D5
00001E38  12EE 0025               1229              MOVE.B  37(A6),(A1)+             *,
00001E3C  4EB9 00004A5A           1230              JSR     PrintPreDeincAddrReg
00001E42  4E75                    1231              RTS                     ; return to input to get more input
00001E44                          1232  
00001E44                          1233  ADD_W_DesEA_M7
00001E44  7803                    1234              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001E46  4EB9 000048B0           1235              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001E4C                          1236  
00001E4C  BABC 00000000           1237              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001E52  6700 0012               1238              BEQ     ADD_W_DesEA_xxxW
00001E56                          1239  
00001E56  BABC 00000001           1240              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001E5C  6700 0032               1241              BEQ     ADD_W_DesEA_xxxL
00001E60                          1242  
00001E60  4EF9 000048A8           1243              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001E66                          1244  
00001E66                          1245  ADD_W_DesEA_xxxW
00001E66  4EB9 00004A6A           1246              JSR     PrintAdd
00001E6C  4EB9 00004BE2           1247              JSR     LengthW
00001E72  4EB9 00004C10           1248              JSR     PrintSpace
00001E78                          1249  
00001E78  1E05                    1250              MOVE.B  D5,D7
00001E7A  1A00                    1251              MOVE.B  D0,D5
00001E7C  4EB9 00004A2A           1252              JSR     PrintDataReg
00001E82                          1253  
00001E82  1A07                    1254              MOVE.B  D7,D5
00001E84  12EE 0025               1255              MOVE.B  37(A6),(A1)+             *,
00001E88  4EB9 000049AA           1256              JSR     PrintByteOrWord
00001E8E  4E75                    1257              RTS                     ; return to input to get more input
00001E90                          1258  
00001E90                          1259  ADD_W_DesEA_xxxL
00001E90  4EB9 00004A6A           1260              JSR     PrintAdd
00001E96  4EB9 00004BE2           1261              JSR     LengthW
00001E9C  4EB9 00004C10           1262              JSR     PrintSpace
00001EA2                          1263  
00001EA2  1E05                    1264              MOVE.B  D5,D7
00001EA4  1A00                    1265              MOVE.B  D0,D5
00001EA6  4EB9 00004A2A           1266              JSR     PrintDataReg
00001EAC                          1267  
00001EAC  1A07                    1268              MOVE.B  D7,D5
00001EAE  12EE 0025               1269              MOVE.B  37(A6),(A1)+             *,
00001EB2  4EB9 000049C0           1270              JSR     PrintLong
00001EB8  4E75                    1271              RTS                     ; return to input to get more input
00001EBA                          1272  
00001EBA                          1273  ADD_L_DesEA
00001EBA  7803                    1274              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00001EBC  4EB9 000048B0           1275              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00001EC2                          1276  
00001EC2  BABC 00000002           1277              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00001EC8  6700 0026               1278              BEQ     ADD_L_DesEA_M2
00001ECC                          1279  
00001ECC  BABC 00000003           1280              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00001ED2  6700 004E               1281              BEQ     ADD_L_DesEA_M3
00001ED6                          1282  
00001ED6  BABC 00000004           1283              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00001EDC  6700 0072               1284              BEQ     ADD_L_DesEA_M4
00001EE0                          1285  
00001EE0  BABC 00000007           1286              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00001EE6  6700 009A               1287              BEQ     ADD_L_DesEA_M7
00001EEA                          1288  
00001EEA  4EF9 000048A8           1289              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001EF0                          1290  
00001EF0                          1291  ADD_L_DesEA_M2
00001EF0  7803                    1292              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001EF2  4EB9 000048B0           1293              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001EF8  4EB9 00004A6A           1294              JSR     PrintAdd
00001EFE  4EB9 00004BEC           1295              JSR     LengthL
00001F04  4EB9 00004C10           1296              JSR     PrintSpace
00001F0A                          1297  
00001F0A  1E05                    1298              MOVE.B  D5,D7
00001F0C  1A00                    1299              MOVE.B  D0,D5
00001F0E  4EB9 00004A2A           1300              JSR     PrintDataReg
00001F14                          1301  
00001F14  1A07                    1302              MOVE.B  D7,D5
00001F16  12EE 0025               1303              MOVE.B  37(A6),(A1)+             *,
00001F1A  4EB9 00004A42           1304              JSR     PrintIndirAddrReg
00001F20  4E75                    1305              RTS                     ; return to input to get more input
00001F22                          1306  
00001F22                          1307  ADD_L_DesEA_M3
00001F22  7803                    1308              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001F24  4EB9 000048B0           1309              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001F2A  4EB9 00004A6A           1310              JSR     PrintAdd
00001F30  4EB9 00004BEC           1311              JSR     LengthL
00001F36  4EB9 00004C10           1312              JSR     PrintSpace
00001F3C  4EB9 00004A50           1313              JSR     PrintPostIncAddrReg
00001F42                          1314  
00001F42  1A00                    1315              MOVE.B  D0,D5
00001F44  12EE 0025               1316              MOVE.B  37(A6),(A1)+             *,
00001F48  4EB9 00004A2A           1317              JSR     PrintDataReg
00001F4E  4E75                    1318              RTS                     ; return to input to get more input
00001F50                          1319  
00001F50                          1320  ADD_L_DesEA_M4
00001F50  7803                    1321              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001F52  4EB9 000048B0           1322              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001F58  4EB9 00004A6A           1323              JSR     PrintAdd
00001F5E  4EB9 00004BEC           1324              JSR     LengthL
00001F64  4EB9 00004C10           1325              JSR     PrintSpace
00001F6A                          1326  
00001F6A  1E05                    1327              MOVE.B  D5,D7
00001F6C  1A00                    1328              MOVE.B  D0,D5
00001F6E  4EB9 00004A2A           1329              JSR     PrintDataReg
00001F74                          1330  
00001F74  1A07                    1331              MOVE.B  D7,D5
00001F76  12EE 0025               1332              MOVE.B  37(A6),(A1)+             *,
00001F7A  4EB9 00004A5A           1333              JSR     PrintPreDeincAddrReg
00001F80  4E75                    1334              RTS                     ; return to input to get more input
00001F82                          1335  
00001F82                          1336  ADD_L_DesEA_M7
00001F82  7803                    1337              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00001F84  4EB9 000048B0           1338              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00001F8A                          1339  
00001F8A  BABC 00000000           1340              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00001F90  6700 0012               1341              BEQ     ADD_L_DesEA_xxxW
00001F94                          1342  
00001F94  BABC 00000001           1343              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00001F9A  6700 0032               1344              BEQ     ADD_L_DesEA_xxxL
00001F9E                          1345  
00001F9E  4EF9 000048A8           1346              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00001FA4                          1347  
00001FA4                          1348  ADD_L_DesEA_xxxW
00001FA4  4EB9 00004A6A           1349              JSR     PrintAdd
00001FAA  4EB9 00004BEC           1350              JSR     LengthL
00001FB0  4EB9 00004C10           1351              JSR     PrintSpace
00001FB6                          1352  
00001FB6  1E05                    1353              MOVE.B  D5,D7
00001FB8  1A00                    1354              MOVE.B  D0,D5
00001FBA  4EB9 00004A2A           1355              JSR     PrintDataReg
00001FC0                          1356  
00001FC0  1A07                    1357              MOVE.B  D7,D5
00001FC2  12EE 0025               1358              MOVE.B  37(A6),(A1)+             *,
00001FC6  4EB9 000049AA           1359              JSR     PrintByteOrWord
00001FCC  4E75                    1360              RTS                     ; return to input to get more input
00001FCE                          1361  
00001FCE                          1362  ADD_L_DesEA_xxxL
00001FCE  4EB9 00004A6A           1363              JSR     PrintAdd
00001FD4  4EB9 00004BEC           1364              JSR     LengthL
00001FDA  4EB9 00004C10           1365              JSR     PrintSpace
00001FE0                          1366  
00001FE0  1E05                    1367              MOVE.B  D5,D7
00001FE2  1A00                    1368              MOVE.B  D0,D5
00001FE4  4EB9 00004A2A           1369              JSR     PrintDataReg
00001FEA                          1370  
00001FEA  1A07                    1371              MOVE.B  D7,D5
00001FEC  12EE 0025               1372              MOVE.B  37(A6),(A1)+             *,
00001FF0  4EB9 000049C0           1373              JSR     PrintLong
00001FF6  4E75                    1374              RTS                     ; return to input to get more input
00001FF8                          1375  
00001FF8                          1376  
00001FF8                          1377  *************************************************                MULS_W_AND_Opcode          *************************************************
00001FF8                          1378  ; first four bit is (1100 #### #### ####)
00001FF8                          1379  MULS_W_AND_Opcode
00001FF8  7803                    1380              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00001FFA  4EB9 000048B0           1381              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00002000                          1382  
00002000  2005                    1383              MOVE.L  D5,D0               ; D0 will hold the register
00002002                          1384          ; D0 will hold the register (position 11-9)
00002002                          1385  
00002002  7803                    1386              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00002004  4EB9 000048B0           1387              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the opmode, and opcode
0000200A                          1388  
0000200A  BABC 00000000           1389              CMP.L   #0,D5               ; if opmode is 0, it is a byte with location specified is a source  (<ea> ^ Dn -> Dn)
00002010  6700 0044               1390              BEQ     And_B_SrcEA
00002014                          1391  
00002014  BABC 00000001           1392              CMP.L   #1,D5               ; if opmode is 1, it is a word with location specified is a source  (<ea> ^ Dn -> Dn)
0000201A  6700 01D0               1393              BEQ     And_W_SrcEA
0000201E                          1394  
0000201E  BABC 00000002           1395              CMP.L   #2,D5               ; if opmode is 2, it is a long with location specified is a source  (<ea> ^ Dn -> Dn)
00002024  6700 035C               1396              BEQ     And_L_SrcEA
00002028                          1397  
00002028  BABC 00000004           1398              CMP.L   #4,D5               ; if opmode is 4, it is a byte with location specified is desination (Dn ^ <ea> -> <ea>)
0000202E  6700 04E8               1399              BEQ     And_B_DesEA
00002032                          1400  
00002032  BABC 00000005           1401              CMP.L   #5,D5               ; if opmode is 5, it is a word with location specified is desination (Dn ^ <ea> -> <ea>)
00002038  6700 0620               1402              BEQ     And_W_DesEA
0000203C                          1403  
0000203C  BABC 00000006           1404              CMP.L   #6,D5               ; if opmode is 6, it is a long with location specified is desination (Dn ^ <ea> -> <ea>)
00002042  6700 0758               1405              BEQ     And_L_DesEA
00002046                          1406  
00002046  BABC 00000007           1407              CMP.L   #7,D5               ; if opmode is 7, the opcode is MULS.W
0000204C  6700 0890               1408              BEQ     MULS_W
00002050                          1409  
00002050  4EF9 000048A8           1410              JMP     InvalidOpcode       ; it is not valid since it is not one of the valid opmode
00002056                          1411  
00002056  7803                    1412  And_B_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002058  4EB9 000048B0           1413              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
0000205E                          1414  
0000205E  BABC 00000000           1415              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002064  6700 0030               1416              BEQ     And_B_SrcEA_M0
00002068                          1417  
00002068  BABC 00000002           1418              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
0000206E  6700 0054               1419              BEQ     And_B_SrcEA_M2
00002072                          1420  
00002072  BABC 00000003           1421              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002078  6700 0078               1422              BEQ     And_B_SrcEA_M3
0000207C                          1423  
0000207C  BABC 00000004           1424              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002082  6700 009C               1425              BEQ     And_B_SrcEA_M4
00002086                          1426  
00002086  BABC 00000007           1427              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
0000208C  6700 00C0               1428              BEQ     And_B_SrcEA_M7
00002090                          1429  
00002090  4EF9 000048A8           1430              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002096                          1431  
00002096                          1432  And_B_SrcEA_M0
00002096  7803                    1433              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002098  4EB9 000048B0           1434              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000209E  4EB9 00004A8C           1435              JSR     PrintAnd
000020A4  4EB9 00004BD8           1436              JSR     LengthB
000020AA  4EB9 00004C10           1437              JSR     PrintSpace
000020B0  4EB9 00004A2A           1438              JSR     PrintDataReg
000020B6                          1439  
000020B6  1A00                    1440              MOVE.B  D0,D5
000020B8  12EE 0025               1441              MOVE.B  37(A6),(A1)+             *,
000020BC  4EB9 00004A2A           1442              JSR     PrintDataReg
000020C2  4E75                    1443              RTS                     ; return to input to get more input
000020C4                          1444  
000020C4                          1445  And_B_SrcEA_M2
000020C4  7803                    1446              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000020C6  4EB9 000048B0           1447              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000020CC  4EB9 00004A8C           1448              JSR     PrintAnd
000020D2  4EB9 00004BD8           1449              JSR     LengthB
000020D8  4EB9 00004C10           1450              JSR     PrintSpace
000020DE  4EB9 00004A42           1451              JSR     PrintIndirAddrReg
000020E4                          1452  
000020E4  1A00                    1453              MOVE.B  D0,D5
000020E6  12EE 0025               1454              MOVE.B  37(A6),(A1)+             *,
000020EA  4EB9 00004A2A           1455              JSR     PrintDataReg
000020F0  4E75                    1456              RTS                     ; return to input to get more input
000020F2                          1457  
000020F2                          1458  And_B_SrcEA_M3
000020F2  7803                    1459              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000020F4  4EB9 000048B0           1460              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000020FA  4EB9 00004A8C           1461              JSR     PrintAnd
00002100  4EB9 00004BD8           1462              JSR     LengthB
00002106  4EB9 00004C10           1463              JSR     PrintSpace
0000210C  4EB9 00004A50           1464              JSR     PrintPostIncAddrReg
00002112                          1465  
00002112  1A00                    1466              MOVE.B  D0,D5
00002114  12EE 0025               1467              MOVE.B  37(A6),(A1)+             *,
00002118  4EB9 00004A2A           1468              JSR     PrintDataReg
0000211E  4E75                    1469              RTS                     ; return to input to get more input
00002120                          1470  
00002120                          1471  And_B_SrcEA_M4
00002120  7803                    1472              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002122  4EB9 000048B0           1473              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002128  4EB9 00004A8C           1474              JSR     PrintAnd
0000212E  4EB9 00004BD8           1475              JSR     LengthB
00002134  4EB9 00004C10           1476              JSR     PrintSpace
0000213A  4EB9 00004A5A           1477              JSR     PrintPreDeincAddrReg
00002140                          1478  
00002140  1A00                    1479              MOVE.B  D0,D5
00002142  12EE 0025               1480              MOVE.B  37(A6),(A1)+             *,
00002146  4EB9 00004A2A           1481              JSR     PrintDataReg
0000214C  4E75                    1482              RTS                     ; return to input to get more input
0000214E                          1483  
0000214E                          1484  And_B_SrcEA_M7
0000214E  7803                    1485              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002150  4EB9 000048B0           1486              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002156                          1487  
00002156  BABC 00000000           1488              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
0000215C  6700 001C               1489              BEQ     And_B_SrcEA_xxxW
00002160                          1490  
00002160  BABC 00000001           1491              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002166  6700 0038               1492              BEQ     And_B_SrcEA_xxxL
0000216A                          1493  
0000216A  BABC 00000004           1494              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002170  6700 0054               1495              BEQ     And_B_SrcEA_Data
00002174                          1496  
00002174  4EF9 000048A8           1497              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000217A                          1498  
0000217A                          1499  And_B_SrcEA_xxxW
0000217A  4EB9 00004A8C           1500              JSR     PrintAnd
00002180  4EB9 00004BD8           1501              JSR     LengthB
00002186  4EB9 00004C10           1502              JSR     PrintSpace
0000218C  4EB9 000049AA           1503              JSR     PrintByteOrWord
00002192                          1504  
00002192  1A00                    1505              MOVE.B  D0,D5
00002194  12EE 0025               1506              MOVE.B  37(A6),(A1)+             *,
00002198  4EB9 00004A2A           1507              JSR     PrintDataReg
0000219E  4E75                    1508              RTS                     ; return to input to get more input
000021A0                          1509  
000021A0                          1510  And_B_SrcEA_xxxL
000021A0  4EB9 00004A8C           1511              JSR     PrintAnd
000021A6  4EB9 00004BD8           1512              JSR     LengthB
000021AC  4EB9 00004C10           1513              JSR     PrintSpace
000021B2  4EB9 000049C0           1514              JSR     PrintLong
000021B8                          1515  
000021B8  1A00                    1516              MOVE.B  D0,D5
000021BA  12EE 0025               1517              MOVE.B  37(A6),(A1)+             *,
000021BE  4EB9 00004A2A           1518              JSR     PrintDataReg
000021C4  4E75                    1519              RTS                     ; return to input to get more input
000021C6                          1520  
000021C6                          1521  And_B_SrcEA_Data
000021C6  4EB9 00004A8C           1522              JSR     PrintAnd
000021CC  4EB9 00004BD8           1523              JSR     LengthB
000021D2  4EB9 00004C10           1524              JSR     PrintSpace
000021D8  4EB9 0000499E           1525              JSR     PrintImmediateData
000021DE                          1526  
000021DE  1A00                    1527              MOVE.B  D0,D5
000021E0  12EE 0025               1528              MOVE.B  37(A6),(A1)+             *,
000021E4  4EB9 00004A2A           1529              JSR     PrintDataReg
000021EA  4E75                    1530              RTS                     ; return to input to get more input
000021EC                          1531  
000021EC  7803                    1532  And_W_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000021EE  4EB9 000048B0           1533              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000021F4                          1534  
000021F4  BABC 00000000           1535              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000021FA  6700 0030               1536              BEQ     And_W_SrcEA_M0
000021FE                          1537  
000021FE  BABC 00000002           1538              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002204  6700 0054               1539              BEQ     And_W_SrcEA_M2
00002208                          1540  
00002208  BABC 00000003           1541              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
0000220E  6700 0078               1542              BEQ     And_W_SrcEA_M3
00002212                          1543  
00002212  BABC 00000004           1544              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002218  6700 009C               1545              BEQ     And_W_SrcEA_M4
0000221C                          1546  
0000221C  BABC 00000007           1547              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002222  6700 00C0               1548              BEQ     And_W_SrcEA_M7
00002226                          1549  
00002226  4EF9 000048A8           1550              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000222C                          1551  
0000222C                          1552  And_W_SrcEA_M0
0000222C  7803                    1553              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000222E  4EB9 000048B0           1554              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002234  4EB9 00004A8C           1555              JSR     PrintAnd
0000223A  4EB9 00004BE2           1556              JSR     LengthW
00002240  4EB9 00004C10           1557              JSR     PrintSpace
00002246  4EB9 00004A2A           1558              JSR     PrintDataReg
0000224C                          1559  
0000224C  1A00                    1560              MOVE.B  D0,D5
0000224E  12EE 0025               1561              MOVE.B  37(A6),(A1)+             *,
00002252  4EB9 00004A2A           1562              JSR     PrintDataReg
00002258  4E75                    1563              RTS                     ; return to input to get more input
0000225A                          1564  
0000225A                          1565  And_W_SrcEA_M2
0000225A  7803                    1566              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000225C  4EB9 000048B0           1567              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002262  4EB9 00004A8C           1568              JSR     PrintAnd
00002268  4EB9 00004BE2           1569              JSR     LengthW
0000226E  4EB9 00004C10           1570              JSR     PrintSpace
00002274  4EB9 00004A42           1571              JSR     PrintIndirAddrReg
0000227A                          1572  
0000227A  1A00                    1573              MOVE.B  D0,D5
0000227C  12EE 0025               1574              MOVE.B  37(A6),(A1)+             *,
00002280  4EB9 00004A2A           1575              JSR     PrintDataReg
00002286  4E75                    1576              RTS                     ; return to input to get more input
00002288                          1577  
00002288                          1578  And_W_SrcEA_M3
00002288  7803                    1579              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000228A  4EB9 000048B0           1580              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002290  4EB9 00004A8C           1581              JSR     PrintAnd
00002296  4EB9 00004BE2           1582              JSR     LengthW
0000229C  4EB9 00004C10           1583              JSR     PrintSpace
000022A2  4EB9 00004A50           1584              JSR     PrintPostIncAddrReg
000022A8                          1585  
000022A8  1A00                    1586              MOVE.B  D0,D5
000022AA  12EE 0025               1587              MOVE.B  37(A6),(A1)+             *,
000022AE  4EB9 00004A2A           1588              JSR     PrintDataReg
000022B4  4E75                    1589              RTS                     ; return to input to get more input
000022B6                          1590  
000022B6                          1591  And_W_SrcEA_M4
000022B6  7803                    1592              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000022B8  4EB9 000048B0           1593              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000022BE  4EB9 00004A8C           1594              JSR     PrintAnd
000022C4  4EB9 00004BE2           1595              JSR     LengthW
000022CA  4EB9 00004C10           1596              JSR     PrintSpace
000022D0  4EB9 00004A5A           1597              JSR     PrintPreDeincAddrReg
000022D6                          1598  
000022D6  1A00                    1599              MOVE.B  D0,D5
000022D8  12EE 0025               1600              MOVE.B  37(A6),(A1)+             *,
000022DC  4EB9 00004A2A           1601              JSR     PrintDataReg
000022E2  4E75                    1602              RTS                     ; return to input to get more input
000022E4                          1603  
000022E4                          1604  And_W_SrcEA_M7
000022E4  7803                    1605              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000022E6  4EB9 000048B0           1606              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000022EC                          1607  
000022EC  BABC 00000000           1608              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000022F2  6700 001C               1609              BEQ     And_W_SrcEA_xxxW
000022F6                          1610  
000022F6  BABC 00000001           1611              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000022FC  6700 0038               1612              BEQ     And_W_SrcEA_xxxL
00002300                          1613  
00002300  BABC 00000004           1614              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002306  6700 0054               1615              BEQ     And_W_SrcEA_Data
0000230A                          1616  
0000230A  4EF9 000048A8           1617              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002310                          1618  
00002310                          1619  And_W_SrcEA_xxxW
00002310  4EB9 00004A8C           1620              JSR     PrintAnd
00002316  4EB9 00004BE2           1621              JSR     LengthW
0000231C  4EB9 00004C10           1622              JSR     PrintSpace
00002322  4EB9 000049AA           1623              JSR     PrintByteOrWord
00002328                          1624  
00002328  1A00                    1625              MOVE.B  D0,D5
0000232A  12EE 0025               1626              MOVE.B  37(A6),(A1)+             *,
0000232E  4EB9 00004A2A           1627              JSR     PrintDataReg
00002334  4E75                    1628              RTS                     ; return to input to get more input
00002336                          1629  
00002336                          1630  And_W_SrcEA_xxxL
00002336  4EB9 00004A8C           1631              JSR     PrintAnd
0000233C  4EB9 00004BE2           1632              JSR     LengthW
00002342  4EB9 00004C10           1633              JSR     PrintSpace
00002348  4EB9 000049C0           1634              JSR     PrintLong
0000234E                          1635  
0000234E  1A00                    1636              MOVE.B  D0,D5
00002350  12EE 0025               1637              MOVE.B  37(A6),(A1)+             *,
00002354  4EB9 00004A2A           1638              JSR     PrintDataReg
0000235A  4E75                    1639              RTS                     ; return to input to get more input
0000235C                          1640  
0000235C                          1641  And_W_SrcEA_Data
0000235C  4EB9 00004A8C           1642              JSR     PrintAnd
00002362  4EB9 00004BE2           1643              JSR     LengthW
00002368  4EB9 00004C10           1644              JSR     PrintSpace
0000236E  4EB9 0000499E           1645              JSR     PrintImmediateData
00002374                          1646  
00002374  1A00                    1647              MOVE.B  D0,D5
00002376  12EE 0025               1648              MOVE.B  37(A6),(A1)+             *,
0000237A  4EB9 00004A2A           1649              JSR     PrintDataReg
00002380  4E75                    1650              RTS                     ; return to input to get more input
00002382                          1651  
00002382  7803                    1652  And_L_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002384  4EB9 000048B0           1653              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
0000238A                          1654  
0000238A  BABC 00000000           1655              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002390  6700 0030               1656              BEQ     And_L_SrcEA_M0
00002394                          1657  
00002394  BABC 00000002           1658              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
0000239A  6700 0054               1659              BEQ     And_L_SrcEA_M2
0000239E                          1660  
0000239E  BABC 00000003           1661              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000023A4  6700 0078               1662              BEQ     And_L_SrcEA_M3
000023A8                          1663  
000023A8  BABC 00000004           1664              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000023AE  6700 009C               1665              BEQ     And_L_SrcEA_M4
000023B2                          1666  
000023B2  BABC 00000007           1667              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000023B8  6700 00C0               1668              BEQ     And_L_SrcEA_M7
000023BC                          1669  
000023BC  4EF9 000048A8           1670              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000023C2                          1671  
000023C2                          1672  And_L_SrcEA_M0
000023C2  7803                    1673              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000023C4  4EB9 000048B0           1674              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000023CA  4EB9 00004A8C           1675              JSR     PrintAnd
000023D0  4EB9 00004BEC           1676              JSR     LengthL
000023D6  4EB9 00004C10           1677              JSR     PrintSpace
000023DC  4EB9 00004A2A           1678              JSR     PrintDataReg
000023E2                          1679  
000023E2  1A00                    1680              MOVE.B  D0,D5
000023E4  12EE 0025               1681              MOVE.B  37(A6),(A1)+             *,
000023E8  4EB9 00004A2A           1682              JSR     PrintDataReg
000023EE  4E75                    1683              RTS                     ; return to input to get more input
000023F0                          1684  
000023F0                          1685  And_L_SrcEA_M2
000023F0  7803                    1686              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000023F2  4EB9 000048B0           1687              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000023F8  4EB9 00004A8C           1688              JSR     PrintAnd
000023FE  4EB9 00004BEC           1689              JSR     LengthL
00002404  4EB9 00004C10           1690              JSR     PrintSpace
0000240A  4EB9 00004A42           1691              JSR     PrintIndirAddrReg
00002410                          1692  
00002410  1A00                    1693              MOVE.B  D0,D5
00002412  12EE 0025               1694              MOVE.B  37(A6),(A1)+             *,
00002416  4EB9 00004A2A           1695              JSR     PrintDataReg
0000241C  4E75                    1696              RTS                     ; return to input to get more input
0000241E                          1697  
0000241E                          1698  And_L_SrcEA_M3
0000241E  7803                    1699              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002420  4EB9 000048B0           1700              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002426  4EB9 00004A8C           1701              JSR     PrintAnd
0000242C  4EB9 00004BEC           1702              JSR     LengthL
00002432  4EB9 00004C10           1703              JSR     PrintSpace
00002438  4EB9 00004A50           1704              JSR     PrintPostIncAddrReg
0000243E                          1705  
0000243E  1A00                    1706              MOVE.B  D0,D5
00002440  12EE 0025               1707              MOVE.B  37(A6),(A1)+             *,
00002444  4EB9 00004A2A           1708              JSR     PrintDataReg
0000244A  4E75                    1709              RTS                     ; return to input to get more input
0000244C                          1710  
0000244C                          1711  And_L_SrcEA_M4
0000244C  7803                    1712              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000244E  4EB9 000048B0           1713              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002454  4EB9 00004A8C           1714              JSR     PrintAnd
0000245A  4EB9 00004BEC           1715              JSR     LengthL
00002460  4EB9 00004C10           1716              JSR     PrintSpace
00002466  4EB9 00004A5A           1717              JSR     PrintPreDeincAddrReg
0000246C                          1718  
0000246C  1A00                    1719              MOVE.B  D0,D5
0000246E  12EE 0025               1720              MOVE.B  37(A6),(A1)+             *,
00002472  4EB9 00004A2A           1721              JSR     PrintDataReg
00002478  4E75                    1722              RTS                     ; return to input to get more input
0000247A                          1723  
0000247A                          1724  And_L_SrcEA_M7
0000247A  7803                    1725              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000247C  4EB9 000048B0           1726              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002482                          1727  
00002482  BABC 00000000           1728              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002488  6700 001C               1729              BEQ     And_L_SrcEA_xxxW
0000248C                          1730  
0000248C  BABC 00000001           1731              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002492  6700 0038               1732              BEQ     And_L_SrcEA_xxxL
00002496                          1733  
00002496  BABC 00000004           1734              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
0000249C  6700 0054               1735              BEQ     And_L_SrcEA_Data
000024A0                          1736  
000024A0  4EF9 000048A8           1737              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000024A6                          1738  
000024A6                          1739  And_L_SrcEA_xxxW
000024A6  4EB9 00004A8C           1740              JSR     PrintAnd
000024AC  4EB9 00004BEC           1741              JSR     LengthL
000024B2  4EB9 00004C10           1742              JSR     PrintSpace
000024B8  4EB9 000049AA           1743              JSR     PrintByteOrWord
000024BE                          1744  
000024BE  1A00                    1745              MOVE.B  D0,D5
000024C0  12EE 0025               1746              MOVE.B  37(A6),(A1)+             *,
000024C4  4EB9 00004A2A           1747              JSR     PrintDataReg
000024CA  4E75                    1748              RTS                     ; return to input to get more input
000024CC                          1749  
000024CC                          1750  And_L_SrcEA_xxxL
000024CC  4EB9 00004A8C           1751              JSR     PrintAnd
000024D2  4EB9 00004BEC           1752              JSR     LengthL
000024D8  4EB9 00004C10           1753              JSR     PrintSpace
000024DE  4EB9 000049C0           1754              JSR     PrintLong
000024E4                          1755  
000024E4  1A00                    1756              MOVE.B  D0,D5
000024E6  12EE 0025               1757              MOVE.B  37(A6),(A1)+             *,
000024EA  4EB9 00004A2A           1758              JSR     PrintDataReg
000024F0  4E75                    1759              RTS                     ; return to input to get more input
000024F2                          1760  
000024F2                          1761  And_L_SrcEA_Data
000024F2  4EB9 00004A8C           1762              JSR     PrintAnd
000024F8  4EB9 00004BEC           1763              JSR     LengthL
000024FE  4EB9 00004C10           1764              JSR     PrintSpace
00002504  4EB9 0000499E           1765              JSR     PrintImmediateData
0000250A                          1766  
0000250A  1A00                    1767              MOVE.B  D0,D5
0000250C  12EE 0025               1768              MOVE.B  37(A6),(A1)+             *,
00002510  4EB9 00004A2A           1769              JSR     PrintDataReg
00002516  4E75                    1770              RTS                     ; return to input to get more input
00002518                          1771  
00002518  7803                    1772  And_B_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000251A  4EB9 000048B0           1773              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002520                          1774  
00002520  BABC 00000002           1775              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002526  6700 0026               1776              BEQ     And_B_DesEA_M2
0000252A                          1777  
0000252A  BABC 00000003           1778              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002530  6700 004E               1779              BEQ     And_B_DesEA_M3
00002534                          1780  
00002534  BABC 00000004           1781              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000253A  6700 0076               1782              BEQ     And_B_DesEA_M4
0000253E                          1783  
0000253E  BABC 00000007           1784              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002544  6700 009E               1785              BEQ     And_B_DesEA_M7
00002548                          1786  
00002548  4EF9 000048A8           1787              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000254E                          1788  
0000254E                          1789  And_B_DesEA_M2
0000254E  7803                    1790              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002550  4EB9 000048B0           1791              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002556  4EB9 00004A8C           1792              JSR     PrintAnd
0000255C  4EB9 00004BD8           1793              JSR     LengthB
00002562  4EB9 00004C10           1794              JSR     PrintSpace
00002568                          1795  
00002568  1E05                    1796              MOVE.B  D5,D7
0000256A  1A00                    1797              MOVE.B  D0,D5
0000256C  4EB9 00004A2A           1798              JSR     PrintDataReg
00002572                          1799  
00002572  1A07                    1800              MOVE.B  D7,D5
00002574  12EE 0025               1801              MOVE.B  37(A6),(A1)+             *,
00002578  4EB9 00004A42           1802              JSR     PrintIndirAddrReg
0000257E  4E75                    1803              RTS                     ; return to input to get more input
00002580                          1804  
00002580                          1805  And_B_DesEA_M3
00002580  7803                    1806              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002582  4EB9 000048B0           1807              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002588  4EB9 00004A8C           1808              JSR     PrintAnd
0000258E  4EB9 00004BD8           1809              JSR     LengthB
00002594  4EB9 00004C10           1810              JSR     PrintSpace
0000259A                          1811  
0000259A  1E05                    1812              MOVE.B  D5,D7
0000259C  1A00                    1813              MOVE.B  D0,D5
0000259E  4EB9 00004A2A           1814              JSR     PrintDataReg
000025A4                          1815  
000025A4  1A07                    1816              MOVE.B  D7,D5
000025A6  12EE 0025               1817              MOVE.B  37(A6),(A1)+             *,
000025AA  4EB9 00004A50           1818              JSR     PrintPostIncAddrReg
000025B0  4E75                    1819              RTS                     ; return to input to get more input
000025B2                          1820  
000025B2                          1821  And_B_DesEA_M4
000025B2  7803                    1822              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000025B4  4EB9 000048B0           1823              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000025BA  4EB9 00004A8C           1824              JSR     PrintAnd
000025C0  4EB9 00004BD8           1825              JSR     LengthB
000025C6  4EB9 00004C10           1826              JSR     PrintSpace
000025CC                          1827  
000025CC  1E05                    1828              MOVE.B  D5,D7
000025CE  1A00                    1829              MOVE.B  D0,D5
000025D0  4EB9 00004A2A           1830              JSR     PrintDataReg
000025D6                          1831  
000025D6  1A07                    1832              MOVE.B  D7,D5
000025D8  12EE 0025               1833              MOVE.B  37(A6),(A1)+             *,
000025DC  4EB9 00004A5A           1834              JSR     PrintPreDeincAddrReg
000025E2  4E75                    1835              RTS                     ; return to input to get more input
000025E4                          1836  
000025E4                          1837  And_B_DesEA_M7
000025E4  7803                    1838              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000025E6  4EB9 000048B0           1839              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000025EC                          1840  
000025EC  BABC 00000000           1841              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000025F2  6700 0012               1842              BEQ     And_B_DesEA_xxxW
000025F6                          1843  
000025F6  BABC 00000001           1844              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000025FC  6700 0032               1845              BEQ     And_B_DesEA_xxxL
00002600                          1846  
00002600  4EF9 000048A8           1847              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002606                          1848  
00002606                          1849  And_B_DesEA_xxxW
00002606  4EB9 00004A8C           1850              JSR     PrintAnd
0000260C  4EB9 00004BD8           1851              JSR     LengthB
00002612  4EB9 00004C10           1852              JSR     PrintSpace
00002618                          1853  
00002618  1E05                    1854              MOVE.B  D5,D7
0000261A  1A00                    1855              MOVE.B  D0,D5
0000261C  4EB9 00004A2A           1856              JSR     PrintDataReg
00002622                          1857  
00002622  1A07                    1858              MOVE.B  D7,D5
00002624  12EE 0025               1859              MOVE.B  37(A6),(A1)+             *,
00002628  4EB9 000049AA           1860              JSR     PrintByteOrWord
0000262E  4E75                    1861              RTS                     ; return to input to get more input
00002630                          1862  
00002630                          1863  And_B_DesEA_xxxL
00002630  4EB9 00004A8C           1864              JSR     PrintAnd
00002636  4EB9 00004BD8           1865              JSR     LengthB
0000263C  4EB9 00004C10           1866              JSR     PrintSpace
00002642                          1867  
00002642  1E05                    1868              MOVE.B  D5,D7
00002644  1A00                    1869              MOVE.B  D0,D5
00002646  4EB9 00004A2A           1870              JSR     PrintDataReg
0000264C                          1871  
0000264C  1A07                    1872              MOVE.B  D7,D5
0000264E  12EE 0025               1873              MOVE.B  37(A6),(A1)+             *,
00002652  4EB9 000049C0           1874              JSR     PrintLong
00002658  4E75                    1875              RTS                     ; return to input to get more input
0000265A                          1876  
0000265A  7803                    1877  And_W_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000265C  4EB9 000048B0           1878              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002662                          1879  
00002662  BABC 00000002           1880              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002668  6700 0026               1881              BEQ     And_W_DesEA_M2
0000266C                          1882  
0000266C  BABC 00000003           1883              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002672  6700 004E               1884              BEQ     And_W_DesEA_M3
00002676                          1885  
00002676  BABC 00000004           1886              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000267C  6700 0076               1887              BEQ     And_W_DesEA_M4
00002680                          1888  
00002680  BABC 00000007           1889              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002686  6700 009E               1890              BEQ     And_W_DesEA_M7
0000268A                          1891  
0000268A  4EF9 000048A8           1892              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002690                          1893  
00002690                          1894  And_W_DesEA_M2
00002690  7803                    1895              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002692  4EB9 000048B0           1896              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002698  4EB9 00004A8C           1897              JSR     PrintAnd
0000269E  4EB9 00004BE2           1898              JSR     LengthW
000026A4  4EB9 00004C10           1899              JSR     PrintSpace
000026AA                          1900  
000026AA  1E05                    1901              MOVE.B  D5,D7
000026AC  1A00                    1902              MOVE.B  D0,D5
000026AE  4EB9 00004A2A           1903              JSR     PrintDataReg
000026B4                          1904  
000026B4  1A07                    1905              MOVE.B  D7,D5
000026B6  12EE 0025               1906              MOVE.B  37(A6),(A1)+             *,
000026BA  4EB9 00004A42           1907              JSR     PrintIndirAddrReg
000026C0  4E75                    1908              RTS                     ; return to input to get more input
000026C2                          1909  
000026C2                          1910  And_W_DesEA_M3
000026C2  7803                    1911              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000026C4  4EB9 000048B0           1912              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000026CA  4EB9 00004A8C           1913              JSR     PrintAnd
000026D0  4EB9 00004BE2           1914              JSR     LengthW
000026D6  4EB9 00004C10           1915              JSR     PrintSpace
000026DC                          1916  
000026DC  1E05                    1917              MOVE.B  D5,D7
000026DE  1A00                    1918              MOVE.B  D0,D5
000026E0  4EB9 00004A2A           1919              JSR     PrintDataReg
000026E6                          1920  
000026E6  1A07                    1921              MOVE.B  D7,D5
000026E8  12EE 0025               1922              MOVE.B  37(A6),(A1)+             *,
000026EC  4EB9 00004A50           1923              JSR     PrintPostIncAddrReg
000026F2  4E75                    1924              RTS                     ; return to input to get more input
000026F4                          1925  
000026F4                          1926  And_W_DesEA_M4
000026F4  7803                    1927              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000026F6  4EB9 000048B0           1928              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000026FC  4EB9 00004A8C           1929              JSR     PrintAnd
00002702  4EB9 00004BE2           1930              JSR     LengthW
00002708  4EB9 00004C10           1931              JSR     PrintSpace
0000270E                          1932  
0000270E  1E05                    1933              MOVE.B  D5,D7
00002710  1A00                    1934              MOVE.B  D0,D5
00002712  4EB9 00004A2A           1935              JSR     PrintDataReg
00002718                          1936  
00002718  1A07                    1937              MOVE.B  D7,D5
0000271A  12EE 0025               1938              MOVE.B  37(A6),(A1)+             *,
0000271E  4EB9 00004A5A           1939              JSR     PrintPreDeincAddrReg
00002724  4E75                    1940              RTS                     ; return to input to get more input
00002726                          1941  
00002726                          1942  And_W_DesEA_M7
00002726  7803                    1943              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002728  4EB9 000048B0           1944              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000272E                          1945  
0000272E  BABC 00000000           1946              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002734  6700 0012               1947              BEQ     And_W_DesEA_xxxW
00002738                          1948  
00002738  BABC 00000001           1949              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
0000273E  6700 0032               1950              BEQ     And_W_DesEA_xxxL
00002742                          1951  
00002742  4EF9 000048A8           1952              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002748                          1953  
00002748                          1954  And_W_DesEA_xxxW
00002748  4EB9 00004A8C           1955              JSR     PrintAnd
0000274E  4EB9 00004BE2           1956              JSR     LengthW
00002754  4EB9 00004C10           1957              JSR     PrintSpace
0000275A                          1958  
0000275A  1E05                    1959              MOVE.B  D5,D7
0000275C  1A00                    1960              MOVE.B  D0,D5
0000275E  4EB9 00004A2A           1961              JSR     PrintDataReg
00002764                          1962  
00002764  1A07                    1963              MOVE.B  D7,D5
00002766  12EE 0025               1964              MOVE.B  37(A6),(A1)+             *,
0000276A  4EB9 000049AA           1965              JSR     PrintByteOrWord
00002770  4E75                    1966              RTS                     ; return to input to get more input
00002772                          1967  
00002772                          1968  And_W_DesEA_xxxL
00002772  4EB9 00004A8C           1969              JSR     PrintAnd
00002778  4EB9 00004BE2           1970              JSR     LengthW
0000277E  4EB9 00004C10           1971              JSR     PrintSpace
00002784                          1972  
00002784  1E05                    1973              MOVE.B  D5,D7
00002786  1A00                    1974              MOVE.B  D0,D5
00002788  4EB9 00004A2A           1975              JSR     PrintDataReg
0000278E                          1976  
0000278E  1A07                    1977              MOVE.B  D7,D5
00002790  12EE 0025               1978              MOVE.B  37(A6),(A1)+             *,
00002794  4EB9 000049C0           1979              JSR     PrintLong
0000279A  4E75                    1980              RTS                     ; return to input to get more input
0000279C                          1981  
0000279C  7803                    1982  And_L_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000279E  4EB9 000048B0           1983              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000027A4                          1984  
000027A4  BABC 00000002           1985              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000027AA  6700 0026               1986              BEQ     And_L_DesEA_M2
000027AE                          1987  
000027AE  BABC 00000003           1988              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000027B4  6700 004E               1989              BEQ     And_L_DesEA_M3
000027B8                          1990  
000027B8  BABC 00000004           1991              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000027BE  6700 0076               1992              BEQ     And_L_DesEA_M4
000027C2                          1993  
000027C2  BABC 00000007           1994              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000027C8  6700 009E               1995              BEQ     And_L_DesEA_M7
000027CC                          1996  
000027CC  4EF9 000048A8           1997              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000027D2                          1998  
000027D2                          1999  And_L_DesEA_M2
000027D2  7803                    2000              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000027D4  4EB9 000048B0           2001              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000027DA  4EB9 00004A8C           2002              JSR     PrintAnd
000027E0  4EB9 00004BEC           2003              JSR     LengthL
000027E6  4EB9 00004C10           2004              JSR     PrintSpace
000027EC                          2005  
000027EC  1E05                    2006              MOVE.B  D5,D7
000027EE  1A00                    2007              MOVE.B  D0,D5
000027F0  4EB9 00004A2A           2008              JSR     PrintDataReg
000027F6                          2009  
000027F6  1A07                    2010              MOVE.B  D7,D5
000027F8  12EE 0025               2011              MOVE.B  37(A6),(A1)+             *,
000027FC  4EB9 00004A42           2012              JSR     PrintIndirAddrReg
00002802  4E75                    2013              RTS                     ; return to input to get more input
00002804                          2014  
00002804                          2015  And_L_DesEA_M3
00002804  7803                    2016              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002806  4EB9 000048B0           2017              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000280C  4EB9 00004A8C           2018              JSR     PrintAnd
00002812  4EB9 00004BEC           2019              JSR     LengthL
00002818  4EB9 00004C10           2020              JSR     PrintSpace
0000281E                          2021  
0000281E  1E05                    2022              MOVE.B  D5,D7
00002820  1A00                    2023              MOVE.B  D0,D5
00002822  4EB9 00004A2A           2024              JSR     PrintDataReg
00002828                          2025  
00002828  1A07                    2026              MOVE.B  D7,D5
0000282A  12EE 0025               2027              MOVE.B  37(A6),(A1)+             *,
0000282E  4EB9 00004A50           2028              JSR     PrintPostIncAddrReg
00002834  4E75                    2029              RTS                     ; return to input to get more input
00002836                          2030  
00002836                          2031  And_L_DesEA_M4
00002836  7803                    2032              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002838  4EB9 000048B0           2033              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000283E  4EB9 00004A8C           2034              JSR     PrintAnd
00002844  4EB9 00004BEC           2035              JSR     LengthL
0000284A  4EB9 00004C10           2036              JSR     PrintSpace
00002850                          2037  
00002850  1E05                    2038              MOVE.B  D5,D7
00002852  1A00                    2039              MOVE.B  D0,D5
00002854  4EB9 00004A2A           2040              JSR     PrintDataReg
0000285A                          2041  
0000285A  1A07                    2042              MOVE.B  D7,D5
0000285C  12EE 0025               2043              MOVE.B  37(A6),(A1)+             *,
00002860  4EB9 00004A5A           2044              JSR     PrintPreDeincAddrReg
00002866  4E75                    2045              RTS                     ; return to input to get more input
00002868                          2046  
00002868                          2047  And_L_DesEA_M7
00002868  7803                    2048              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000286A  4EB9 000048B0           2049              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002870                          2050  
00002870  BABC 00000000           2051              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002876  6700 0012               2052              BEQ     And_L_DesEA_xxxW
0000287A                          2053  
0000287A  BABC 00000001           2054              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002880  6700 0032               2055              BEQ     And_L_DesEA_xxxL
00002884                          2056  
00002884  4EF9 000048A8           2057              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000288A                          2058  
0000288A                          2059  And_L_DesEA_xxxW
0000288A  4EB9 00004A8C           2060              JSR     PrintAnd
00002890  4EB9 00004BEC           2061              JSR     LengthL
00002896  4EB9 00004C10           2062              JSR     PrintSpace
0000289C                          2063  
0000289C  1E05                    2064              MOVE.B  D5,D7
0000289E  1A00                    2065              MOVE.B  D0,D5
000028A0  4EB9 00004A2A           2066              JSR     PrintDataReg
000028A6                          2067  
000028A6  1A07                    2068              MOVE.B  D7,D5
000028A8  12EE 0025               2069              MOVE.B  37(A6),(A1)+             *,
000028AC  4EB9 000049AA           2070              JSR     PrintByteOrWord
000028B2  4E75                    2071              RTS                     ; return to input to get more input
000028B4                          2072  
000028B4                          2073  And_L_DesEA_xxxL
000028B4  4EB9 00004A8C           2074              JSR     PrintAnd
000028BA  4EB9 00004BEC           2075              JSR     LengthL
000028C0  4EB9 00004C10           2076              JSR     PrintSpace
000028C6                          2077  
000028C6  1E05                    2078              MOVE.B  D5,D7
000028C8  1A00                    2079              MOVE.B  D0,D5
000028CA  4EB9 00004A2A           2080              JSR     PrintDataReg
000028D0                          2081  
000028D0  1A07                    2082              MOVE.B  D7,D5
000028D2  12EE 0025               2083              MOVE.B  37(A6),(A1)+             *,
000028D6  4EB9 000049C0           2084              JSR     PrintLong
000028DC  4E75                    2085              RTS                     ; return to input to get more input
000028DE                          2086  
000028DE  7803                    2087  MULS_W      MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000028E0  4EB9 000048B0           2088              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000028E6                          2089  
000028E6  BABC 00000000           2090              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
000028EC  6700 0030               2091              BEQ     MULS_W_M0
000028F0                          2092  
000028F0  BABC 00000002           2093              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000028F6  6700 0054               2094              BEQ     MULS_W_M2
000028FA                          2095  
000028FA  BABC 00000003           2096              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002900  6700 0078               2097              BEQ     MULS_W_M3
00002904                          2098  
00002904  BABC 00000004           2099              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
0000290A  6700 009C               2100              BEQ     MULS_W_M4
0000290E                          2101  
0000290E  BABC 00000007           2102              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002914  6700 00C0               2103              BEQ     MULS_W_M7
00002918                          2104  
00002918  4EF9 000048A8           2105              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000291E                          2106  
0000291E  7803                    2107  MULS_W_M0   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002920  4EB9 000048B0           2108              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002926  4EB9 00004B68           2109              JSR     PrintMuls
0000292C  4EB9 00004BE2           2110              JSR     LengthW
00002932  4EB9 00004C10           2111              JSR     PrintSpace
00002938  4EB9 00004A2A           2112              JSR     PrintDataReg
0000293E                          2113  
0000293E  1A00                    2114              MOVE.B  D0,D5
00002940  12EE 0025               2115              MOVE.B  37(A6),(A1)+             *,
00002944  4EB9 00004A2A           2116              JSR     PrintDataReg
0000294A  4E75                    2117              RTS                     ; return to input to get more input
0000294C                          2118  
0000294C  7803                    2119  MULS_W_M2   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000294E  4EB9 000048B0           2120              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002954  4EB9 00004B68           2121              JSR     PrintMuls
0000295A  4EB9 00004BE2           2122              JSR     LengthW
00002960  4EB9 00004C10           2123              JSR     PrintSpace
00002966  4EB9 00004A42           2124              JSR     PrintIndirAddrReg
0000296C                          2125  
0000296C  1A00                    2126              MOVE.B  D0,D5
0000296E  12EE 0025               2127              MOVE.B  37(A6),(A1)+             *,
00002972  4EB9 00004A2A           2128              JSR     PrintDataReg
00002978  4E75                    2129              RTS                     ; return to input to get more input
0000297A                          2130  
0000297A  7803                    2131  MULS_W_M3   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000297C  4EB9 000048B0           2132              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002982  4EB9 00004B68           2133              JSR     PrintMuls
00002988  4EB9 00004BE2           2134              JSR     LengthW
0000298E  4EB9 00004C10           2135              JSR     PrintSpace
00002994  4EB9 00004A50           2136              JSR     PrintPostIncAddrReg
0000299A                          2137  
0000299A  1A00                    2138              MOVE.B  D0,D5
0000299C  12EE 0025               2139              MOVE.B  37(A6),(A1)+             *,
000029A0  4EB9 00004A2A           2140              JSR     PrintDataReg
000029A6  4E75                    2141              RTS                     ; return to input to get more input
000029A8                          2142  
000029A8  7803                    2143  MULS_W_M4   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000029AA  4EB9 000048B0           2144              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000029B0  4EB9 00004B68           2145              JSR     PrintMuls
000029B6  4EB9 00004BE2           2146              JSR     LengthW
000029BC  4EB9 00004C10           2147              JSR     PrintSpace
000029C2  4EB9 00004A5A           2148              JSR     PrintPreDeincAddrReg
000029C8                          2149  
000029C8  1A00                    2150              MOVE.B  D0,D5
000029CA  12EE 0025               2151              MOVE.B  37(A6),(A1)+             *,
000029CE  4EB9 00004A2A           2152              JSR     PrintDataReg
000029D4  4E75                    2153              RTS                     ; return to input to get more input
000029D6                          2154  
000029D6  7803                    2155  MULS_W_M7   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000029D8  4EB9 000048B0           2156              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000029DE                          2157  
000029DE  BABC 00000000           2158              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000029E4  6700 001C               2159              BEQ     MULS_W_xxxW
000029E8                          2160  
000029E8  BABC 00000001           2161              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000029EE  6700 0038               2162              BEQ     MULS_W_xxxL
000029F2                          2163  
000029F2  BABC 00000004           2164              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
000029F8  6700 0054               2165              BEQ     MULS_W_Data
000029FC                          2166  
000029FC  4EF9 000048A8           2167              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002A02                          2168  
00002A02                          2169  MULS_W_xxxW
00002A02  4EB9 00004B68           2170              JSR     PrintMuls
00002A08  4EB9 00004BE2           2171              JSR     LengthW
00002A0E  4EB9 00004C10           2172              JSR     PrintSpace
00002A14  4EB9 000049AA           2173              JSR     PrintByteOrWord
00002A1A                          2174  
00002A1A  1A00                    2175              MOVE.B  D0,D5
00002A1C  12EE 0025               2176              MOVE.B  37(A6),(A1)+             *,
00002A20  4EB9 00004A2A           2177              JSR     PrintDataReg
00002A26  4E75                    2178              RTS                     ; return to input to get more input
00002A28                          2179  
00002A28                          2180  MULS_W_xxxL
00002A28  4EB9 00004B68           2181              JSR     PrintMuls
00002A2E  4EB9 00004BE2           2182              JSR     LengthW
00002A34  4EB9 00004C10           2183              JSR     PrintSpace
00002A3A  4EB9 000049C0           2184              JSR     PrintLong
00002A40                          2185  
00002A40  1A00                    2186              MOVE.B  D0,D5
00002A42  12EE 0025               2187              MOVE.B  37(A6),(A1)+             *,
00002A46  4EB9 00004A2A           2188              JSR     PrintDataReg
00002A4C  4E75                    2189              RTS                     ; return to input to get more input
00002A4E                          2190  
00002A4E                          2191  MULS_W_Data
00002A4E  4EB9 00004B68           2192              JSR     PrintMuls
00002A54  4EB9 00004BE2           2193              JSR     LengthW
00002A5A  4EB9 00004C10           2194              JSR     PrintSpace
00002A60  4EB9 0000499E           2195              JSR     PrintImmediateData
00002A66                          2196  
00002A66  1A00                    2197              MOVE.B  D0,D5
00002A68  12EE 0025               2198              MOVE.B  37(A6),(A1)+             *,
00002A6C  4EB9 00004A2A           2199              JSR     PrintDataReg
00002A72  4E75                    2200              RTS                     ; return to input to get more input
00002A74                          2201  
00002A74                          2202  *************************************************                SUB_Opcode                 *************************************************
00002A74                          2203  ; first four bit is (1001 #### #### ####)
00002A74  7803                    2204  SUB_Opcode  MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00002A76  4EB9 000048B0           2205              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us register
00002A7C                          2206  
00002A7C  2005                    2207              MOVE.L  D5,D0               ; D0 will hold the register
00002A7E                          2208          ; D0 will hold the register (position 11-9)
00002A7E                          2209  
00002A7E  7803                    2210              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00002A80  4EB9 000048B0           2211              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the opmode
00002A86                          2212  
00002A86  BABC 00000000           2213              CMP.L   #0,D5               ; if opmode is 0, it is a byte with location specified is a source  (Dn - <ea> -> <ea>)
00002A8C  6700 003A               2214              BEQ     SUB_B_SrcEA
00002A90                          2215  
00002A90  BABC 00000001           2216              CMP.L   #1,D5               ; if opmode is 1, it is a word with location specified is a source  (Dn - <ea> -> <ea>)
00002A96  6700 01FE               2217              BEQ     SUB_W_SrcEA
00002A9A                          2218  
00002A9A  BABC 00000002           2219              CMP.L   #2,D5               ; if opmode is 2, it is a long with location specified is a source  (Dn - <ea> -> <ea>)
00002AA0  6700 03C2               2220              BEQ     SUB_L_SrcEA
00002AA4                          2221  
00002AA4  BABC 00000004           2222              CMP.L   #4,D5               ; if opmode is 4, it is a byte with location specified is a Destination (<ea> - Dn -> <ea>)
00002AAA  6700 0586               2223              BEQ     SUB_B_DesEA
00002AAE                          2224  
00002AAE  BABC 00000005           2225              CMP.L   #5,D5               ; if opmode is 5, it is a word with location specified is a Destination (<ea> - Dn -> <ea>)
00002AB4  6700 06C8               2226              BEQ     SUB_W_DesEA
00002AB8                          2227  
00002AB8  BABC 00000006           2228              CMP.L   #6,D5               ; if opmode is 6, it is a long with location specified is a Destination (<ea> - Dn -> <ea>)
00002ABE  6700 080A               2229              BEQ     SUB_L_DesEA
00002AC2                          2230  
00002AC2  4EF9 000048A8           2231              JMP     InvalidOpcode       ; if it is not one of the opmode the opcode is invalid
00002AC8                          2232  
00002AC8  7803                    2233  SUB_B_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002ACA  4EB9 000048B0           2234              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002AD0                          2235  
00002AD0  BABC 00000000           2236              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002AD6  6700 003A               2237              BEQ     SUB_B_SrcEA_M0
00002ADA                          2238  
00002ADA  BABC 00000001           2239              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00002AE0  6700 005E               2240              BEQ     SUB_B_SrcEA_M1
00002AE4                          2241  
00002AE4  BABC 00000002           2242              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002AEA  6700 0082               2243              BEQ     SUB_B_SrcEA_M2
00002AEE                          2244  
00002AEE  BABC 00000003           2245              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002AF4  6700 00A6               2246              BEQ     SUB_B_SrcEA_M3
00002AF8                          2247  
00002AF8  BABC 00000004           2248              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002AFE  6700 00CA               2249              BEQ     SUB_B_SrcEA_M4
00002B02                          2250  
00002B02  BABC 00000007           2251              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002B08  6700 00EE               2252              BEQ     SUB_B_SrcEA_M7
00002B0C                          2253  
00002B0C  4EF9 000048A8           2254              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002B12                          2255  
00002B12                          2256  SUB_B_SrcEA_M0
00002B12  7803                    2257              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B14  4EB9 000048B0           2258              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002B1A  4EB9 00004BCA           2259              JSR     PrintSub
00002B20  4EB9 00004BD8           2260              JSR     LengthB
00002B26  4EB9 00004C10           2261              JSR     PrintSpace
00002B2C  4EB9 00004A2A           2262              JSR     PrintDataReg
00002B32                          2263  
00002B32  1A00                    2264              MOVE.B  D0,D5
00002B34  12EE 0025               2265              MOVE.B  37(A6),(A1)+             *,
00002B38  4EB9 00004A2A           2266              JSR     PrintDataReg
00002B3E  4E75                    2267              RTS                     ; return to input to get more input
00002B40                          2268  
00002B40                          2269  SUB_B_SrcEA_M1
00002B40  7803                    2270              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B42  4EB9 000048B0           2271              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002B48  4EB9 00004BCA           2272              JSR     PrintSub
00002B4E  4EB9 00004BD8           2273              JSR     LengthB
00002B54  4EB9 00004C10           2274              JSR     PrintSpace
00002B5A  4EB9 00004A36           2275              JSR     PrintAddrReg
00002B60                          2276  
00002B60  1A00                    2277              MOVE.B  D0,D5
00002B62  12EE 0025               2278              MOVE.B  37(A6),(A1)+             *,
00002B66  4EB9 00004A2A           2279              JSR     PrintDataReg
00002B6C  4E75                    2280              RTS                     ; return to input to get more input
00002B6E                          2281  
00002B6E                          2282  SUB_B_SrcEA_M2
00002B6E  7803                    2283              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B70  4EB9 000048B0           2284              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002B76  4EB9 00004BCA           2285              JSR     PrintSub
00002B7C  4EB9 00004BD8           2286              JSR     LengthB
00002B82  4EB9 00004C10           2287              JSR     PrintSpace
00002B88  4EB9 00004A42           2288              JSR     PrintIndirAddrReg
00002B8E                          2289  
00002B8E  1A00                    2290              MOVE.B  D0,D5
00002B90  12EE 0025               2291              MOVE.B  37(A6),(A1)+             *,
00002B94  4EB9 00004A2A           2292              JSR     PrintDataReg
00002B9A  4E75                    2293              RTS                     ; return to input to get more input
00002B9C                          2294  
00002B9C                          2295  SUB_B_SrcEA_M3
00002B9C  7803                    2296              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002B9E  4EB9 000048B0           2297              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002BA4  4EB9 00004BCA           2298              JSR     PrintSub
00002BAA  4EB9 00004BD8           2299              JSR     LengthB
00002BB0  4EB9 00004C10           2300              JSR     PrintSpace
00002BB6  4EB9 00004A50           2301              JSR     PrintPostIncAddrReg
00002BBC                          2302  
00002BBC  1A00                    2303              MOVE.B  D0,D5
00002BBE  12EE 0025               2304              MOVE.B  37(A6),(A1)+             *,
00002BC2  4EB9 00004A2A           2305              JSR     PrintDataReg
00002BC8  4E75                    2306              RTS                     ; return to input to get more input
00002BCA                          2307  
00002BCA                          2308  SUB_B_SrcEA_M4
00002BCA  7803                    2309              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002BCC  4EB9 000048B0           2310              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002BD2  4EB9 00004BCA           2311              JSR     PrintSub
00002BD8  4EB9 00004BD8           2312              JSR     LengthB
00002BDE  4EB9 00004C10           2313              JSR     PrintSpace
00002BE4  4EB9 00004A5A           2314              JSR     PrintPreDeincAddrReg
00002BEA                          2315  
00002BEA  1A00                    2316              MOVE.B  D0,D5
00002BEC  12EE 0025               2317              MOVE.B  37(A6),(A1)+             *,
00002BF0  4EB9 00004A2A           2318              JSR     PrintDataReg
00002BF6  4E75                    2319              RTS                     ; return to input to get more input
00002BF8                          2320  
00002BF8                          2321  SUB_B_SrcEA_M7
00002BF8  7803                    2322              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002BFA  4EB9 000048B0           2323              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002C00                          2324  
00002C00  BABC 00000000           2325              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002C06  6700 001C               2326              BEQ     SUB_B_SrcEA_xxxW
00002C0A                          2327  
00002C0A  BABC 00000001           2328              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002C10  6700 0038               2329              BEQ     SUB_B_SrcEA_xxxL
00002C14                          2330  
00002C14  BABC 00000004           2331              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002C1A  6700 0054               2332              BEQ     SUB_B_SrcEA_Data
00002C1E                          2333  
00002C1E  4EF9 000048A8           2334              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002C24                          2335  
00002C24                          2336  SUB_B_SrcEA_xxxW
00002C24  4EB9 00004BCA           2337              JSR     PrintSub
00002C2A  4EB9 00004BD8           2338              JSR     LengthB
00002C30  4EB9 00004C10           2339              JSR     PrintSpace
00002C36  4EB9 000049AA           2340              JSR     PrintByteOrWord
00002C3C                          2341  
00002C3C  1A00                    2342              MOVE.B  D0,D5
00002C3E  12EE 0025               2343              MOVE.B  37(A6),(A1)+             *,
00002C42  4EB9 00004A2A           2344              JSR     PrintDataReg
00002C48  4E75                    2345              RTS                     ; return to input to get more input
00002C4A                          2346  
00002C4A                          2347  SUB_B_SrcEA_xxxL
00002C4A  4EB9 00004BCA           2348              JSR     PrintSub
00002C50  4EB9 00004BD8           2349              JSR     LengthB
00002C56  4EB9 00004C10           2350              JSR     PrintSpace
00002C5C  4EB9 000049C0           2351              JSR     PrintLong
00002C62                          2352  
00002C62  1A00                    2353              MOVE.B  D0,D5
00002C64  12EE 0025               2354              MOVE.B  37(A6),(A1)+             *,
00002C68  4EB9 00004A2A           2355              JSR     PrintDataReg
00002C6E  4E75                    2356              RTS                     ; return to input to get more input
00002C70                          2357  
00002C70                          2358  SUB_B_SrcEA_Data
00002C70  4EB9 00004BCA           2359              JSR     PrintSub
00002C76  4EB9 00004BD8           2360              JSR     LengthB
00002C7C  4EB9 00004C10           2361              JSR     PrintSpace
00002C82  4EB9 0000499E           2362              JSR     PrintImmediateData
00002C88                          2363  
00002C88  1A00                    2364              MOVE.B  D0,D5
00002C8A  12EE 0025               2365              MOVE.B  37(A6),(A1)+             *,
00002C8E  4EB9 00004A2A           2366              JSR     PrintDataReg
00002C94  4E75                    2367              RTS                     ; return to input to get more input
00002C96                          2368  
00002C96                          2369  
00002C96  7803                    2370  SUB_W_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002C98  4EB9 000048B0           2371              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002C9E                          2372  
00002C9E  BABC 00000000           2373              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002CA4  6700 003A               2374              BEQ     SUB_W_SrcEA_M0
00002CA8                          2375  
00002CA8  BABC 00000001           2376              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00002CAE  6700 005E               2377              BEQ     SUB_W_SrcEA_M1
00002CB2                          2378  
00002CB2  BABC 00000002           2379              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002CB8  6700 0082               2380              BEQ     SUB_W_SrcEA_M2
00002CBC                          2381  
00002CBC  BABC 00000003           2382              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002CC2  6700 00A6               2383              BEQ     SUB_W_SrcEA_M3
00002CC6                          2384  
00002CC6  BABC 00000004           2385              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002CCC  6700 00CA               2386              BEQ     SUB_W_SrcEA_M4
00002CD0                          2387  
00002CD0  BABC 00000007           2388              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002CD6  6700 00EE               2389              BEQ     SUB_W_SrcEA_M7
00002CDA                          2390  
00002CDA  4EF9 000048A8           2391              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002CE0                          2392  
00002CE0                          2393  SUB_W_SrcEA_M0
00002CE0  7803                    2394              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002CE2  4EB9 000048B0           2395              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002CE8  4EB9 00004BCA           2396              JSR     PrintSub
00002CEE  4EB9 00004BE2           2397              JSR     LengthW
00002CF4  4EB9 00004C10           2398              JSR     PrintSpace
00002CFA  4EB9 00004A2A           2399              JSR     PrintDataReg
00002D00                          2400  
00002D00  1A00                    2401              MOVE.B  D0,D5
00002D02  12EE 0025               2402              MOVE.B  37(A6),(A1)+             *,
00002D06  4EB9 00004A2A           2403              JSR     PrintDataReg
00002D0C  4E75                    2404              RTS                     ; return to input to get more input
00002D0E                          2405  
00002D0E                          2406  SUB_W_SrcEA_M1
00002D0E  7803                    2407              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D10  4EB9 000048B0           2408              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002D16  4EB9 00004BCA           2409              JSR     PrintSub
00002D1C  4EB9 00004BE2           2410              JSR     LengthW
00002D22  4EB9 00004C10           2411              JSR     PrintSpace
00002D28  4EB9 00004A36           2412              JSR     PrintAddrReg
00002D2E                          2413  
00002D2E  1A00                    2414              MOVE.B  D0,D5
00002D30  12EE 0025               2415              MOVE.B  37(A6),(A1)+             *,
00002D34  4EB9 00004A2A           2416              JSR     PrintDataReg
00002D3A  4E75                    2417              RTS                     ; return to input to get more input
00002D3C                          2418  
00002D3C                          2419  SUB_W_SrcEA_M2
00002D3C  7803                    2420              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D3E  4EB9 000048B0           2421              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002D44  4EB9 00004BCA           2422              JSR     PrintSub
00002D4A  4EB9 00004BE2           2423              JSR     LengthW
00002D50  4EB9 00004C10           2424              JSR     PrintSpace
00002D56  4EB9 00004A42           2425              JSR     PrintIndirAddrReg
00002D5C                          2426  
00002D5C  1A00                    2427              MOVE.B  D0,D5
00002D5E  12EE 0025               2428              MOVE.B  37(A6),(A1)+             *,
00002D62  4EB9 00004A2A           2429              JSR     PrintDataReg
00002D68  4E75                    2430              RTS                     ; return to input to get more input
00002D6A                          2431  
00002D6A                          2432  SUB_W_SrcEA_M3
00002D6A  7803                    2433              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D6C  4EB9 000048B0           2434              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002D72  4EB9 00004BCA           2435              JSR     PrintSub
00002D78  4EB9 00004BE2           2436              JSR     LengthW
00002D7E  4EB9 00004C10           2437              JSR     PrintSpace
00002D84  4EB9 00004A50           2438              JSR     PrintPostIncAddrReg
00002D8A                          2439  
00002D8A  1A00                    2440              MOVE.B  D0,D5
00002D8C  12EE 0025               2441              MOVE.B  37(A6),(A1)+             *,
00002D90  4EB9 00004A2A           2442              JSR     PrintDataReg
00002D96  4E75                    2443              RTS                     ; return to input to get more input
00002D98                          2444  
00002D98                          2445  SUB_W_SrcEA_M4
00002D98  7803                    2446              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002D9A  4EB9 000048B0           2447              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002DA0  4EB9 00004BCA           2448              JSR     PrintSub
00002DA6  4EB9 00004BE2           2449              JSR     LengthW
00002DAC  4EB9 00004C10           2450              JSR     PrintSpace
00002DB2  4EB9 00004A5A           2451              JSR     PrintPreDeincAddrReg
00002DB8                          2452  
00002DB8  1A00                    2453              MOVE.B  D0,D5
00002DBA  12EE 0025               2454              MOVE.B  37(A6),(A1)+             *,
00002DBE  4EB9 00004A2A           2455              JSR     PrintDataReg
00002DC4  4E75                    2456              RTS                     ; return to input to get more input
00002DC6                          2457  
00002DC6                          2458  SUB_W_SrcEA_M7
00002DC6  7803                    2459              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002DC8  4EB9 000048B0           2460              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002DCE                          2461  
00002DCE  BABC 00000000           2462              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002DD4  6700 001C               2463              BEQ     SUB_W_SrcEA_xxxW
00002DD8                          2464  
00002DD8  BABC 00000001           2465              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002DDE  6700 0038               2466              BEQ     SUB_W_SrcEA_xxxL
00002DE2                          2467  
00002DE2  BABC 00000004           2468              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002DE8  6700 0054               2469              BEQ     SUB_W_SrcEA_Data
00002DEC                          2470  
00002DEC  4EF9 000048A8           2471              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002DF2                          2472  
00002DF2                          2473  SUB_W_SrcEA_xxxW
00002DF2  4EB9 00004BCA           2474              JSR     PrintSub
00002DF8  4EB9 00004BE2           2475              JSR     LengthW
00002DFE  4EB9 00004C10           2476              JSR     PrintSpace
00002E04  4EB9 000049AA           2477              JSR     PrintByteOrWord
00002E0A                          2478  
00002E0A  1A00                    2479              MOVE.B  D0,D5
00002E0C  12EE 0025               2480              MOVE.B  37(A6),(A1)+             *,
00002E10  4EB9 00004A2A           2481              JSR     PrintDataReg
00002E16  4E75                    2482              RTS                     ; return to input to get more input
00002E18                          2483  
00002E18                          2484  SUB_W_SrcEA_xxxL
00002E18  4EB9 00004BCA           2485              JSR     PrintSub
00002E1E  4EB9 00004BE2           2486              JSR     LengthW
00002E24  4EB9 00004C10           2487              JSR     PrintSpace
00002E2A  4EB9 000049C0           2488              JSR     PrintLong
00002E30                          2489  
00002E30  1A00                    2490              MOVE.B  D0,D5
00002E32  12EE 0025               2491              MOVE.B  37(A6),(A1)+             *,
00002E36  4EB9 00004A2A           2492              JSR     PrintDataReg
00002E3C  4E75                    2493              RTS                     ; return to input to get more input
00002E3E                          2494  
00002E3E                          2495  SUB_W_SrcEA_Data
00002E3E  4EB9 00004BCA           2496              JSR     PrintSub
00002E44  4EB9 00004BE2           2497              JSR     LengthW
00002E4A  4EB9 00004C10           2498              JSR     PrintSpace
00002E50  4EB9 0000499E           2499              JSR     PrintImmediateData
00002E56                          2500  
00002E56  1A00                    2501              MOVE.B  D0,D5
00002E58  12EE 0025               2502              MOVE.B  37(A6),(A1)+             *,
00002E5C  4EB9 00004A2A           2503              JSR     PrintDataReg
00002E62  4E75                    2504              RTS                     ; return to input to get more input
00002E64                          2505  
00002E64  7803                    2506  SUB_L_SrcEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00002E66  4EB9 000048B0           2507              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00002E6C                          2508  
00002E6C  BABC 00000000           2509              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00002E72  6700 003A               2510              BEQ     SUB_L_SrcEA_M0
00002E76                          2511  
00002E76  BABC 00000001           2512              CMP.L   #1,D5               ; if EA mode is 1 EA is An*
00002E7C  6700 005E               2513              BEQ     SUB_L_SrcEA_M1
00002E80                          2514  
00002E80  BABC 00000002           2515              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00002E86  6700 0082               2516              BEQ     SUB_L_SrcEA_M2
00002E8A                          2517  
00002E8A  BABC 00000003           2518              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00002E90  6700 00A6               2519              BEQ     SUB_L_SrcEA_M3
00002E94                          2520  
00002E94  BABC 00000004           2521              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00002E9A  6700 00CA               2522              BEQ     SUB_L_SrcEA_M4
00002E9E                          2523  
00002E9E  BABC 00000007           2524              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
00002EA4  6700 00EE               2525              BEQ     SUB_L_SrcEA_M7
00002EA8                          2526  
00002EA8  4EF9 000048A8           2527              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002EAE                          2528  
00002EAE                          2529  SUB_L_SrcEA_M0
00002EAE  7803                    2530              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002EB0  4EB9 000048B0           2531              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002EB6  4EB9 00004BCA           2532              JSR     PrintSub
00002EBC  4EB9 00004BEC           2533              JSR     LengthL
00002EC2  4EB9 00004C10           2534              JSR     PrintSpace
00002EC8  4EB9 00004A2A           2535              JSR     PrintDataReg
00002ECE                          2536  
00002ECE  1A00                    2537              MOVE.B  D0,D5
00002ED0  12EE 0025               2538              MOVE.B  37(A6),(A1)+             *,
00002ED4  4EB9 00004A2A           2539              JSR     PrintDataReg
00002EDA  4E75                    2540              RTS                     ; return to input to get more input
00002EDC                          2541  
00002EDC                          2542  SUB_L_SrcEA_M1
00002EDC  7803                    2543              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002EDE  4EB9 000048B0           2544              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002EE4  4EB9 00004BCA           2545              JSR     PrintSub
00002EEA  4EB9 00004BEC           2546              JSR     LengthL
00002EF0  4EB9 00004C10           2547              JSR     PrintSpace
00002EF6  4EB9 00004A36           2548              JSR     PrintAddrReg
00002EFC                          2549  
00002EFC  1A00                    2550              MOVE.B  D0,D5
00002EFE  12EE 0025               2551              MOVE.B  37(A6),(A1)+             *,
00002F02  4EB9 00004A2A           2552              JSR     PrintDataReg
00002F08  4E75                    2553              RTS                     ; return to input to get more input
00002F0A                          2554  
00002F0A                          2555  SUB_L_SrcEA_M2
00002F0A  7803                    2556              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F0C  4EB9 000048B0           2557              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F12  4EB9 00004BCA           2558              JSR     PrintSub
00002F18  4EB9 00004BEC           2559              JSR     LengthL
00002F1E  4EB9 00004C10           2560              JSR     PrintSpace
00002F24  4EB9 00004A42           2561              JSR     PrintIndirAddrReg
00002F2A                          2562  
00002F2A  1A00                    2563              MOVE.B  D0,D5
00002F2C  12EE 0025               2564              MOVE.B  37(A6),(A1)+             *,
00002F30  4EB9 00004A2A           2565              JSR     PrintDataReg
00002F36  4E75                    2566              RTS                     ; return to input to get more input
00002F38                          2567  
00002F38                          2568  SUB_L_SrcEA_M3
00002F38  7803                    2569              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F3A  4EB9 000048B0           2570              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F40  4EB9 00004BCA           2571              JSR     PrintSub
00002F46  4EB9 00004BEC           2572              JSR     LengthL
00002F4C  4EB9 00004C10           2573              JSR     PrintSpace
00002F52  4EB9 00004A50           2574              JSR     PrintPostIncAddrReg
00002F58                          2575  
00002F58  1A00                    2576              MOVE.B  D0,D5
00002F5A  12EE 0025               2577              MOVE.B  37(A6),(A1)+             *,
00002F5E  4EB9 00004A2A           2578              JSR     PrintDataReg
00002F64  4E75                    2579              RTS                     ; return to input to get more input
00002F66                          2580  
00002F66                          2581  SUB_L_SrcEA_M4
00002F66  7803                    2582              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F68  4EB9 000048B0           2583              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F6E  4EB9 00004BCA           2584              JSR     PrintSub
00002F74  4EB9 00004BEC           2585              JSR     LengthL
00002F7A  4EB9 00004C10           2586              JSR     PrintSpace
00002F80  4EB9 00004A5A           2587              JSR     PrintPreDeincAddrReg
00002F86                          2588  
00002F86  1A00                    2589              MOVE.B  D0,D5
00002F88  12EE 0025               2590              MOVE.B  37(A6),(A1)+             *,
00002F8C  4EB9 00004A2A           2591              JSR     PrintDataReg
00002F92  4E75                    2592              RTS                     ; return to input to get more input
00002F94                          2593  
00002F94                          2594  SUB_L_SrcEA_M7
00002F94  7803                    2595              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00002F96  4EB9 000048B0           2596              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00002F9C                          2597  
00002F9C  BABC 00000000           2598              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00002FA2  6700 001C               2599              BEQ     SUB_L_SrcEA_xxxW
00002FA6                          2600  
00002FA6  BABC 00000001           2601              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00002FAC  6700 0038               2602              BEQ     SUB_L_SrcEA_xxxL
00002FB0                          2603  
00002FB0  BABC 00000004           2604              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00002FB6  6700 0054               2605              BEQ     SUB_L_SrcEA_Data
00002FBA                          2606  
00002FBA  4EF9 000048A8           2607              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00002FC0                          2608  
00002FC0                          2609  SUB_L_SrcEA_xxxW
00002FC0  4EB9 00004BCA           2610              JSR     PrintSub
00002FC6  4EB9 00004BEC           2611              JSR     LengthL
00002FCC  4EB9 00004C10           2612              JSR     PrintSpace
00002FD2  4EB9 000049AA           2613              JSR     PrintByteOrWord
00002FD8                          2614  
00002FD8  1A00                    2615              MOVE.B  D0,D5
00002FDA  12EE 0025               2616              MOVE.B  37(A6),(A1)+             *,
00002FDE  4EB9 00004A2A           2617              JSR     PrintDataReg
00002FE4  4E75                    2618              RTS                     ; return to input to get more input
00002FE6                          2619  
00002FE6                          2620  SUB_L_SrcEA_xxxL
00002FE6  4EB9 00004BCA           2621              JSR     PrintSub
00002FEC  4EB9 00004BEC           2622              JSR     LengthL
00002FF2  4EB9 00004C10           2623              JSR     PrintSpace
00002FF8  4EB9 000049C0           2624              JSR     PrintLong
00002FFE                          2625  
00002FFE  1A00                    2626              MOVE.B  D0,D5
00003000  12EE 0025               2627              MOVE.B  37(A6),(A1)+             *,
00003004  4EB9 00004A2A           2628              JSR     PrintDataReg
0000300A  4E75                    2629              RTS                     ; return to input to get more input
0000300C                          2630  
0000300C                          2631  SUB_L_SrcEA_Data
0000300C  4EB9 00004BCA           2632              JSR     PrintSub
00003012  4EB9 00004BEC           2633              JSR     LengthL
00003018  4EB9 00004C10           2634              JSR     PrintSpace
0000301E  4EB9 0000499E           2635              JSR     PrintImmediateData
00003024                          2636  
00003024  1A00                    2637              MOVE.B  D0,D5
00003026  12EE 0025               2638              MOVE.B  37(A6),(A1)+             *,
0000302A  4EB9 00004A2A           2639              JSR     PrintDataReg
00003030  4E75                    2640              RTS                     ; return to input to get more input
00003032                          2641  
00003032  7803                    2642  SUB_B_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00003034  4EB9 000048B0           2643              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
0000303A                          2644  
0000303A  BABC 00000002           2645              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00003040  6700 0026               2646              BEQ     SUB_B_DesEA_M2
00003044                          2647  
00003044  BABC 00000003           2648              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
0000304A  6700 004E               2649              BEQ     SUB_B_DesEA_M3
0000304E                          2650  
0000304E  BABC 00000004           2651              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00003054  6700 0076               2652              BEQ     SUB_B_DesEA_M4
00003058                          2653  
00003058  BABC 00000007           2654              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
0000305E  6700 009E               2655              BEQ     SUB_B_DesEA_M7
00003062                          2656  
00003062  4EF9 000048A8           2657              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00003068                          2658  
00003068                          2659  SUB_B_DesEA_M2
00003068  7803                    2660              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000306A  4EB9 000048B0           2661              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003070  4EB9 00004BCA           2662              JSR     PrintSub
00003076  4EB9 00004BD8           2663              JSR     LengthB
0000307C  4EB9 00004C10           2664              JSR     PrintSpace
00003082                          2665  
00003082  1E05                    2666              MOVE.B  D5,D7
00003084  1A00                    2667              MOVE.B  D0,D5
00003086  4EB9 00004A2A           2668              JSR     PrintDataReg
0000308C                          2669  
0000308C  1A07                    2670              MOVE.B  D7,D5
0000308E  12EE 0025               2671              MOVE.B  37(A6),(A1)+             *,
00003092  4EB9 00004A42           2672              JSR     PrintIndirAddrReg
00003098  4E75                    2673              RTS                     ; return to input to get more input
0000309A                          2674  
0000309A                          2675  SUB_B_DesEA_M3
0000309A  7803                    2676              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000309C  4EB9 000048B0           2677              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000030A2  4EB9 00004BCA           2678              JSR     PrintSub
000030A8  4EB9 00004BD8           2679              JSR     LengthB
000030AE  4EB9 00004C10           2680              JSR     PrintSpace
000030B4                          2681  
000030B4  1E05                    2682              MOVE.B  D5,D7
000030B6  1A00                    2683              MOVE.B  D0,D5
000030B8  4EB9 00004A2A           2684              JSR     PrintDataReg
000030BE                          2685  
000030BE  1A07                    2686              MOVE.B  D7,D5
000030C0  12EE 0025               2687              MOVE.B  37(A6),(A1)+             *,
000030C4  4EB9 00004A50           2688              JSR     PrintPostIncAddrReg
000030CA  4E75                    2689              RTS                     ; return to input to get more input
000030CC                          2690  
000030CC                          2691  SUB_B_DesEA_M4
000030CC  7803                    2692              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000030CE  4EB9 000048B0           2693              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000030D4  4EB9 00004BCA           2694              JSR     PrintSub
000030DA  4EB9 00004BD8           2695              JSR     LengthB
000030E0  4EB9 00004C10           2696              JSR     PrintSpace
000030E6                          2697  
000030E6  1E05                    2698              MOVE.B  D5,D7
000030E8  1A00                    2699              MOVE.B  D0,D5
000030EA  4EB9 00004A2A           2700              JSR     PrintDataReg
000030F0                          2701  
000030F0  1A07                    2702              MOVE.B  D7,D5
000030F2  12EE 0025               2703              MOVE.B  37(A6),(A1)+             *,
000030F6  4EB9 00004A5A           2704              JSR     PrintPreDeincAddrReg
000030FC  4E75                    2705              RTS                     ; return to input to get more input
000030FE                          2706  
000030FE                          2707  SUB_B_DesEA_M7
000030FE  7803                    2708              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003100  4EB9 000048B0           2709              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003106                          2710  
00003106  BABC 00000000           2711              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
0000310C  6700 FB16               2712              BEQ     SUB_B_SrcEA_xxxW
00003110                          2713  
00003110  BABC 00000001           2714              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00003116  6700 FB32               2715              BEQ     SUB_B_SrcEA_xxxL
0000311A                          2716  
0000311A  BABC 00000004           2717              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
00003120  6700 FB4E               2718              BEQ     SUB_B_SrcEA_Data
00003124                          2719  
00003124  4EF9 000048A8           2720              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
0000312A                          2721  
0000312A                          2722  SUB_B_DesEA_xxxW
0000312A  4EB9 00004BCA           2723              JSR     PrintSub
00003130  4EB9 00004BD8           2724              JSR     LengthB
00003136  4EB9 00004C10           2725              JSR     PrintSpace
0000313C                          2726  
0000313C  1E05                    2727              MOVE.B  D5,D7
0000313E  1A00                    2728              MOVE.B  D0,D5
00003140  4EB9 00004A2A           2729              JSR     PrintDataReg
00003146                          2730  
00003146  1A07                    2731              MOVE.B  D7,D5
00003148  12EE 0025               2732              MOVE.B  37(A6),(A1)+             *,
0000314C  4EB9 000049AA           2733              JSR     PrintByteOrWord
00003152  4E75                    2734              RTS                     ; return to input to get more input
00003154                          2735  
00003154                          2736  SUB_B_DesEA_xxxL
00003154  4EB9 00004BCA           2737              JSR     PrintSub
0000315A  4EB9 00004BD8           2738              JSR     LengthB
00003160  4EB9 00004C10           2739              JSR     PrintSpace
00003166                          2740  
00003166  1E05                    2741              MOVE.B  D5,D7
00003168  1A00                    2742              MOVE.B  D0,D5
0000316A  4EB9 00004A2A           2743              JSR     PrintDataReg
00003170                          2744  
00003170  1A07                    2745              MOVE.B  D7,D5
00003172  12EE 0025               2746              MOVE.B  37(A6),(A1)+             *,
00003176  4EB9 000049C0           2747              JSR     PrintLong
0000317C  4E75                    2748              RTS                     ; return to input to get more input
0000317E                          2749  
0000317E  7803                    2750  SUB_W_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00003180  4EB9 000048B0           2751              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
00003186                          2752  
00003186  BABC 00000002           2753              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
0000318C  6700 0026               2754              BEQ     SUB_W_DesEA_M2
00003190                          2755  
00003190  BABC 00000003           2756              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
00003196  6700 004E               2757              BEQ     SUB_W_DesEA_M3
0000319A                          2758  
0000319A  BABC 00000004           2759              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000031A0  6700 0076               2760              BEQ     SUB_W_DesEA_M4
000031A4                          2761  
000031A4  BABC 00000007           2762              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000031AA  6700 009E               2763              BEQ     SUB_W_DesEA_M7
000031AE                          2764  
000031AE  4EF9 000048A8           2765              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000031B4                          2766  
000031B4                          2767  SUB_W_DesEA_M2
000031B4  7803                    2768              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000031B6  4EB9 000048B0           2769              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000031BC  4EB9 00004BCA           2770              JSR     PrintSub
000031C2  4EB9 00004BE2           2771              JSR     LengthW
000031C8  4EB9 00004C10           2772              JSR     PrintSpace
000031CE                          2773  
000031CE  1E05                    2774              MOVE.B  D5,D7
000031D0  1A00                    2775              MOVE.B  D0,D5
000031D2  4EB9 00004A2A           2776              JSR     PrintDataReg
000031D8                          2777  
000031D8  1A07                    2778              MOVE.B  D7,D5
000031DA  12EE 0025               2779              MOVE.B  37(A6),(A1)+             *,
000031DE  4EB9 00004A42           2780              JSR     PrintIndirAddrReg
000031E4  4E75                    2781              RTS                     ; return to input to get more input
000031E6                          2782  
000031E6                          2783  SUB_W_DesEA_M3
000031E6  7803                    2784              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000031E8  4EB9 000048B0           2785              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
000031EE  4EB9 00004BCA           2786              JSR     PrintSub
000031F4  4EB9 00004BE2           2787              JSR     LengthW
000031FA  4EB9 00004C10           2788              JSR     PrintSpace
00003200                          2789  
00003200  1E05                    2790              MOVE.B  D5,D7
00003202  1A00                    2791              MOVE.B  D0,D5
00003204  4EB9 00004A2A           2792              JSR     PrintDataReg
0000320A                          2793  
0000320A  1A07                    2794              MOVE.B  D7,D5
0000320C  12EE 0025               2795              MOVE.B  37(A6),(A1)+             *,
00003210  4EB9 00004A50           2796              JSR     PrintPostIncAddrReg
00003216  4E75                    2797              RTS                     ; return to input to get more input
00003218                          2798  
00003218                          2799  SUB_W_DesEA_M4
00003218  7803                    2800              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000321A  4EB9 000048B0           2801              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003220  4EB9 00004BCA           2802              JSR     PrintSub
00003226  4EB9 00004BE2           2803              JSR     LengthW
0000322C  4EB9 00004C10           2804              JSR     PrintSpace
00003232                          2805  
00003232  1E05                    2806              MOVE.B  D5,D7
00003234  1A00                    2807              MOVE.B  D0,D5
00003236  4EB9 00004A2A           2808              JSR     PrintDataReg
0000323C                          2809  
0000323C  1A07                    2810              MOVE.B  D7,D5
0000323E  12EE 0025               2811              MOVE.B  37(A6),(A1)+             *,
00003242  4EB9 00004A5A           2812              JSR     PrintPreDeincAddrReg
00003248  4E75                    2813              RTS                     ; return to input to get more input
0000324A                          2814  
0000324A                          2815  SUB_W_DesEA_M7
0000324A  7803                    2816              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000324C  4EB9 000048B0           2817              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003252                          2818  
00003252  BABC 00000000           2819              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
00003258  6700 FB98               2820              BEQ     SUB_W_SrcEA_xxxW
0000325C                          2821  
0000325C  BABC 00000001           2822              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
00003262  6700 FBB4               2823              BEQ     SUB_W_SrcEA_xxxL
00003266                          2824  
00003266  BABC 00000004           2825              CMP.L   #4,D5               ; if the register is 4 the EA mode is #<data>
0000326C  6700 FBD0               2826              BEQ     SUB_W_SrcEA_Data
00003270                          2827  
00003270  4EF9 000048A8           2828              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00003276                          2829  
00003276                          2830  SUB_W_DesEA_xxxW
00003276  4EB9 00004BCA           2831              JSR     PrintSub
0000327C  4EB9 00004BE2           2832              JSR     LengthW
00003282  4EB9 00004C10           2833              JSR     PrintSpace
00003288                          2834  
00003288  1E05                    2835              MOVE.B  D5,D7
0000328A  1A00                    2836              MOVE.B  D0,D5
0000328C  4EB9 00004A2A           2837              JSR     PrintDataReg
00003292                          2838  
00003292  1A07                    2839              MOVE.B  D7,D5
00003294  12EE 0025               2840              MOVE.B  37(A6),(A1)+             *,
00003298  4EB9 000049AA           2841              JSR     PrintByteOrWord
0000329E  4E75                    2842              RTS                     ; return to input to get more input
000032A0                          2843  
000032A0                          2844  SUB_W_DesEA_xxxL
000032A0  4EB9 00004BCA           2845              JSR     PrintSub
000032A6  4EB9 00004BE2           2846              JSR     LengthW
000032AC  4EB9 00004C10           2847              JSR     PrintSpace
000032B2                          2848  
000032B2  1E05                    2849              MOVE.B  D5,D7
000032B4  1A00                    2850              MOVE.B  D0,D5
000032B6  4EB9 00004A2A           2851              JSR     PrintDataReg
000032BC                          2852  
000032BC  1A07                    2853              MOVE.B  D7,D5
000032BE  12EE 0025               2854              MOVE.B  37(A6),(A1)+             *,
000032C2  4EB9 000049C0           2855              JSR     PrintLong
000032C8  4E75                    2856              RTS                     ; return to input to get more input
000032CA                          2857  
000032CA  7803                    2858  SUB_L_DesEA MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000032CC  4EB9 000048B0           2859              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us EA mode
000032D2                          2860  
000032D2  BABC 00000002           2861              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
000032D8  6700 0026               2862              BEQ     SUB_L_DesEA_M2
000032DC                          2863  
000032DC  BABC 00000003           2864              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
000032E2  6700 004E               2865              BEQ     SUB_L_DesEA_M3
000032E6                          2866  
000032E6  BABC 00000004           2867              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
000032EC  6700 0076               2868              BEQ     SUB_L_DesEA_M4
000032F0                          2869  
000032F0  BABC 00000007           2870              CMP.L   #7,D5               ; EA mode is 7, if it D5 is 7
000032F6  6700 009E               2871              BEQ     SUB_L_DesEA_M7
000032FA                          2872  
000032FA  4EF9 000048A8           2873              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
00003300                          2874  
00003300                          2875  SUB_L_DesEA_M2
00003300  7803                    2876              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003302  4EB9 000048B0           2877              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
00003308  4EB9 00004BCA           2878              JSR     PrintSub
0000330E  4EB9 00004BEC           2879              JSR     LengthL
00003314  4EB9 00004C10           2880              JSR     PrintSpace
0000331A                          2881  
0000331A  1E05                    2882              MOVE.B  D5,D7
0000331C  1A00                    2883              MOVE.B  D0,D5
0000331E  4EB9 00004A2A           2884              JSR     PrintDataReg
00003324                          2885  
00003324  1A07                    2886              MOVE.B  D7,D5
00003326  12EE 0025               2887              MOVE.B  37(A6),(A1)+             *,
0000332A  4EB9 00004A42           2888              JSR     PrintIndirAddrReg
00003330  4E75                    2889              RTS                     ; return to input to get more input
00003332                          2890  
00003332                          2891  SUB_L_DesEA_M3
00003332  7803                    2892              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003334  4EB9 000048B0           2893              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000333A  4EB9 00004BCA           2894              JSR     PrintSub
00003340  4EB9 00004BEC           2895              JSR     LengthL
00003346  4EB9 00004C10           2896              JSR     PrintSpace
0000334C                          2897  
0000334C  1E05                    2898              MOVE.B  D5,D7
0000334E  1A00                    2899              MOVE.B  D0,D5
00003350  4EB9 00004A2A           2900              JSR     PrintDataReg
00003356                          2901  
00003356  1A07                    2902              MOVE.B  D7,D5
00003358  12EE 0025               2903              MOVE.B  37(A6),(A1)+             *,
0000335C  4EB9 00004A50           2904              JSR     PrintPostIncAddrReg
00003362  4E75                    2905              RTS                     ; return to input to get more input
00003364                          2906  
00003364                          2907  SUB_L_DesEA_M4
00003364  7803                    2908              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003366  4EB9 000048B0           2909              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000336C  4EB9 00004BCA           2910              JSR     PrintSub
00003372  4EB9 00004BEC           2911              JSR     LengthL
00003378  4EB9 00004C10           2912              JSR     PrintSpace
0000337E                          2913  
0000337E  1E05                    2914              MOVE.B  D5,D7
00003380  1A00                    2915              MOVE.B  D0,D5
00003382  4EB9 00004A2A           2916              JSR     PrintDataReg
00003388                          2917  
00003388  1A07                    2918              MOVE.B  D7,D5
0000338A  12EE 0025               2919              MOVE.B  37(A6),(A1)+             *,
0000338E  4EB9 00004A5A           2920              JSR     PrintPreDeincAddrReg
00003394  4E75                    2921              RTS                     ; return to input to get more input
00003396                          2922  
00003396                          2923  SUB_L_DesEA_M7
00003396  7803                    2924              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003398  4EB9 000048B0           2925              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register
0000339E                          2926  
0000339E  BABC 00000000           2927              CMP.L   #0,D5               ; if the register is 0 the EA mode is (xxx).W
000033A4  6700 FC1A               2928              BEQ     SUB_L_SrcEA_xxxW
000033A8                          2929  
000033A8  BABC 00000001           2930              CMP.L   #1,D5               ; if the register is 1 the EA mode is (xxx).L
000033AE  6700 FC36               2931              BEQ     SUB_L_SrcEA_xxxL
000033B2                          2932  
000033B2  4EF9 000048A8           2933              JMP     InvalidOpcode       ; if it is not one of the EA mode, it is invalid
000033B8                          2934  
000033B8                          2935  SUB_L_DesEA_xxxW
000033B8  4EB9 00004BCA           2936              JSR     PrintSub
000033BE  4EB9 00004BEC           2937              JSR     LengthL
000033C4  4EB9 00004C10           2938              JSR     PrintSpace
000033CA                          2939  
000033CA  1E05                    2940              MOVE.B  D5,D7
000033CC  1A00                    2941              MOVE.B  D0,D5
000033CE  4EB9 00004A2A           2942              JSR     PrintDataReg
000033D4                          2943  
000033D4  1A07                    2944              MOVE.B  D7,D5
000033D6  12EE 0025               2945              MOVE.B  37(A6),(A1)+             *,
000033DA  4EB9 000049AA           2946              JSR     PrintByteOrWord
000033E0  4E75                    2947              RTS                     ; return to input to get more input
000033E2                          2948  
000033E2                          2949  SUB_L_DesEA_xxxL
000033E2  4EB9 00004BCA           2950              JSR     PrintSub
000033E8  4EB9 00004BEC           2951              JSR     LengthL
000033EE  4EB9 00004C10           2952              JSR     PrintSpace
000033F4                          2953  
000033F4  1E05                    2954              MOVE.B  D5,D7
000033F6  1A00                    2955              MOVE.B  D0,D5
000033F8  4EB9 00004A2A           2956              JSR     PrintDataReg
000033FE                          2957  
000033FE  1A07                    2958              MOVE.B  D7,D5
00003400  12EE 0025               2959              MOVE.B  37(A6),(A1)+             *,
00003404  4EB9 000049C0           2960              JSR     PrintLong
0000340A  4E75                    2961              RTS                     ; return to input to get more input
0000340C                          2962  
0000340C                          2963  *************************************************                DIVU_W_Opcode              *************************************************
0000340C                          2964  ; first four bit is (1000 #### #### ####)
0000340C                          2965  DIVU_W_Opcode
0000340C  7803                    2966              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
0000340E  4EB9 000048B0           2967              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the register
00003414                          2968  
00003414  2005                    2969              MOVE.L  D5,D0               ; D0 will hold the register
00003416                          2970          ; D0 will hold the register (position 11-9)
00003416                          2971  
00003416  7803                    2972              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
00003418  4EB9 000048B0           2973              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the register
0000341E                          2974  
0000341E  BABC 00000003           2975              CMP.L   #3,D5               ; position 8-6 should be 011, else it is invalid
00003424  6600 1482               2976              BNE     InvalidOpcode
00003428                          2977  
00003428  7803                    2978              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
0000342A  4EB9 000048B0           2979              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003430                          2980  
00003430  BABC 00000000           2981              CMP.L   #0,D5               ; if EA mode is 0 EA is Dn
00003436  6700 0030               2982              BEQ     DIVU_W_M0
0000343A                          2983  
0000343A  BABC 00000002           2984              CMP.L   #2,D5               ; if EA mode is 2 EA is (An)
00003440  6700 0054               2985              BEQ     DIVU_W_M2
00003444                          2986  
00003444  BABC 00000003           2987              CMP.L   #3,D5               ; if EA mode is 3 EA is (An)+
0000344A  6700 0078               2988              BEQ     DIVU_W_M3
0000344E                          2989  
0000344E  BABC 00000004           2990              CMP.L   #4,D5               ; if EA mode is 4 EA is -(An)
00003454  6700 009C               2991              BEQ     DIVU_W_M4
00003458                          2992  
00003458  BABC 00000007           2993              CMP.L   #7,D5               ; if EA mode is 7 if D5 is 7
0000345E  6700 00C0               2994              BEQ     DIVU_W_M7
00003462                          2995  
00003462  4EF9 000048A8           2996              JMP     InvalidOpcode       ; not one of the valid EA mode
00003468                          2997  
00003468                          2998  
00003468  7803                    2999  DIVU_W_M0   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
0000346A  4EB9 000048B0           3000              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
00003470  4EB9 00004AEE           3001              JSR     PrintDivu
00003476  4EB9 00004BE2           3002              JSR     LengthW
0000347C  4EB9 00004C10           3003              JSR     PrintSpace
00003482  4EB9 00004A2A           3004              JSR     PrintDataReg
00003488                          3005  
00003488  1A00                    3006              MOVE.B  D0,D5
0000348A  12EE 0025               3007              MOVE.B  37(A6),(A1)+             *,
0000348E  4EB9 00004A2A           3008              JSR     PrintDataReg
00003494  4E75                    3009              RTS                     ; return to input to get more input
00003496                          3010  
00003496  7803                    3011  DIVU_W_M2   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003498  4EB9 000048B0           3012              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
0000349E  4EB9 00004AEE           3013              JSR     PrintDivu
000034A4  4EB9 00004BE2           3014              JSR     LengthW
000034AA  4EB9 00004C10           3015              JSR     PrintSpace
000034B0  4EB9 00004A42           3016              JSR     PrintIndirAddrReg
000034B6                          3017  
000034B6  1A00                    3018              MOVE.B  D0,D5
000034B8  12EE 0025               3019              MOVE.B  37(A6),(A1)+             *,
000034BC  4EB9 00004A2A           3020              JSR     PrintDataReg
000034C2  4E75                    3021              RTS                     ; return to input to get more input
000034C4                          3022  
000034C4  7803                    3023  DIVU_W_M3   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000034C6  4EB9 000048B0           3024              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
000034CC  4EB9 00004AEE           3025              JSR     PrintDivu
000034D2  4EB9 00004BE2           3026              JSR     LengthW
000034D8  4EB9 00004C10           3027              JSR     PrintSpace
000034DE  4EB9 00004A50           3028              JSR     PrintPostIncAddrReg
000034E4                          3029  
000034E4  1A00                    3030              MOVE.B  D0,D5
000034E6  12EE 0025               3031              MOVE.B  37(A6),(A1)+             *,
000034EA  4EB9 00004A2A           3032              JSR     PrintDataReg
000034F0  4E75                    3033              RTS                     ; return to input to get more input
000034F2                          3034  
000034F2  7803                    3035  DIVU_W_M4   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
000034F4  4EB9 000048B0           3036              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
000034FA  4EB9 00004AEE           3037              JSR     PrintDivu
00003500  4EB9 00004BE2           3038              JSR     LengthW
00003506  4EB9 00004C10           3039              JSR     PrintSpace
0000350C  4EB9 00004A5A           3040              JSR     PrintPreDeincAddrReg
00003512                          3041  
00003512  1A00                    3042              MOVE.B  D0,D5
00003514  12EE 0025               3043              MOVE.B  37(A6),(A1)+             *,
00003518  4EB9 00004A2A           3044              JSR     PrintDataReg
0000351E  4E75                    3045              RTS                     ; return to input to get more input
00003520                          3046  
00003520  7803                    3047  DIVU_W_M7   MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 2-0) in to D5
00003522  4EB9 000048B0           3048              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the EA register number
00003528                          3049  
00003528  BABC 00000000           3050              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
0000352E  6700 001C               3051              BEQ     DIVU_W_xxxW
00003532                          3052  
00003532  BABC 00000001           3053              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003538  6700 0038               3054              BEQ     DIVU_W_xxxL
0000353C                          3055  
0000353C  BABC 00000004           3056              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00003542  6700 0054               3057              BEQ     DIVU_W_Data
00003546                          3058  
00003546  4EF9 000048A8           3059              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1 or 4, it is invaid
0000354C                          3060  
0000354C  4EB9 00004AEE           3061  DIVU_W_xxxW JSR     PrintDivu
00003552  4EB9 00004BE2           3062              JSR     LengthW
00003558  4EB9 00004C10           3063              JSR     PrintSpace
0000355E  4EB9 000049AA           3064              JSR     PrintByteOrWord
00003564                          3065  
00003564  1A00                    3066              MOVE.B  D0,D5
00003566  12EE 0025               3067              MOVE.B  37(A6),(A1)+             *,
0000356A  4EB9 00004A2A           3068              JSR     PrintDataReg
00003570  4E75                    3069              RTS                     ; return to input to get more input
00003572                          3070  
00003572  4EB9 00004AEE           3071  DIVU_W_xxxL JSR     PrintDivu
00003578  4EB9 00004BE2           3072              JSR     LengthW
0000357E  4EB9 00004C10           3073              JSR     PrintSpace
00003584  4EB9 000049C0           3074              JSR     PrintLong
0000358A                          3075  
0000358A  1A00                    3076              MOVE.B  D0,D5
0000358C  12EE 0025               3077              MOVE.B  37(A6),(A1)+             *,
00003590  4EB9 00004A2A           3078              JSR     PrintDataReg
00003596  4E75                    3079              RTS                     ; return to input to get more input
00003598                          3080  
00003598  4EB9 00004AEE           3081  DIVU_W_Data JSR     PrintDivu
0000359E  4EB9 00004BE2           3082              JSR     LengthW
000035A4  4EB9 00004C10           3083              JSR     PrintSpace
000035AA  4EB9 0000499E           3084              JSR     PrintImmediateData
000035B0                          3085  
000035B0  1A00                    3086              MOVE.B  D0,D5
000035B2  12EE 0025               3087              MOVE.B  37(A6),(A1)+             *,
000035B6  4EB9 00004A2A           3088              JSR     PrintDataReg
000035BC  4E75                    3089              RTS                     ; return to input to get more input
000035BE                          3090  
000035BE                          3091  *************************************************                Bcc_Opcode                 *************************************************
000035BE                          3092  ; first four bit is (0110 #### #### ####)
000035BE                          3093  Bcc_Opcode
000035BE  7804                    3094              MOVE.L  #4,D4          ; get the next 4 bit from (A4)(position 11-8) in to D5
000035C0  4EB9 000048B0           3095              JSR     GetNextD4bit   ; D5 hold the next 4 bit of (A4), which tell us which Bcc
000035C6                          3096         ; cmp to see whice Bcc opcode the the next 4 bit(position 11-8) match with
000035C6  BABC 0000000E           3097              CMP.L   #14,D5
000035CC  6700 0026               3098              BEQ     BGT_Opcode
000035D0                          3099  
000035D0  BABC 0000000F           3100              CMP.L   #15,D5
000035D6  6700 0028               3101              BEQ     BLE_Opcode
000035DA                          3102  
000035DA  BABC 00000000           3103              CMP.L   #0,D5
000035E0  6700 002A               3104              BEQ     BRA_Opcode
000035E4                          3105  
000035E4  BABC 00000007           3106              CMP.L   #7,D5
000035EA  6700 002C               3107              BEQ     BEQ_Opcode
000035EE                          3108  
000035EE  4EF9 000048A8           3109              JMP     InvalidOpcode   ; (position 11-8) did not match any of the Bcc opcode, so it is invalid
000035F4                          3110  
000035F4                          3111  
000035F4  4EB9 00004AC4           3112  BGT_Opcode  JSR PrintBGT
000035FA  4EF9 00003624           3113              JMP     Bcc_displacement ; take care of output the displacement bit
00003600                          3114  
00003600  4EB9 00004AD2           3115  BLE_Opcode  JSR PrintBLE
00003606  4EF9 00003624           3116              JMP     Bcc_displacement ; take care of output the displacement bit
0000360C                          3117  
0000360C  4EB9 00004AE0           3118  BRA_Opcode  JSR PrintBRA
00003612  4EF9 00003624           3119              JMP     Bcc_displacement ; take care of output the displacement bit
00003618                          3120  
00003618  4EB9 00004AB6           3121  BEQ_Opcode  JSR PrintBEQ
0000361E  4EF9 00003624           3122              JMP     Bcc_displacement ; take care of output the displacement bit
00003624                          3123  
00003624                          3124  Bcc_displacement    ;for gettin the next 8 bit for displacement and outputting it
00003624  7808                    3125              MOVE.L  #8,D4          ; get the next 8 bit from (A4)(position 7-0) in to D5
00003626  4EB9 000048B0           3126              JSR     GetNextD4bit   ; D5 hold the next 4 bit of (A4), which tell us the displacement
0000362C                          3127  
0000362C  BABC 00000000           3128              CMP.L   #$00,D5          ; if displacement is $00 than it is a 16bit displacement
00003632  6700 000E               3129              BEQ     Bcc_16bit_Disp
00003636                          3130  
00003636  BABC 000000FF           3131              CMP.L   #$FF,D5
0000363C  6700 000E               3132              BEQ     Bcc_32bit_Disp   ; if displacement is $00 than it is a 32bit displacement
00003640                          3133  
00003640                          3134              ; print 8bit displacemnt address from D5
00003640  4E75                    3135              RTS                     ; return to input to get more input
00003642                          3136  
00003642                          3137  Bcc_16bit_Disp
00003642                          3138              ; print 16bit address
00003642  12EE 002C               3139              MOVE.B   44(A6),(A1)+        *(space)
00003646  12EE 0026               3140                  MOVE.B   38(A6),(A1)+        *$
0000364A  4E75                    3141              RTS                     ; return to input to get more input
0000364C                          3142  
0000364C                          3143  Bcc_32bit_Disp
0000364C                          3144              ; print 32bit address
0000364C  12EE 002C               3145              MOVE.B   44(A6),(A1)+        *(space)
00003650  12EE 0026               3146                  MOVE.B   38(A6),(A1)+        *$
00003654  4E75                    3147              RTS                     ; return to input to get more input
00003656                          3148  
00003656                          3149  
00003656                          3150  *************************************************                NeedMoreBit                *************************************************
00003656                          3151  ;Could be MOVEM, MULS.L, DIVU.L, JSR, NOT, LEA
00003656                          3152  ; first four bit is (0100 #### #### ####)
00003656                          3153  NeedMoreBit
00003656  7806                    3154              MOVE.L  #6,D4          ; get the next 6 bit from (A4)(position 11-6) in to D5
00003658  4EB9 000048B0           3155              JSR     GetNextD4bit   ; D5 hold the next 6 bit of (A4), which will narrow down the opcode possibility
0000365E                          3156  
0000365E  BABC 00000022           3157              CMP.L   #34,D5         ; if position 11-6 equal to 34, it is MoveM register to memory size Word
00003664  6700 0136               3158              BEQ     MoveM_R2M_W
00003668                          3159  
00003668  BABC 00000023           3160              CMP.L   #35,D5         ; if position 11-6 equal to 35, it is MoveM register to memory size Long
0000366E  6700 0212               3161              BEQ     MoveM_R2M_L
00003672                          3162  
00003672  BABC 00000032           3163              CMP.L   #50,D5         ; if position 11-6 equal to 50, it is MoveM memory to register size word
00003678  6700 02EE               3164              BEQ     MoveM_M2R_W
0000367C                          3165  
0000367C  BABC 00000033           3166              CMP.L   #51,D5         ; if position 11-6 equal to 51, it is MoveM memory to register size long
00003682  6700 03CA               3167              BEQ     MoveM_M2R_L
00003686                          3168  
00003686  BABC 00000030           3169              CMP.L   #48,D5         ; if position 11-6 equal to 48, it is MULS.L
0000368C  6700 04A6               3170              BEQ     Muls_L
00003690                          3171  
00003690  BABC 00000031           3172              CMP.L   #49,D5         ; if position 11-6 equal to 49, it is DIVU.L
00003696  6700 0632               3173              BEQ     Divu_L
0000369A                          3174  
0000369A  BABC 0000003A           3175              CMP.L   #58,D5         ; if position 11-6 equal to 58, it is JSR
000036A0  6700 07BE               3176              BEQ     JSR_Opcode
000036A4                          3177  
000036A4  BABC 00000018           3178              CMP.L   #24,D5         ; if position 11-6 equal to 24, it is NOT size byte
000036AA  6700 083C               3179              BEQ     Not_B_Opcode
000036AE                          3180  
000036AE  BABC 00000019           3181              CMP.L   #25,D5         ; if position 11-6 equal to 25, it is NOT size word
000036B4  6700 0950               3182              BEQ     Not_W_Opcode
000036B8                          3183  
000036B8  BABC 0000001A           3184              CMP.L   #26,D5         ; if position 11-6 equal to 26, it is NOT size long
000036BE  6700 0A64               3185              BEQ     Not_L_Opcode
000036C2                          3186  
000036C2                          3187  
000036C2                          3188  *************************************************                Lea_Opcode                 *************************************************
000036C2                          3189  ; notice there is no line that say jupm to Lea_Opcode, it should be run automatically of after NeedMoreBit, if it doesn't match other opcode
000036C2                          3190  Lea_Opcode  ; the only posible opcode left is LEA, it is LEA if the bit from position 8-6 is all 1
000036C2  E28D                    3191              LSR.L   #1,D5          ; shift left to get carry bit of 6 place
000036C4  6400 11E2               3192              BCC     InvalidOpcode  ; if the carry bit is is not 1, it is not a valid opcode
000036C8  E28D                    3193              LSR.L   #1,D5          ; shift left to get carry bit of 5 place
000036CA  6400 11DC               3194              BCC     InvalidOpcode  ; if the carry bit is is not 1, it is not a valid opcode
000036CE  E28D                    3195              LSR.L   #1,D5          ; shift left to get carry bit of 4 place
000036D0  6400 11D6               3196              BCC     InvalidOpcode  ; if the carry bit is is not 1, it is not a valid opcode
000036D4                          3197  
000036D4                          3198          ; D5 should hold the position 11-9, which is the register, since D5 originaly hold bit from position 11-6 and we shift right 3 times.
000036D4                          3199          ; D0 will hold the register number for LEA opcode
000036D4                          3200  
000036D4  2005                    3201              MOVE.L  D5,D0          ; D0 will hold the register number for LEA opcode
000036D6                          3202  
000036D6  7803                    3203              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
000036D8  4EB9 000048B0           3204              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
000036DE                          3205  
000036DE  BABC 00000002           3206              CMP.L   #2,D5          ; if position 5-3 is two the EA for LEA is (An) mode 2
000036E4  6700 0012               3207              BEQ     Lea_M2_Opcode
000036E8                          3208  
000036E8  BABC 00000007           3209              CMP.L   #7,D5          ; if position 5-3 is 7 the EA for LEA is mode 7
000036EE  6700 0030               3210              BEQ     Lea_M7_Opcode
000036F2                          3211  
000036F2  4EF9 000048A8           3212              JMP     InvalidOpcode  ; if it is not mode 7 or mode 2, LEA is invaid
000036F8                          3213  
000036F8                          3214  Lea_M2_Opcode
000036F8  7803                    3215              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000036FA  4EB9 000048B0           3216              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003700  4EB9 00004B0E           3217              JSR     PrintLEA
00003706  4EB9 00004C10           3218              JSR     PrintSpace
0000370C  4EB9 00004A42           3219              JSR     PrintIndirAddrReg
00003712                          3220  
00003712  1A00                    3221              MOVE.B  D0,D5
00003714  12EE 0025               3222              MOVE.B  37(A6),(A1)+             *,
00003718  4EB9 00004A36           3223              JSR     PrintAddrReg
0000371E  4E75                    3224              RTS                     ; return to input to get more input
00003720                          3225  
00003720                          3226  Lea_M7_Opcode
00003720  7803                    3227              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003722  4EB9 000048B0           3228              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003728                          3229  
00003728  BABC 00000000           3230              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for LEA is (xxx).W
0000372E  6700 0012               3231              BEQ     Lea_xxxW_Opcode
00003732                          3232  
00003732  BABC 00000001           3233              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for LEA is (xxx).L
00003738  6700 0028               3234              BEQ     Lea_xxxL_Opcode
0000373C                          3235  
0000373C  4EF9 000048A8           3236              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, LEA is invaid
00003742                          3237  
00003742                          3238  Lea_xxxW_Opcode
00003742  4EB9 00004B0E           3239              JSR     PrintLEA
00003748  4EB9 00004C10           3240              JSR     PrintSpace
0000374E  4EB9 000049AA           3241              JSR     PrintByteOrWord
00003754                          3242  
00003754  1A00                    3243              MOVE.B  D0,D5
00003756  12EE 0025               3244              MOVE.B  37(A6),(A1)+             *,
0000375A  4EB9 00004A36           3245              JSR     PrintAddrReg
00003760  4E75                    3246              RTS                     ; return to input to get more input
00003762                          3247  
00003762                          3248  Lea_xxxL_Opcode
00003762  4EB9 00004B0E           3249              JSR PrintLEA
00003768  4EB9 00004C10           3250              JSR     PrintSpace
0000376E  4EB9 000049C0           3251              JSR     PrintLong
00003774                          3252  
00003774  1A00                    3253              MOVE.B  D0,D5
00003776  12EE 0025               3254              MOVE.B  37(A6),(A1)+             *,
0000377A  4EB9 00004A36           3255              JSR     PrintAddrReg
00003780  4E75                    3256              RTS                     ; return to input to get more input
00003782                          3257  
00003782                          3258  
00003782                          3259  *************************************************                MoveM_R2M_W                *************************************************
00003782                          3260  ; MOVEM.W from register to memory
00003782                          3261  ; first 10 bit is (0100 1000 10## ####)
00003782                          3262  PrintList
00003782  12EE 0027               3263              MOVE.B   39(A6),(A1)+        *(
00003786  12EE 0015               3264              MOVE.B   21(A6),(A1)+        *L
0000378A  12EE 0012               3265              MOVE.B   18(A6),(A1)+        *I
0000378E  12EE 001C               3266              MOVE.B   28(A6),(A1)+        *S
00003792  12EE 001D               3267              MOVE.B   29(A6),(A1)+        *T
00003796  12EE 0028               3268              MOVE.B   40(A6),(A1)+        *)
0000379A  4E75                    3269              RTS
0000379C                          3270  
0000379C                          3271  MoveM_R2M_W
0000379C  7803                    3272              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
0000379E  4EB9 000048B0           3273              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
000037A4                          3274  
000037A4  BABC 00000002           3275              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
000037AA  6700 001C               3276              BEQ     MoveM_R2M_W_M2
000037AE                          3277  
000037AE  BABC 00000004           3278              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
000037B4  6700 003C               3279              BEQ     MoveM_R2M_W_M4
000037B8                          3280  
000037B8  BABC 00000007           3281              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
000037BE  6700 005C               3282              BEQ     MoveM_R2M_W_M7
000037C2                          3283  
000037C2  4EF9 000048A8           3284              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
000037C8                          3285  
000037C8                          3286  MoveM_R2M_W_M2
000037C8  7803                    3287              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000037CA  4EB9 000048B0           3288              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000037D0  4EB9 00004B5E           3289              JSR     PrintMoveM
000037D6  4EB9 00004BE2           3290              JSR     LengthW
000037DC  4EB9 00004C10           3291              JSR     PrintSpace
000037E2  4EB8 3782               3292              JSR     PrintList
000037E6  12EE 0025               3293              MOVE.B  37(A6),(A1)+             *,
000037EA  4EB9 00004A42           3294              JSR     PrintIndirAddrReg
000037F0  4E75                    3295              RTS                     ; return to input to get more input
000037F2                          3296  
000037F2                          3297  MoveM_R2M_W_M4
000037F2  7803                    3298              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000037F4  4EB9 000048B0           3299              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000037FA  4EB9 00004B5E           3300              JSR     PrintMoveM
00003800  4EB9 00004BE2           3301              JSR     LengthW
00003806  4EB9 00004C10           3302              JSR     PrintSpace
0000380C  4EB8 3782               3303              JSR     PrintList
00003810  12EE 0025               3304              MOVE.B  37(A6),(A1)+             *,
00003814  4EB9 00004A5A           3305              JSR     PrintPreDeincAddrReg
0000381A  4E75                    3306              RTS                     ; return to input to get more input
0000381C                          3307  
0000381C                          3308  MoveM_R2M_W_M7
0000381C  7803                    3309              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000381E  4EB9 000048B0           3310              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003824                          3311  
00003824  BABC 00000000           3312              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
0000382A  6700 0012               3313              BEQ     MoveM_R2M_W_xxxW
0000382E                          3314  
0000382E  BABC 00000001           3315              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
00003834  6700 002A               3316              BEQ     MoveM_R2M_W_xxxL
00003838                          3317  
00003838  4EF9 000048A8           3318              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
0000383E                          3319  
0000383E                          3320  MoveM_R2M_W_xxxW
0000383E  4EB9 00004B5E           3321              JSR     PrintMoveM
00003844  4EB9 00004BE2           3322              JSR     LengthW
0000384A  4EB9 00004C10           3323              JSR     PrintSpace
00003850  4EB8 3782               3324              JSR     PrintList
00003854  12EE 0025               3325              MOVE.B  37(A6),(A1)+             *,
00003858  4EB9 000049AA           3326              JSR     PrintByteOrWord
0000385E  4E75                    3327              RTS                     ; return to input to get more input
00003860                          3328  
00003860                          3329  MoveM_R2M_W_xxxL
00003860  4EB9 00004B5E           3330              JSR     PrintMoveM
00003866  4EB9 00004BE2           3331              JSR     LengthW
0000386C  4EB9 00004C10           3332              JSR     PrintSpace
00003872  4EB8 3782               3333              JSR     PrintList
00003876  12EE 0025               3334              MOVE.B  37(A6),(A1)+             *,
0000387A  4EB9 000049C0           3335              JSR     PrintLong
00003880  4E75                    3336              RTS                     ; return to input to get more input
00003882                          3337  
00003882                          3338  
00003882                          3339  *************************************************                MoveM_R2M_L                *************************************************
00003882                          3340  ; MOVEM.L from register to memory
00003882                          3341  ; first 10 bit is (0100 1000 11## ####)
00003882                          3342  MoveM_R2M_L
00003882  7803                    3343              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003884  4EB9 000048B0           3344              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
0000388A                          3345  
0000388A  BABC 00000002           3346              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
00003890  6700 001C               3347              BEQ     MoveM_R2M_L_M2
00003894                          3348  
00003894  BABC 00000004           3349              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
0000389A  6700 003C               3350              BEQ     MoveM_R2M_L_M4
0000389E                          3351  
0000389E  BABC 00000007           3352              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
000038A4  6700 005C               3353              BEQ     MoveM_R2M_L_M7
000038A8                          3354  
000038A8  4EF9 000048A8           3355              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
000038AE                          3356  
000038AE                          3357  MoveM_R2M_L_M2
000038AE  7803                    3358              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000038B0  4EB9 000048B0           3359              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000038B6  4EB9 00004B5E           3360              JSR     PrintMoveM
000038BC  4EB9 00004BEC           3361              JSR     LengthL
000038C2  4EB9 00004C10           3362              JSR     PrintSpace
000038C8  4EB8 3782               3363              JSR     PrintList
000038CC  12EE 0025               3364              MOVE.B  37(A6),(A1)+             *,
000038D0  4EB9 00004A42           3365              JSR     PrintIndirAddrReg
000038D6  4E75                    3366              RTS                     ; return to input to get more input
000038D8                          3367  
000038D8                          3368  MoveM_R2M_L_M4
000038D8  7803                    3369              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000038DA  4EB9 000048B0           3370              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000038E0  4EB9 00004B5E           3371              JSR     PrintMoveM
000038E6  4EB9 00004BEC           3372              JSR     LengthL
000038EC  4EB9 00004C10           3373              JSR     PrintSpace
000038F2  4EB8 3782               3374              JSR     PrintList
000038F6  12EE 0025               3375              MOVE.B  37(A6),(A1)+             *,
000038FA  4EB9 00004A5A           3376              JSR     PrintPreDeincAddrReg
00003900  4E75                    3377              RTS                     ; return to input to get more input
00003902                          3378  
00003902                          3379  MoveM_R2M_L_M7
00003902  7803                    3380              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003904  4EB9 000048B0           3381              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000390A                          3382  
0000390A  BABC 00000000           3383              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
00003910  6700 0012               3384              BEQ     MoveM_R2M_L_xxxW
00003914                          3385  
00003914  BABC 00000001           3386              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
0000391A  6700 002A               3387              BEQ     MoveM_R2M_L_xxxL
0000391E                          3388  
0000391E  4EF9 000048A8           3389              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
00003924                          3390  
00003924                          3391  MoveM_R2M_L_xxxW
00003924  4EB9 00004B5E           3392              JSR PrintMoveM
0000392A  4EB9 00004BEC           3393              JSR LengthL
00003930  4EB9 00004C10           3394              JSR     PrintSpace
00003936  4EB8 3782               3395              JSR     PrintList
0000393A  12EE 0025               3396              MOVE.B  37(A6),(A1)+             *,
0000393E  4EB9 000049AA           3397              JSR     PrintByteOrWord
00003944  4E75                    3398              RTS                     ; return to input to get more input
00003946                          3399  
00003946                          3400  MoveM_R2M_L_xxxL
00003946  4EB9 00004B5E           3401              JSR PrintMoveM
0000394C  4EB9 00004BEC           3402              JSR LengthL
00003952  4EB9 00004C10           3403              JSR     PrintSpace
00003958  4EB8 3782               3404              JSR     PrintList
0000395C  12EE 0025               3405              MOVE.B  37(A6),(A1)+             *,
00003960  4EB9 000049C0           3406              JSR     PrintLong
00003966  4E75                    3407              RTS                     ; return to input to get more input
00003968                          3408  
00003968                          3409  *************************************************                MoveM_M2R_W                *************************************************
00003968                          3410  ; MOVEM.W from memory to register
00003968                          3411  ; first 10 bit is (0100 1100 10## ####)
00003968                          3412  MoveM_M2R_W
00003968  7803                    3413              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
0000396A  4EB9 000048B0           3414              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003970                          3415  
00003970  BABC 00000002           3416              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
00003976  6700 001C               3417              BEQ     MoveM_M2R_W_M2
0000397A                          3418  
0000397A  BABC 00000004           3419              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
00003980  6700 003C               3420              BEQ     MoveM_M2R_W_M4
00003984                          3421  
00003984  BABC 00000007           3422              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
0000398A  6700 005C               3423              BEQ     MoveM_M2R_W_M7
0000398E                          3424  
0000398E  4EF9 000048A8           3425              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
00003994                          3426  
00003994                          3427  MoveM_M2R_W_M2
00003994  7803                    3428              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003996  4EB9 000048B0           3429              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000399C  4EB9 00004B5E           3430              JSR     PrintMoveM
000039A2  4EB9 00004BE2           3431              JSR     LengthW
000039A8  4EB9 00004C10           3432              JSR     PrintSpace
000039AE  4EB9 00004A42           3433              JSR     PrintIndirAddrReg
000039B4                          3434  
000039B4  12EE 0025               3435              MOVE.B  37(A6),(A1)+             *,
000039B8  4EB8 3782               3436              JSR     PrintList
000039BC  4E75                    3437              RTS                     ; return to input to get more input
000039BE                          3438  
000039BE                          3439  MoveM_M2R_W_M4
000039BE  7803                    3440              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000039C0  4EB9 000048B0           3441              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000039C6  4EB9 00004B5E           3442              JSR     PrintMoveM
000039CC  4EB9 00004BE2           3443              JSR     LengthW
000039D2  4EB9 00004C10           3444              JSR     PrintSpace
000039D8  4EB9 00004A5A           3445              JSR     PrintPreDeincAddrReg
000039DE                          3446  
000039DE  12EE 0025               3447              MOVE.B  37(A6),(A1)+             *,
000039E2  4EB8 3782               3448              JSR     PrintList
000039E6  4E75                    3449              RTS                     ; return to input to get more input
000039E8                          3450  
000039E8                          3451  MoveM_M2R_W_M7
000039E8  7803                    3452              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000039EA  4EB9 000048B0           3453              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000039F0                          3454  
000039F0  BABC 00000000           3455              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
000039F6  6700 0012               3456              BEQ     MoveM_M2R_W_xxxW
000039FA                          3457  
000039FA  BABC 00000001           3458              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
00003A00  6700 002A               3459              BEQ     MoveM_M2R_W_xxxL
00003A04                          3460  
00003A04  4EF9 000048A8           3461              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
00003A0A                          3462  
00003A0A                          3463  MoveM_M2R_W_xxxW
00003A0A  4EB9 00004B5E           3464              JSR     PrintMoveM
00003A10  4EB9 00004BE2           3465              JSR     LengthW
00003A16  4EB9 00004C10           3466              JSR     PrintSpace
00003A1C  4EB9 000049AA           3467              JSR     PrintByteOrWord
00003A22                          3468  
00003A22  12EE 0025               3469              MOVE.B  37(A6),(A1)+             *,
00003A26  4EB8 3782               3470              JSR     PrintList
00003A2A  4E75                    3471              RTS                     ; return to input to get more input
00003A2C                          3472  
00003A2C                          3473  MoveM_M2R_W_xxxL
00003A2C  4EB9 00004B5E           3474              JSR     PrintMoveM
00003A32  4EB9 00004BE2           3475              JSR     LengthW
00003A38  4EB9 00004C10           3476              JSR     PrintSpace
00003A3E  4EB9 000049C0           3477              JSR     PrintLong
00003A44                          3478  
00003A44  12EE 0025               3479              MOVE.B  37(A6),(A1)+             *,
00003A48  4EB8 3782               3480              JSR     PrintList
00003A4C  4E75                    3481              RTS                     ; return to input to get more input
00003A4E                          3482  
00003A4E                          3483  *************************************************                MoveM_M2R_L                *************************************************
00003A4E                          3484  ; MOVEM.L from memory to register
00003A4E                          3485  ; first 10 bit is (0100 1100 11## ####)
00003A4E                          3486  MoveM_M2R_L
00003A4E  7803                    3487              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003A50  4EB9 000048B0           3488              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003A56                          3489  
00003A56  BABC 00000002           3490              CMP.L   #2,D5          ; if position 5-3 is two the EA for moveM is (An) mode 2
00003A5C  6700 001C               3491              BEQ     MoveM_M2R_L_M2
00003A60                          3492  
00003A60  BABC 00000004           3493              CMP.L   #4,D5          ; if position 5-3 is two the EA for moveM is -(An) mode 4
00003A66  6700 003C               3494              BEQ     MoveM_M2R_L_M4
00003A6A                          3495  
00003A6A  BABC 00000007           3496              CMP.L   #7,D5          ; if position 5-3 is two the EA for moveM is mode 7
00003A70  6700 005C               3497              BEQ     MoveM_M2R_L_M7
00003A74                          3498  
00003A74  4EF9 000048A8           3499              JMP     InvalidOpcode  ; if it is not mode 2,4 or mode 7, moveM is invaid
00003A7A                          3500  
00003A7A                          3501  MoveM_M2R_L_M2
00003A7A  7803                    3502              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003A7C  4EB9 000048B0           3503              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003A82  4EB9 00004B5E           3504              JSR     PrintMoveM
00003A88  4EB9 00004BEC           3505              JSR     LengthL
00003A8E  4EB9 00004C10           3506              JSR     PrintSpace
00003A94  4EB9 00004A42           3507              JSR     PrintIndirAddrReg
00003A9A                          3508  
00003A9A  12EE 0025               3509              MOVE.B  37(A6),(A1)+             *,
00003A9E  4EB8 3782               3510              JSR     PrintList
00003AA2  4E75                    3511              RTS                     ; return to input to get more input
00003AA4                          3512  
00003AA4                          3513  MoveM_M2R_L_M4
00003AA4  7803                    3514              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003AA6  4EB9 000048B0           3515              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003AAC  4EB9 00004B5E           3516              JSR     PrintMoveM
00003AB2  4EB9 00004BEC           3517              JSR     LengthL
00003AB8  4EB9 00004C10           3518              JSR     PrintSpace
00003ABE  4EB9 00004A5A           3519              JSR     PrintPreDeincAddrReg
00003AC4                          3520  
00003AC4  12EE 0025               3521              MOVE.B  37(A6),(A1)+             *,
00003AC8  4EB8 3782               3522              JSR     PrintList
00003ACC  4E75                    3523              RTS                     ; return to input to get more input
00003ACE                          3524  
00003ACE                          3525  MoveM_M2R_L_M7
00003ACE  7803                    3526              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003AD0  4EB9 000048B0           3527              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003AD6                          3528  
00003AD6  BABC 00000000           3529              CMP.L   #0,D5          ; if position 2-0 is 0 the EA for MoveM is (xxx).W
00003ADC  6700 0012               3530              BEQ     MoveM_M2R_L_xxxW
00003AE0                          3531  
00003AE0  BABC 00000001           3532              CMP.L   #1,D5          ; if position 2-0 is 1 the EA for MoveM is (xxx).L
00003AE6  6700 002A               3533              BEQ     MoveM_M2R_L_xxxL
00003AEA                          3534  
00003AEA  4EF9 000048A8           3535              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, moveM is invaid
00003AF0                          3536  
00003AF0                          3537  MoveM_M2R_L_xxxW
00003AF0  4EB9 00004B5E           3538              JSR     PrintMoveM
00003AF6  4EB9 00004BEC           3539              JSR     LengthL
00003AFC  4EB9 00004C10           3540              JSR     PrintSpace
00003B02  4EB9 000049AA           3541              JSR     PrintByteOrWord
00003B08                          3542  
00003B08  12EE 0025               3543              MOVE.B  37(A6),(A1)+             *,
00003B0C  4EB8 3782               3544              JSR     PrintList
00003B10  4E75                    3545              RTS                     ; return to input to get more input
00003B12                          3546  
00003B12                          3547  MoveM_M2R_L_xxxL
00003B12  4EB9 00004B5E           3548              JSR     PrintMoveM
00003B18  4EB9 00004BEC           3549              JSR     LengthL
00003B1E  4EB9 00004C10           3550              JSR     PrintSpace
00003B24  4EB9 000049C0           3551              JSR     PrintLong
00003B2A                          3552  
00003B2A  12EE 0025               3553              MOVE.B  37(A6),(A1)+             *,
00003B2E  4EB8 3782               3554              JSR     PrintList
00003B32  4E75                    3555              RTS                     ; return to input to get more input
00003B34                          3556  
00003B34                          3557  *************************************************                Muls_L                 *************************************************
00003B34                          3558  ; first 10 bit is (0100 1100 00## ####)
00003B34  7803                    3559  Muls_L      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003B36  4EB9 000048B0           3560              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003B3C                          3561  
00003B3C  BABC 00000000           3562              CMP.L   #0,D5          ; if position 5-3 is 0 the EA for MULS.L is Dn mode 0
00003B42  6700 0030               3563              BEQ     Muls_L_M0
00003B46                          3564  
00003B46  BABC 00000002           3565              CMP.L   #2,D5          ; if position 5-3 is 2 the EA for MULS.L is (An) mode 2
00003B4C  6700 0054               3566              BEQ     Muls_L_M2
00003B50                          3567  
00003B50  BABC 00000003           3568              CMP.L   #3,D5          ; if position 5-3 is 3 the EA for MULS.L is (An)+ mode 3
00003B56  6700 0078               3569              BEQ     Muls_L_M3
00003B5A                          3570  
00003B5A  BABC 00000004           3571              CMP.L   #4,D5          ; if position 5-3 is 4 the EA for MULS.L is -(An) mode 4
00003B60  6700 009C               3572              BEQ     Muls_L_M4
00003B64                          3573  
00003B64  BABC 00000007           3574              CMP.L   #7,D5          ; if position 5-3 is 7 the EA for MULS.L is mode 7
00003B6A  6700 00C0               3575              BEQ     Muls_L_M7
00003B6E                          3576  
00003B6E  4EF9 000048A8           3577              JMP     InvalidOpcode  ; if it is not one of the moveM EA mode
00003B74                          3578  
00003B74  7803                    3579  Muls_L_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003B76  4EB9 000048B0           3580              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003B7C  4EB9 00004B68           3581              JSR     PrintMuls
00003B82  4EB9 00004BEC           3582              JSR     LengthL
00003B88  4EB9 00004C10           3583              JSR     PrintSpace
00003B8E  4EB9 00004A2A           3584              JSR     PrintDataReg
00003B94                          3585  
00003B94  12EE 0025               3586              MOVE.B  37(A6),(A1)+             *,
00003B98  385C                    3587              MOVE.W  (A4)+,A4
00003B9A  4EB9 00004928           3588              JSR     PrintAddr
00003BA0  4E75                    3589              RTS                     ; return to input to get more input
00003BA2                          3590  
00003BA2  7803                    3591  Muls_L_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003BA4  4EB9 000048B0           3592              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003BAA  4EB9 00004B68           3593              JSR     PrintMuls
00003BB0  4EB9 00004BEC           3594              JSR     LengthL
00003BB6  4EB9 00004C10           3595              JSR     PrintSpace
00003BBC  4EB9 00004A42           3596              JSR     PrintIndirAddrReg
00003BC2                          3597  
00003BC2  12EE 0025               3598              MOVE.B  37(A6),(A1)+             *,
00003BC6  385C                    3599              MOVE.W  (A4)+,A4
00003BC8  4EB9 00004928           3600              JSR     PrintAddr
00003BCE  4E75                    3601              RTS                     ; return to input to get more input
00003BD0                          3602  
00003BD0  7803                    3603  Muls_L_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003BD2  4EB9 000048B0           3604              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003BD8  4EB9 00004B68           3605              JSR     PrintMuls
00003BDE  4EB9 00004BEC           3606              JSR     LengthL
00003BE4  4EB9 00004C10           3607              JSR     PrintSpace
00003BEA  4EB9 00004A50           3608              JSR     PrintPostIncAddrReg
00003BF0                          3609  
00003BF0  12EE 0025               3610              MOVE.B  37(A6),(A1)+             *,
00003BF4  385C                    3611              MOVE.W  (A4)+,A4
00003BF6  4EB9 00004928           3612              JSR     PrintAddr
00003BFC  4E75                    3613              RTS                     ; return to input to get more input
00003BFE                          3614  
00003BFE  7803                    3615  Muls_L_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003C00  4EB9 000048B0           3616              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003C06  4EB9 00004B68           3617              JSR     PrintMuls
00003C0C  4EB9 00004BEC           3618              JSR     LengthL
00003C12  4EB9 00004C10           3619              JSR     PrintSpace
00003C18  4EB9 00004A5A           3620              JSR     PrintPreDeincAddrReg
00003C1E                          3621  
00003C1E  12EE 0025               3622              MOVE.B  37(A6),(A1)+             *,
00003C22  385C                    3623              MOVE.W  (A4)+,A4
00003C24  4EB9 00004928           3624              JSR     PrintAddr
00003C2A  4E75                    3625              RTS                     ; return to input to get more input
00003C2C                          3626  
00003C2C  7803                    3627  Muls_L_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003C2E  4EB9 000048B0           3628              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003C34                          3629  
00003C34  BABC 00000000           3630              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003C3A  6700 001C               3631              BEQ     Muls_L_xxxW
00003C3E                          3632  
00003C3E  BABC 00000001           3633              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003C44  6700 0038               3634              BEQ     Muls_L_xxxL
00003C48                          3635  
00003C48  BABC 00000004           3636              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00003C4E  6700 0054               3637              BEQ     Muls_L_Data
00003C52                          3638  
00003C52  4EF9 000048A8           3639              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1 or 4, MULS.L is invaid
00003C58                          3640  
00003C58  4EB9 00004B68           3641  Muls_L_xxxW JSR     PrintMuls
00003C5E  4EB9 00004BEC           3642              JSR     LengthL
00003C64  4EB9 00004C10           3643              JSR     PrintSpace
00003C6A  4EB9 000049AA           3644              JSR     PrintByteOrWord
00003C70                          3645  
00003C70  12EE 0025               3646              MOVE.B  37(A6),(A1)+             *,
00003C74                          3647  
00003C74  385C                    3648              MOVE.W  (A4)+,A4
00003C76  4EB9 00004928           3649              JSR     PrintAddr
00003C7C  4E75                    3650              RTS                     ; return to input to get more input
00003C7E                          3651  
00003C7E  4EB9 00004B68           3652  Muls_L_xxxL JSR     PrintMuls
00003C84  4EB9 00004BEC           3653              JSR     LengthL
00003C8A  4EB9 00004C10           3654              JSR     PrintSpace
00003C90  4EB9 000049C0           3655              JSR     PrintLong
00003C96                          3656  
00003C96  12EE 0025               3657              MOVE.B  37(A6),(A1)+             *,
00003C9A  385C                    3658              MOVE.W  (A4)+,A4
00003C9C  4EB9 00004928           3659              JSR     PrintAddr
00003CA2  4E75                    3660              RTS                     ; return to input to get more input
00003CA4                          3661  
00003CA4  4EB9 00004B68           3662  Muls_L_Data JSR PrintMuls
00003CAA  4EB9 00004BEC           3663              JSR LengthL
00003CB0  4EB9 00004C10           3664              JSR     PrintSpace
00003CB6  4EB9 0000499E           3665              JSR     PrintImmediateData
00003CBC                          3666  
00003CBC  12EE 0025               3667              MOVE.B  37(A6),(A1)+             *,
00003CC0  385C                    3668              MOVE.W  (A4)+,A4
00003CC2  4EB9 00004928           3669              JSR     PrintAddr
00003CC8  4E75                    3670              RTS                     ; return to input to get more input
00003CCA                          3671  
00003CCA                          3672  *************************************************                Divu_L                 *************************************************
00003CCA                          3673  ; first 10 bit is (0100 1100 01## ####)
00003CCA  7803                    3674  Divu_L      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003CCC  4EB9 000048B0           3675              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003CD2                          3676  
00003CD2  BABC 00000000           3677              CMP.L   #0,D5          ; if position 5-3 is 0 the EA for MULS.L is Dn mode 0
00003CD8  6700 0030               3678              BEQ     Divu_L_M0
00003CDC                          3679  
00003CDC  BABC 00000002           3680              CMP.L   #2,D5          ; if position 5-3 is 2 the EA for MULS.L is (An) mode 2
00003CE2  6700 0054               3681              BEQ     Divu_L_M2
00003CE6                          3682  
00003CE6  BABC 00000003           3683              CMP.L   #3,D5          ; if position 5-3 is 3 the EA for MULS.L is (An)+ mode 3
00003CEC  6700 0078               3684              BEQ     Divu_L_M3
00003CF0                          3685  
00003CF0  BABC 00000004           3686              CMP.L   #4,D5          ; if position 5-3 is 4 the EA for MULS.L is -(An) mode 4
00003CF6  6700 009C               3687              BEQ     Divu_L_M4
00003CFA                          3688  
00003CFA  BABC 00000007           3689              CMP.L   #7,D5          ; if position 5-3 is 7 the EA for MULS.L is mode 7
00003D00  6700 00C0               3690              BEQ     Divu_L_M7
00003D04                          3691  
00003D04  4EF9 000048A8           3692              JMP     InvalidOpcode  ; if it is not one of the moveM EA mode
00003D0A                          3693  
00003D0A  7803                    3694  Divu_L_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003D0C  4EB9 000048B0           3695              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003D12  4EB9 00004AEE           3696              JSR     PrintDivu
00003D18  4EB9 00004BEC           3697              JSR     LengthL
00003D1E  4EB9 00004C10           3698              JSR     PrintSpace
00003D24  4EB9 00004A2A           3699              JSR     PrintDataReg
00003D2A                          3700  
00003D2A  12EE 0025               3701              MOVE.B  37(A6),(A1)+             *,
00003D2E  385C                    3702              MOVE.W  (A4)+,A4
00003D30  4EB9 00004928           3703              JSR     PrintAddr
00003D36  4E75                    3704              RTS                     ; return to input to get more input
00003D38                          3705  
00003D38  7803                    3706  Divu_L_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003D3A  4EB9 000048B0           3707              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003D40  4EB9 00004AEE           3708              JSR     PrintDivu
00003D46  4EB9 00004BEC           3709              JSR     LengthL
00003D4C  4EB9 00004C10           3710              JSR     PrintSpace
00003D52  4EB9 00004A42           3711              JSR     PrintIndirAddrReg
00003D58                          3712  
00003D58  12EE 0025               3713              MOVE.B  37(A6),(A1)+             *,
00003D5C  385C                    3714              MOVE.W  (A4)+,A4
00003D5E  4EB9 00004928           3715              JSR     PrintAddr
00003D64  4E75                    3716              RTS                     ; return to input to get more input
00003D66                          3717  
00003D66  7803                    3718  Divu_L_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003D68  4EB9 000048B0           3719              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003D6E  4EB9 00004AEE           3720              JSR     PrintDivu
00003D74  4EB9 00004BEC           3721              JSR     LengthL
00003D7A  4EB9 00004C10           3722              JSR     PrintSpace
00003D80  4EB9 00004A50           3723              JSR     PrintPostIncAddrReg
00003D86                          3724  
00003D86  12EE 0025               3725              MOVE.B  37(A6),(A1)+             *,
00003D8A  385C                    3726              MOVE.W  (A4)+,A4
00003D8C  4EB9 00004928           3727              JSR     PrintAddr
00003D92  4E75                    3728              RTS                     ; return to input to get more input
00003D94                          3729  
00003D94  7803                    3730  Divu_L_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003D96  4EB9 000048B0           3731              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003D9C  4EB9 00004AEE           3732              JSR     PrintDivu
00003DA2  4EB9 00004BEC           3733              JSR     LengthL
00003DA8  4EB9 00004C10           3734              JSR     PrintSpace
00003DAE  4EB9 00004A5A           3735              JSR     PrintPreDeincAddrReg
00003DB4                          3736  
00003DB4  12EE 0025               3737              MOVE.B  37(A6),(A1)+             *,
00003DB8  385C                    3738              MOVE.W  (A4)+,A4
00003DBA  4EB9 00004928           3739              JSR     PrintAddr
00003DC0  4E75                    3740              RTS                     ; return to input to get more input
00003DC2                          3741  
00003DC2  7803                    3742  Divu_L_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003DC4  4EB9 000048B0           3743              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003DCA                          3744  
00003DCA  BABC 00000000           3745              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003DD0  6700 001C               3746              BEQ     Divu_L_xxxW
00003DD4                          3747  
00003DD4  BABC 00000001           3748              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003DDA  6700 0038               3749              BEQ     Divu_L_xxxL
00003DDE                          3750  
00003DDE  BABC 00000004           3751              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00003DE4  6700 0054               3752              BEQ     Divu_L_Data
00003DE8                          3753  
00003DE8  4EF9 000048A8           3754              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1 or 4, Divu.L is invaid
00003DEE                          3755  
00003DEE  4EB9 00004AEE           3756  Divu_L_xxxW JSR     PrintDivu
00003DF4  4EB9 00004BEC           3757              JSR     LengthL
00003DFA  4EB9 00004C10           3758              JSR     PrintSpace
00003E00  4EB9 000049AA           3759              JSR     PrintByteOrWord
00003E06                          3760  
00003E06  12EE 0025               3761              MOVE.B  37(A6),(A1)+             *,
00003E0A  385C                    3762              MOVE.W  (A4)+,A4
00003E0C  4EB9 00004928           3763              JSR     PrintAddr
00003E12  4E75                    3764              RTS                     ; return to input to get more input
00003E14                          3765  
00003E14  4EB9 00004AEE           3766  Divu_L_xxxL JSR     PrintDivu
00003E1A  4EB9 00004BEC           3767              JSR     LengthL
00003E20  4EB9 00004C10           3768              JSR     PrintSpace
00003E26  4EB9 000049C0           3769              JSR     PrintLong
00003E2C                          3770  
00003E2C  12EE 0025               3771              MOVE.B  37(A6),(A1)+             *,
00003E30  385C                    3772              MOVE.W  (A4)+,A4
00003E32  4EB9 00004928           3773              JSR     PrintAddr
00003E38  4E75                    3774              RTS                     ; return to input to get more input
00003E3A                          3775  
00003E3A  4EB9 00004AEE           3776  Divu_L_Data JSR     PrintDivu
00003E40  4EB9 00004BEC           3777              JSR     LengthL
00003E46  4EB9 00004C10           3778              JSR     PrintSpace
00003E4C  4EB9 0000499E           3779              JSR     PrintImmediateData
00003E52                          3780  
00003E52  12EE 0025               3781              MOVE.B  37(A6),(A1)+             *,
00003E56  385C                    3782              MOVE.W  (A4)+,A4
00003E58  4EB9 00004928           3783              JSR     PrintAddr
00003E5E  4E75                    3784              RTS                     ; return to input to get more input
00003E60                          3785  
00003E60                          3786  
00003E60                          3787  *************************************************                JSR_Opcode             *************************************************
00003E60                          3788  ; first 10 bit is (0100 1110 10## ####)
00003E60  7803                    3789  JSR_Opcode  MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003E62  4EB9 000048B0           3790              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003E68                          3791  
00003E68  BABC 00000002           3792              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An) mode 2
00003E6E  6700 0012               3793              BEQ     JSR_M2
00003E72                          3794  
00003E72  BABC 00000007           3795              CMP.L   #7,D5          ; if position 5-3 is 2 the EA is (An) mode 2
00003E78  6700 0024               3796              BEQ     JSR_M7
00003E7C                          3797  
00003E7C  4EF9 000048A8           3798              JMP     InvalidOpcode  ; if it is not a valid JSR EA mode if it is not 2 or 7
00003E82                          3799  
00003E82  7803                    3800  JSR_M2      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003E84  4EB9 000048B0           3801              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003E8A  4EB9 00004B00           3802              JSR     PrintJSR
00003E90  4EB9 00004C10           3803              JSR     PrintSpace
00003E96  4EB9 00004A42           3804              JSR     PrintIndirAddrReg
00003E9C  4E75                    3805              RTS                     ; return to input to get more input
00003E9E                          3806  
00003E9E  7803                    3807  JSR_M7      MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003EA0  4EB9 000048B0           3808              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003EA6                          3809  
00003EA6  BABC 00000000           3810              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003EAC  6700 0012               3811              BEQ     JSR_xxxW
00003EB0                          3812  
00003EB0  BABC 00000001           3813              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003EB6  6700 001C               3814              BEQ     JSR_xxxL
00003EBA                          3815  
00003EBA  4EF9 000048A8           3816              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid JSR EA mode
00003EC0                          3817  
00003EC0  4EB9 00004B00           3818  JSR_xxxW    JSR     PrintJSR
00003EC6  4EB9 00004C10           3819              JSR     PrintSpace
00003ECC  4EB9 000049AA           3820              JSR     PrintByteOrWord
00003ED2  4E75                    3821              RTS                     ; return to input to get more input
00003ED4                          3822  
00003ED4  4EB9 00004B00           3823  JSR_xxxL    JSR     PrintJSR
00003EDA  4EB9 00004C10           3824              JSR     PrintSpace
00003EE0  4EB9 000049C0           3825              JSR     PrintLong
00003EE6  4E75                    3826              RTS                     ; return to input to get more input
00003EE8                          3827  
00003EE8                          3828  
00003EE8                          3829  *************************************************                Not_B_Opcode           *************************************************
00003EE8                          3830  ; first 10 bit is (0100 0110 00## ####)
00003EE8                          3831  Not_B_Opcode
00003EE8  7803                    3832              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00003EEA  4EB9 000048B0           3833              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
00003EF0                          3834  
00003EF0  BABC 00000000           3835              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
00003EF6  6700 0030               3836              BEQ     Not_B_M0
00003EFA                          3837  
00003EFA  BABC 00000002           3838              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
00003F00  6700 0048               3839              BEQ     Not_B_M2
00003F04                          3840  
00003F04  BABC 00000003           3841              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00003F0A  6700 0060               3842              BEQ     Not_B_M3
00003F0E                          3843  
00003F0E  BABC 00000004           3844              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
00003F14  6700 0078               3845              BEQ     Not_B_M4
00003F18                          3846  
00003F18  BABC 00000007           3847              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode is 7
00003F1E  6700 0090               3848              BEQ     Not_B_M7
00003F22                          3849  
00003F22  4EF9 000048A8           3850              JMP     InvalidOpcode  ; if it is not a valid NOT EA mode if it is not 0 2 3 4 7
00003F28                          3851  
00003F28  7803                    3852  Not_B_M0    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003F2A  4EB9 000048B0           3853              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003F30  4EB9 00004B88           3854              JSR     PrintNot
00003F36  4EB9 00004BD8           3855              JSR     LengthB
00003F3C  4EB9 00004C10           3856              JSR     PrintSpace
00003F42  4EB9 00004A2A           3857              JSR     PrintDataReg
00003F48  4E75                    3858              RTS                     ; return to input to get more input
00003F4A                          3859  
00003F4A  7803                    3860  Not_B_M2    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003F4C  4EB9 000048B0           3861              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003F52  4EB9 00004B88           3862              JSR     PrintNot
00003F58  4EB9 00004BD8           3863              JSR     LengthB
00003F5E  4EB9 00004C10           3864              JSR     PrintSpace
00003F64  4EB9 00004A42           3865              JSR     PrintIndirAddrReg
00003F6A  4E75                    3866              RTS                     ; return to input to get more input
00003F6C                          3867  
00003F6C  7803                    3868  Not_B_M3    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003F6E  4EB9 000048B0           3869              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003F74  4EB9 00004B88           3870              JSR     PrintNot
00003F7A  4EB9 00004BD8           3871              JSR     LengthB
00003F80  4EB9 00004C10           3872              JSR     PrintSpace
00003F86  4EB9 00004A50           3873              JSR     PrintPostIncAddrReg
00003F8C  4E75                    3874              RTS                     ; return to input to get more input
00003F8E                          3875  
00003F8E  7803                    3876  Not_B_M4    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003F90  4EB9 000048B0           3877              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003F96  4EB9 00004B88           3878              JSR     PrintNot
00003F9C  4EB9 00004BD8           3879              JSR     LengthB
00003FA2  4EB9 00004C10           3880              JSR     PrintSpace
00003FA8  4EB9 00004A5A           3881              JSR     PrintPreDeincAddrReg
00003FAE  4E75                    3882              RTS                     ; return to input to get more input
00003FB0                          3883  
00003FB0  7803                    3884  Not_B_M7    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00003FB2  4EB9 000048B0           3885              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00003FB8                          3886  
00003FB8  BABC 00000000           3887              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00003FBE  6700 0012               3888              BEQ     Not_B_xxxW
00003FC2                          3889  
00003FC2  BABC 00000001           3890              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00003FC8  6700 0022               3891              BEQ     Not_B_xxxL
00003FCC                          3892  
00003FCC  4EF9 000048A8           3893              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid NOT EA mode
00003FD2                          3894  
00003FD2  4EB9 00004B88           3895  Not_B_xxxW  JSR     PrintNot
00003FD8  4EB9 00004BD8           3896              JSR     LengthB
00003FDE  4EB9 00004C10           3897              JSR     PrintSpace
00003FE4  4EB9 000049AA           3898              JSR     PrintByteOrWord
00003FEA  4E75                    3899              RTS                     ; return to input to get more input
00003FEC                          3900  
00003FEC  4EB9 00004B88           3901  Not_B_xxxL  JSR     PrintNot
00003FF2  4EB9 00004BD8           3902              JSR     LengthB
00003FF8  4EB9 00004C10           3903              JSR     PrintSpace
00003FFE  4EB9 000049C0           3904              JSR     PrintLong
00004004  4E75                    3905              RTS                     ; return to input to get more input
00004006                          3906  
00004006                          3907  
00004006                          3908  *************************************************                Not_W_Opcode           *************************************************
00004006                          3909  ; first 10 bit is (0100 0110 01## ####)
00004006                          3910  Not_W_Opcode
00004006  7803                    3911              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00004008  4EB9 000048B0           3912              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
0000400E                          3913  
0000400E  BABC 00000000           3914              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
00004014  6700 0030               3915              BEQ     Not_W_M0
00004018                          3916  
00004018  BABC 00000002           3917              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
0000401E  6700 0048               3918              BEQ     Not_W_M2
00004022                          3919  
00004022  BABC 00000003           3920              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00004028  6700 0060               3921              BEQ     Not_W_M3
0000402C                          3922  
0000402C  BABC 00000004           3923              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
00004032  6700 0078               3924              BEQ     Not_W_M4
00004036                          3925  
00004036  BABC 00000007           3926              CMP.L   #7,D5          ; if position 5-3 is 7 the EA mode is 7
0000403C  6700 0090               3927              BEQ     Not_W_M7
00004040                          3928  
00004040  4EF9 000048A8           3929              JMP     InvalidOpcode  ; if it is not a valid NOT EA mode if it is not 0 2 3 4 7
00004046                          3930  
00004046  7803                    3931  Not_W_M0    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004048  4EB9 000048B0           3932              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000404E  4EB9 00004B88           3933              JSR     PrintNot
00004054  4EB9 00004BE2           3934              JSR     LengthW
0000405A  4EB9 00004C10           3935              JSR     PrintSpace
00004060  4EB9 00004A2A           3936              JSR     PrintDataReg
00004066  4E75                    3937              RTS                     ; return to input to get more input
00004068                          3938  
00004068  7803                    3939  Not_W_M2    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000406A  4EB9 000048B0           3940              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004070  4EB9 00004B88           3941              JSR     PrintNot
00004076  4EB9 00004BE2           3942              JSR     LengthW
0000407C  4EB9 00004C10           3943              JSR     PrintSpace
00004082  4EB9 00004A42           3944              JSR     PrintIndirAddrReg
00004088  4E75                    3945              RTS                     ; return to input to get more input
0000408A                          3946  
0000408A  7803                    3947  Not_W_M3    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000408C  4EB9 000048B0           3948              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
00004092  4EB9 00004B88           3949              JSR     PrintNot
00004098  4EB9 00004BE2           3950              JSR     LengthW
0000409E  4EB9 00004C10           3951              JSR     PrintSpace
000040A4  4EB9 00004A50           3952              JSR     PrintPostIncAddrReg
000040AA  4E75                    3953              RTS                     ; return to input to get more input
000040AC                          3954  
000040AC  7803                    3955  Not_W_M4    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000040AE  4EB9 000048B0           3956              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000040B4  4EB9 00004B88           3957              JSR     PrintNot
000040BA  4EB9 00004BE2           3958              JSR     LengthW
000040C0  4EB9 00004C10           3959              JSR     PrintSpace
000040C6  4EB9 00004A5A           3960              JSR     PrintPreDeincAddrReg
000040CC  4E75                    3961              RTS                     ; return to input to get more input
000040CE                          3962  
000040CE  7803                    3963  Not_W_M7    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000040D0  4EB9 000048B0           3964              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000040D6                          3965  
000040D6  BABC 00000000           3966              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
000040DC  6700 0012               3967              BEQ     Not_W_xxxW
000040E0                          3968  
000040E0  BABC 00000001           3969              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
000040E6  6700 0022               3970              BEQ     Not_W_xxxL
000040EA                          3971  
000040EA  4EF9 000048A8           3972              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid NOT EA mode
000040F0                          3973  
000040F0  4EB9 00004B88           3974  Not_W_xxxW  JSR     PrintNot
000040F6  4EB9 00004BE2           3975              JSR     LengthW
000040FC  4EB9 00004C10           3976              JSR     PrintSpace
00004102  4EB9 000049AA           3977              JSR     PrintByteOrWord
00004108  4E75                    3978              RTS                     ; return to input to get more input
0000410A                          3979  
0000410A  4EB9 00004B88           3980  Not_W_xxxL  JSR     PrintNot
00004110  4EB9 00004BE2           3981              JSR     LengthW
00004116  4EB9 00004C10           3982              JSR     PrintSpace
0000411C  4EB9 000049C0           3983              JSR     PrintLong
00004122  4E75                    3984              RTS                     ; return to input to get more input
00004124                          3985  
00004124                          3986  
00004124                          3987  *************************************************                Not_L_Opcode           *************************************************
00004124                          3988  ; first 10 bit is (0100 0110 10## ####)
00004124                          3989  Not_L_Opcode
00004124  7803                    3990              MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 5-3) in to D5
00004126  4EB9 000048B0           3991              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the EA mode
0000412C                          3992  
0000412C  BABC 00000000           3993              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
00004132  6700 0030               3994              BEQ     Not_L_M0
00004136                          3995  
00004136  BABC 00000002           3996              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
0000413C  6700 0048               3997              BEQ     Not_L_M2
00004140                          3998  
00004140  BABC 00000003           3999              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00004146  6700 0060               4000              BEQ     Not_L_M3
0000414A                          4001  
0000414A  BABC 00000004           4002              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
00004150  6700 0078               4003              BEQ     Not_L_M4
00004154                          4004  
00004154  BABC 00000007           4005              CMP.L   #7,D5          ; if position 5-3 is 7 the EA mode is 7
0000415A  6700 0090               4006              BEQ     Not_L_M7
0000415E                          4007  
0000415E  4EF9 000048A8           4008              JMP     InvalidOpcode  ; if it is not a valid NOT EA mode if it is not 0 2 3 4 7
00004164                          4009  
00004164  7803                    4010  Not_L_M0    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004166  4EB9 000048B0           4011              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000416C  4EB9 00004B88           4012              JSR     PrintNot
00004172  4EB9 00004BEC           4013              JSR     LengthL
00004178  4EB9 00004C10           4014              JSR     PrintSpace
0000417E  4EB9 00004A2A           4015              JSR     PrintDataReg
00004184  4E75                    4016              RTS                     ; return to input to get more input
00004186                          4017  
00004186  7803                    4018  Not_L_M2    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004188  4EB9 000048B0           4019              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
0000418E  4EB9 00004B88           4020              JSR     PrintNot
00004194  4EB9 00004BEC           4021              JSR     LengthL
0000419A  4EB9 00004C10           4022              JSR     PrintSpace
000041A0  4EB9 00004A42           4023              JSR     PrintIndirAddrReg
000041A6  4E75                    4024              RTS                     ; return to input to get more input
000041A8                          4025  
000041A8  7803                    4026  Not_L_M3    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000041AA  4EB9 000048B0           4027              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000041B0  4EB9 00004B88           4028              JSR     PrintNot
000041B6  4EB9 00004BEC           4029              JSR     LengthL
000041BC  4EB9 00004C10           4030              JSR     PrintSpace
000041C2  4EB9 00004A50           4031              JSR     PrintPostIncAddrReg
000041C8  4E75                    4032              RTS                     ; return to input to get more input
000041CA                          4033  
000041CA  7803                    4034  Not_L_M4    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000041CC  4EB9 000048B0           4035              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000041D2  4EB9 00004B88           4036              JSR     PrintNot
000041D8  4EB9 00004BEC           4037              JSR     LengthL
000041DE  4EB9 00004C10           4038              JSR     PrintSpace
000041E4  4EB9 00004A5A           4039              JSR     PrintPreDeincAddrReg
000041EA  4E75                    4040              RTS                     ; return to input to get more input
000041EC                          4041  
000041EC  7803                    4042  Not_L_M7    MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000041EE  4EB9 000048B0           4043              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the register
000041F4                          4044  
000041F4  BABC 00000000           4045              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
000041FA  6700 0012               4046              BEQ     Not_L_xxxW
000041FE                          4047  
000041FE  BABC 00000001           4048              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
00004204  6700 0022               4049              BEQ     Not_L_xxxL
00004208                          4050  
00004208  4EF9 000048A8           4051              JMP     InvalidOpcode  ; for mode 7 if register is not 0 or 1, it is not a vaid NOT EA mode
0000420E                          4052  
0000420E  4EB9 00004B88           4053  Not_L_xxxW  JSR     PrintNot
00004214  4EB9 00004BEC           4054              JSR     LengthL
0000421A  4EB9 00004C10           4055              JSR     PrintSpace
00004220  4EB9 000049AA           4056              JSR     PrintByteOrWord
00004226  4E75                    4057              RTS                     ; return to input to get more input
00004228                          4058  
00004228  4EB9 00004B88           4059  Not_L_xxxL  JSR     PrintNot
0000422E  4EB9 00004BEC           4060              JSR     LengthL
00004234  4EB9 00004C10           4061              JSR     PrintSpace
0000423A  4EB9 000049C0           4062              JSR     PrintLong
00004240  4E75                    4063              RTS                     ; return to input to get more input
00004242                          4064  
00004242                          4065  
00004242                          4066  *************************************************                MOVE_W_Opcode          *************************************************
00004242                          4067  ; first four bit is (0011 #### #### ####)
00004242                          4068  MOVE_W_Opcode
00004242  7803                    4069              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
00004244  4EB9 000048B0           4070              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination register
0000424A                          4071  
0000424A  2005                    4072              MOVE.L  D5,D0               ; D0 will hold the destination register
0000424C                          4073          ; D0 will hold the destination register (position 11-9)
0000424C                          4074  
0000424C  7803                    4075              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
0000424E  4EB9 000048B0           4076              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination mode
00004254                          4077  
00004254  BABC 00000001           4078              CMP.L   #1,D5               ; destination mode can't be mode one
0000425A  6700 064C               4079              BEQ     InvalidOpcode
0000425E                          4080  
0000425E  BABC 00000005           4081              CMP.L   #5,D5               ; destination mode can't be mode 5
00004264  6700 0642               4082              BEQ     InvalidOpcode
00004268                          4083  
00004268  BABC 00000006           4084              CMP.L   #6,D5               ; destination mode can't be mode 6
0000426E  6700 0638               4085              BEQ     InvalidOpcode
00004272                          4086  
00004272  BABC 00000007           4087              CMP.L   #7,D5               ; if destination mode is 7, we need to check the register. the lable is in
00004278  6700 0048               4088              BEQ     MOVE_W_DesM7_Check
0000427C                          4089  
0000427C                          4090  Continue_MOVE_W
0000427C  2205                    4091              MOVE.L  D5,D1               ; D1 will hold the destination mode
0000427E                          4092          ; D1 will hold the destination mode (position 8-6)
0000427E                          4093  
0000427E  7803                    4094              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00004280  4EB9 000048B0           4095              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the source mode
00004286                          4096  
00004286  BABC 00000000           4097              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
0000428C  6700 0040               4098              BEQ     MOVE_W_M0
00004290                          4099  
00004290  BABC 00000001           4100              CMP.L   #1,D5          ; if position 5-3 is 1 the EA is An
00004296  6700 0062               4101              BEQ     MOVE_W_M1
0000429A                          4102  
0000429A  BABC 00000002           4103              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
000042A0  6700 0084               4104              BEQ     MOVE_W_M2
000042A4                          4105  
000042A4  BABC 00000003           4106              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
000042AA  6700 00A6               4107              BEQ     MOVE_W_M3
000042AE                          4108  
000042AE  BABC 00000004           4109              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
000042B4  6700 00C8               4110              BEQ     MOVE_W_M4
000042B8                          4111  
000042B8  BABC 00000007           4112              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode 7
000042BE  6700 0176               4113              BEQ     MOVE_W_M7
000042C2                          4114  
000042C2                          4115  MOVE_W_DesM7_Check
000042C2  B0BC 00000001           4116              CMP.L   #1,D0               ; if destination mode is 7, and register is bigger than 1 it is invalid
000042C8  6E00 05DE               4117              BGT     InvalidOpcode
000042CC                          4118  
000042CC  60AE                    4119              BRA     Continue_MOVE_W     ; if it is good then continue to decode move
000042CE                          4120  
000042CE  7803                    4121  MOVE_W_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000042D0  4EB9 000048B0           4122              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000042D6  4EB9 00004B38           4123              JSR     PrintMove
000042DC  4EB9 00004BE2           4124              JSR     LengthW
000042E2  4EB9 00004C10           4125              JSR     PrintSpace
000042E8  4EB9 00004A2A           4126              JSR     PrintDataReg
000042EE                          4127  
000042EE  12EE 0025               4128              MOVE.B  37(A6),(A1)+             *,
000042F2  4EB9 000043AA           4129              JSR CheckDest
000042F8  4E75                    4130              RTS                     ; return to input to get more input
000042FA                          4131  
000042FA  7803                    4132  MOVE_W_M1   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000042FC  4EB9 000048B0           4133              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004302  4EB9 00004B38           4134              JSR     PrintMove
00004308  4EB9 00004BE2           4135              JSR     LengthW
0000430E  4EB9 00004C10           4136              JSR     PrintSpace
00004314  4EB9 00004A36           4137              JSR     PrintAddrReg
0000431A                          4138  
0000431A  12EE 0025               4139              MOVE.B  37(A6),(A1)+             *,
0000431E  4EB9 000043AA           4140              JSR CheckDest
00004324  4E75                    4141              RTS                     ; return to input to get more input
00004326                          4142  
00004326  7803                    4143  MOVE_W_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004328  4EB9 000048B0           4144              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000432E  4EB9 00004B38           4145              JSR     PrintMove
00004334  4EB9 00004BE2           4146              JSR     LengthW
0000433A  4EB9 00004C10           4147              JSR     PrintSpace
00004340  4EB9 00004A42           4148              JSR     PrintIndirAddrReg
00004346                          4149  
00004346  12EE 0025               4150              MOVE.B  37(A6),(A1)+             *,
0000434A  4EB9 000043AA           4151              JSR CheckDest
00004350  4E75                    4152              RTS                     ; return to input to get more input
00004352                          4153  
00004352  7803                    4154  MOVE_W_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004354  4EB9 000048B0           4155              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000435A  4EB9 00004B38           4156              JSR     PrintMove
00004360  4EB9 00004BE2           4157              JSR     LengthW
00004366  4EB9 00004C10           4158              JSR     PrintSpace
0000436C  4EB9 00004A50           4159              JSR     PrintPostIncAddrReg
00004372                          4160  
00004372  12EE 0025               4161              MOVE.B  37(A6),(A1)+             *,
00004376  4EB9 000043AA           4162              JSR CheckDest
0000437C  4E75                    4163              RTS                     ; return to input to get more input
0000437E                          4164  
0000437E  7803                    4165  MOVE_W_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004380  4EB9 000048B0           4166              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004386  4EB9 00004B38           4167              JSR     PrintMove
0000438C  4EB9 00004BE2           4168              JSR     LengthW
00004392  4EB9 00004C10           4169              JSR     PrintSpace
00004398  4EB9 00004A5A           4170              JSR     PrintPreDeincAddrReg
0000439E                          4171  
0000439E  12EE 0025               4172              MOVE.B  37(A6),(A1)+             *,
000043A2  4EB9 000043AA           4173              JSR CheckDest
000043A8  4E75                    4174              RTS                     ; return to input to get more input
000043AA                          4175  
000043AA                          4176  CheckDest
000043AA  B2BC 00000000           4177              CMP.L   #0,D1          ; if position 5-3 is 0 the EA is Dn
000043B0  6700 0036               4178              BEQ     DestDn
000043B4                          4179  
000043B4  B2BC 00000001           4180              CMP.L   #1,D1          ; if position 5-3 is 1 the EA is An
000043BA  6700 04EC               4181              BEQ     InvalidOpcode
000043BE                          4182  
000043BE  B2BC 00000002           4183              CMP.L   #2,D1          ; if position 5-3 is 2 the EA is (An)
000043C4  6700 002C               4184              BEQ     DestIndirAn
000043C8                          4185  
000043C8  B2BC 00000003           4186              CMP.L   #3,D1          ; if position 5-3 is 3 the EA is (An)+
000043CE  6700 002C               4187              BEQ     DestPostIncAn
000043D2                          4188  
000043D2  B2BC 00000004           4189              CMP.L   #4,D1          ; if position 5-3 is 4 the EA is -(An)
000043D8  6700 002C               4190              BEQ     DestPreDeincAn
000043DC                          4191  
000043DC  B2BC 00000007           4192              CMP.L   #7,D1          ; if position 5-3 is 7 the EA is mode 7
000043E2  6700 002C               4193              BEQ     DestWL
000043E6  4E75                    4194              RTS
000043E8                          4195  
000043E8                          4196  DestDn
000043E8  1A00                    4197              MOVE.B  D0,D5
000043EA  4EB9 00004A2A           4198              JSR     PrintDataReg
000043F0  4E75                    4199              RTS
000043F2                          4200  
000043F2                          4201  DestIndirAn
000043F2  1A00                    4202              MOVE.B  D0,D5
000043F4  4EB9 00004A42           4203              JSR     PrintIndirAddrReg
000043FA  4E75                    4204              RTS
000043FC                          4205  
000043FC                          4206  DestPostIncAn
000043FC  1A00                    4207              MOVE.B  D0,D5
000043FE  4EB9 00004A50           4208              JSR     PrintPostIncAddrReg
00004404  4E75                    4209              RTS
00004406                          4210  
00004406                          4211  DestPreDeincAn
00004406  1A00                    4212              MOVE.B  D0,D5
00004408  4EB9 00004A5A           4213              JSR     PrintPreDeincAddrReg
0000440E  4E75                    4214              RTS
00004410                          4215  
00004410                          4216  DestWL
00004410  B0BC 00000000           4217              CMP.L   #0,D0
00004416  6700 000E               4218              BEQ     DestW
0000441A                          4219  
0000441A  B0BC 00000001           4220              CMP.L   #1,D0
00004420  6700 000C               4221              BEQ     DestL
00004424                          4222  
00004424  4E75                    4223              RTS
00004426                          4224  
00004426                          4225  DestW
00004426  4EB9 000049AA           4226              JSR     PrintByteOrWord
0000442C  4E75                    4227              RTS
0000442E                          4228  
0000442E                          4229  DestL
0000442E  4EB9 000049C0           4230              JSR     PrintLong
00004434  4E75                    4231              RTS
00004436                          4232  
00004436  7803                    4233  MOVE_W_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004438  4EB9 000048B0           4234              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000443E                          4235  
0000443E  BABC 00000000           4236              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00004444  6700 001C               4237              BEQ     MOVE_W_xxxW
00004448                          4238  
00004448  BABC 00000001           4239              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
0000444E  6700 0034               4240              BEQ     MOVE_W_xxxL
00004452                          4241  
00004452  BABC 00000004           4242              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00004458  6700 004C               4243              BEQ     MOVE_W_data
0000445C                          4244  
0000445C  4EF9 000048A8           4245              JMP     InvalidOpcode  ; for mode 7 if Source register is not 0 or 1 or 4, it is not a vaid NOT EA mode
00004462                          4246  
00004462  4EB9 00004B38           4247  MOVE_W_xxxW JSR     PrintMove
00004468  4EB9 00004BE2           4248              JSR     LengthW
0000446E  4EB9 00004C10           4249              JSR     PrintSpace
00004474  4EB9 000049AA           4250              JSR     PrintByteOrWord
0000447A                          4251  
0000447A  12EE 0025               4252              MOVE.B  37(A6),(A1)+             *,
0000447E  4EB8 43AA               4253              JSR CheckDest
00004482  4E75                    4254              RTS                     ; return to input to get more input
00004484                          4255  
00004484  4EB9 00004B38           4256  MOVE_W_xxxL JSR     PrintMove
0000448A  4EB9 00004BE2           4257              JSR     LengthW
00004490  4EB9 00004C10           4258              JSR     PrintSpace
00004496  4EB9 000049C0           4259              JSR     PrintLong
0000449C                          4260  
0000449C  12EE 0025               4261              MOVE.B  37(A6),(A1)+             *,
000044A0  4EB8 43AA               4262              JSR CheckDest
000044A4  4E75                    4263              RTS                     ; return to input to get more input
000044A6                          4264  
000044A6  4EB9 00004B38           4265  MOVE_W_data JSR     PrintMove
000044AC  4EB9 00004BE2           4266              JSR     LengthW
000044B2  4EB9 00004C10           4267              JSR     PrintSpace
000044B8  4EB9 0000499E           4268              JSR     PrintImmediateData
000044BE                          4269  
000044BE  12EE 0025               4270              MOVE.B  37(A6),(A1)+             *,
000044C2  4EB8 43AA               4271              JSR CheckDest
000044C6  4E75                    4272              RTS                     ; return to input to get more input
000044C8                          4273  
000044C8                          4274  *************************************************                MOVE_L_Opcode          *************************************************
000044C8                          4275  ; first four bit is (0010 #### #### ####)
000044C8                          4276  MOVE_L_Opcode
000044C8  7803                    4277              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
000044CA  4EB9 000048B0           4278              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination register
000044D0                          4279  
000044D0  2005                    4280              MOVE.L  D5,D0               ; D0 will hold the destination register
000044D2                          4281          ; D0 will hold the destination register (position 11-9)
000044D2                          4282  
000044D2  7803                    4283              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
000044D4  4EB9 000048B0           4284              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination mode
000044DA                          4285  
000044DA  BABC 00000001           4286              CMP.L   #1,D5               ; destination mode can't be mode one
000044E0  6700 03C6               4287              BEQ     InvalidOpcode
000044E4                          4288  
000044E4  BABC 00000005           4289              CMP.L   #5,D5               ; destination mode can't be mode 5
000044EA  6700 03BC               4290              BEQ     InvalidOpcode
000044EE                          4291  
000044EE  BABC 00000006           4292              CMP.L   #6,D5               ; destination mode can't be mode 6
000044F4  6700 03B2               4293              BEQ     InvalidOpcode
000044F8                          4294  
000044F8  BABC 00000007           4295              CMP.L   #7,D5               ; if destination mode is 7, we need to check the register. the lable is in
000044FE  6700 0048               4296              BEQ     MOVE_L_DesM7_Check
00004502                          4297  
00004502                          4298  Continue_MOVE_L
00004502  2205                    4299              MOVE.L  D5,D1               ; D1 will hold the destination mode
00004504                          4300          ; D1 will hold the destination mode (position 8-6)
00004504                          4301  
00004504  7803                    4302              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
00004506  4EB9 000048B0           4303              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the source mode
0000450C                          4304  
0000450C  BABC 00000000           4305              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
00004512  6700 0040               4306              BEQ     MOVE_L_M0
00004516                          4307  
00004516  BABC 00000001           4308              CMP.L   #1,D5          ; if position 5-3 is 1 the EA is An
0000451C  6700 0060               4309              BEQ     MOVE_L_M1
00004520                          4310  
00004520  BABC 00000002           4311              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
00004526  6700 0080               4312              BEQ     MOVE_L_M2
0000452A                          4313  
0000452A  BABC 00000003           4314              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00004530  6700 00A0               4315              BEQ     MOVE_L_M3
00004534                          4316  
00004534  BABC 00000004           4317              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
0000453A  6700 00C0               4318              BEQ     MOVE_L_M4
0000453E                          4319  
0000453E  BABC 00000007           4320              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode 7
00004544  6700 00E0               4321              BEQ     MOVE_L_M7
00004548                          4322  
00004548                          4323  MOVE_L_DesM7_Check
00004548  B0BC 00000001           4324              CMP.L   #1,D0               ; if destination mode is 7, and register is bigger than 1 it is invalid
0000454E  6E00 0358               4325              BGT     InvalidOpcode
00004552                          4326  
00004552  60AE                    4327              BRA     Continue_MOVE_L     ; if it is good then continue to decode move
00004554                          4328  
00004554  7803                    4329  MOVE_L_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004556  4EB9 000048B0           4330              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000455C  4EB9 00004B38           4331              JSR     PrintMove
00004562  4EB9 00004BEC           4332              JSR     LengthL
00004568  4EB9 00004C10           4333              JSR     PrintSpace
0000456E  4EB9 00004A2A           4334              JSR     PrintDataReg
00004574                          4335  
00004574  12EE 0025               4336              MOVE.B  37(A6),(A1)+             *,
00004578  4EB8 43AA               4337              JSR CheckDest
0000457C  4E75                    4338              RTS                     ; return to input to get more input
0000457E                          4339  
0000457E  7803                    4340  MOVE_L_M1   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004580  4EB9 000048B0           4341              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004586  4EB9 00004B38           4342              JSR     PrintMove
0000458C  4EB9 00004BEC           4343              JSR     LengthL
00004592  4EB9 00004C10           4344              JSR     PrintSpace
00004598  4EB9 00004A36           4345              JSR     PrintAddrReg
0000459E                          4346  
0000459E  12EE 0025               4347              MOVE.B  37(A6),(A1)+             *,
000045A2  4EB8 43AA               4348              JSR CheckDest
000045A6  4E75                    4349              RTS                     ; return to input to get more input
000045A8                          4350  
000045A8  7803                    4351  MOVE_L_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000045AA  4EB9 000048B0           4352              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000045B0  4EB9 00004B38           4353              JSR     PrintMove
000045B6  4EB9 00004BEC           4354              JSR     LengthL
000045BC  4EB9 00004C10           4355              JSR     PrintSpace
000045C2  4EB9 00004A42           4356              JSR     PrintIndirAddrReg
000045C8                          4357  
000045C8  12EE 0025               4358              MOVE.B  37(A6),(A1)+             *,
000045CC  4EB8 43AA               4359              JSR CheckDest
000045D0  4E75                    4360              RTS                     ; return to input to get more input
000045D2                          4361  
000045D2  7803                    4362  MOVE_L_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000045D4  4EB9 000048B0           4363              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000045DA  4EB9 00004B38           4364              JSR     PrintMove
000045E0  4EB9 00004BEC           4365              JSR     LengthL
000045E6  4EB9 00004C10           4366              JSR     PrintSpace
000045EC  4EB9 00004A50           4367              JSR     PrintPostIncAddrReg
000045F2                          4368  
000045F2  12EE 0025               4369              MOVE.B  37(A6),(A1)+             *,
000045F6  4EB8 43AA               4370              JSR CheckDest
000045FA  4E75                    4371              RTS                     ; return to input to get more input
000045FC                          4372  
000045FC  7803                    4373  MOVE_L_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000045FE  4EB9 000048B0           4374              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004604  4EB9 00004B38           4375              JSR     PrintMove
0000460A  4EB9 00004BEC           4376              JSR     LengthL
00004610  4EB9 00004C10           4377              JSR     PrintSpace
00004616  4EB9 00004A5A           4378              JSR     PrintPreDeincAddrReg
0000461C                          4379  
0000461C  12EE 0025               4380              MOVE.B  37(A6),(A1)+             *,
00004620  4EB8 43AA               4381              JSR CheckDest
00004624  4E75                    4382              RTS                     ; return to input to get more input
00004626                          4383  
00004626  7803                    4384  MOVE_L_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004628  4EB9 000048B0           4385              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000462E                          4386  
0000462E  BABC 00000000           4387              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00004634  6700 001C               4388              BEQ     MOVE_L_xxxW
00004638                          4389  
00004638  BABC 00000001           4390              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
0000463E  6700 0034               4391              BEQ     MOVE_L_xxxL
00004642                          4392  
00004642  BABC 00000004           4393              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00004648  6700 004C               4394              BEQ     MOVE_L_data
0000464C                          4395  
0000464C  4EF9 000048A8           4396              JMP     InvalidOpcode  ; for mode 7 if Source register is not 0 or 1 or 4, it is not a vaid NOT EA mode
00004652                          4397  
00004652  4EB9 00004B38           4398  MOVE_L_xxxW JSR PrintMove
00004658  4EB9 00004BEC           4399              JSR LengthL
0000465E  4EB9 00004C10           4400              JSR     PrintSpace
00004664  4EB9 000049AA           4401              JSR     PrintByteOrWord
0000466A                          4402  
0000466A  12EE 0025               4403              MOVE.B  37(A6),(A1)+             *,
0000466E  4EB8 43AA               4404              JSR CheckDest
00004672  4E75                    4405              RTS                     ; return to input to get more input
00004674                          4406  
00004674  4EB9 00004B38           4407  MOVE_L_xxxL JSR     PrintMove
0000467A  4EB9 00004BEC           4408              JSR     LengthL
00004680  4EB9 00004C10           4409              JSR     PrintSpace
00004686  4EB9 000049C0           4410              JSR     PrintLong
0000468C                          4411  
0000468C  12EE 0025               4412              MOVE.B  37(A6),(A1)+             *,
00004690  4EB8 43AA               4413              JSR CheckDest
00004694  4E75                    4414              RTS                     ; return to input to get more input
00004696                          4415  
00004696  4EB9 00004B38           4416  MOVE_L_data JSR     PrintMove
0000469C  4EB9 00004BEC           4417              JSR     LengthL
000046A2  4EB9 00004C10           4418              JSR     PrintSpace
000046A8  4EB9 0000499E           4419              JSR     PrintImmediateData
000046AE                          4420  
000046AE  12EE 0025               4421              MOVE.B  37(A6),(A1)+             *,
000046B2  4EB8 43AA               4422              JSR CheckDest
000046B6  4E75                    4423              RTS                     ; return to input to get more input
000046B8                          4424  
000046B8                          4425  
000046B8                          4426  *************************************************                MOVE_B_Opcode          *************************************************
000046B8                          4427  ; first four bit is (0001 #### #### ####)
000046B8                          4428  MOVE_B_Opcode
000046B8  7803                    4429              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 11-9) in to D5
000046BA  4EB9 000048B0           4430              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination register
000046C0                          4431  
000046C0  2005                    4432              MOVE.L  D5,D0               ; D0 will hold the destination register
000046C2                          4433          ; D0 will hold the destination register (position 11-9)
000046C2                          4434  
000046C2  7803                    4435              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 8-6) in to D5
000046C4  4EB9 000048B0           4436              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the destination mode
000046CA                          4437  
000046CA  BABC 00000001           4438              CMP.L   #1,D5               ; destination mode can't be mode one
000046D0  6700 01D6               4439              BEQ     InvalidOpcode
000046D4                          4440  
000046D4  BABC 00000005           4441              CMP.L   #5,D5               ; destination mode can't be mode 5
000046DA  6700 01CC               4442              BEQ     InvalidOpcode
000046DE                          4443  
000046DE  BABC 00000006           4444              CMP.L   #6,D5               ; destination mode can't be mode 6
000046E4  6700 01C2               4445              BEQ     InvalidOpcode
000046E8                          4446  
000046E8  BABC 00000007           4447              CMP.L   #7,D5               ; if destination mode is 7, we need to check the register. the lable is in
000046EE  6700 0048               4448              BEQ     MOVE_B_DesM7_Check
000046F2                          4449  
000046F2                          4450  Continue_MOVE_B
000046F2  2205                    4451              MOVE.L  D5,D1               ; D1 will hold the destination mode
000046F4                          4452          ; D1 will hold the destination mode (position 8-6)
000046F4                          4453  
000046F4  7803                    4454              MOVE.L  #3,D4               ; get the next 3 bit from (A4)(position 5-3) in to D5
000046F6  4EB9 000048B0           4455              JSR     GetNextD4bit        ; D5 hold the next 3 bit of (A4), which tell us the source mode
000046FC                          4456  
000046FC  BABC 00000000           4457              CMP.L   #0,D5          ; if position 5-3 is 0 the EA is Dn
00004702  6700 0040               4458              BEQ     MOVE_B_M0
00004706                          4459  
00004706  BABC 00000001           4460              CMP.L   #1,D5          ; if position 5-3 is 1 the EA is An
0000470C  6700 0060               4461              BEQ     MOVE_B_M1
00004710                          4462  
00004710  BABC 00000002           4463              CMP.L   #2,D5          ; if position 5-3 is 2 the EA is (An)
00004716  6700 0080               4464              BEQ     MOVE_B_M2
0000471A                          4465  
0000471A  BABC 00000003           4466              CMP.L   #3,D5          ; if position 5-3 is 3 the EA is (An)+
00004720  6700 00A0               4467              BEQ     MOVE_B_M3
00004724                          4468  
00004724  BABC 00000004           4469              CMP.L   #4,D5          ; if position 5-3 is 4 the EA is -(An)
0000472A  6700 00C0               4470              BEQ     MOVE_B_M4
0000472E                          4471  
0000472E  BABC 00000007           4472              CMP.L   #7,D5          ; if position 5-3 is 7 the EA is mode 7
00004734  6700 00E0               4473              BEQ     MOVE_B_M7
00004738                          4474  
00004738                          4475  MOVE_B_DesM7_Check
00004738  B0BC 00000001           4476              CMP.L   #1,D0               ; if destination mode is 7, and register is bigger than 1 it is invalid
0000473E  6E00 0168               4477              BGT     InvalidOpcode
00004742                          4478  
00004742  60AE                    4479              BRA     Continue_MOVE_B     ; if it is good then continue to decode move
00004744                          4480  
00004744  7803                    4481  MOVE_B_M0   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004746  4EB9 000048B0           4482              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000474C  4EB9 00004B38           4483              JSR     PrintMove
00004752  4EB9 00004BD8           4484              JSR     LengthB
00004758  4EB9 00004C10           4485              JSR     PrintSpace
0000475E  4EB9 00004A2A           4486              JSR     PrintDataReg
00004764                          4487  
00004764  12EE 0025               4488              MOVE.B  37(A6),(A1)+             *,
00004768  4EB8 43AA               4489              JSR CheckDest
0000476C  4E75                    4490              RTS                     ; return to input to get more input
0000476E                          4491  
0000476E  7803                    4492  MOVE_B_M1   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004770  4EB9 000048B0           4493              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
00004776  4EB9 00004B38           4494              JSR     PrintMove
0000477C  4EB9 00004BD8           4495              JSR     LengthB
00004782  4EB9 00004C10           4496              JSR     PrintSpace
00004788  4EB9 00004A36           4497              JSR     PrintAddrReg
0000478E                          4498  
0000478E  12EE 0025               4499              MOVE.B  37(A6),(A1)+             *,
00004792  4EB8 43AA               4500              JSR CheckDest
00004796  4E75                    4501              RTS                     ; return to input to get more input
00004798                          4502  
00004798  7803                    4503  MOVE_B_M2   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
0000479A  4EB9 000048B0           4504              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000047A0  4EB9 00004B38           4505              JSR     PrintMove
000047A6  4EB9 00004BD8           4506              JSR     LengthB
000047AC  4EB9 00004C10           4507              JSR     PrintSpace
000047B2  4EB9 00004A42           4508              JSR     PrintIndirAddrReg
000047B8                          4509  
000047B8  12EE 0025               4510              MOVE.B  37(A6),(A1)+             *,
000047BC  4EB8 43AA               4511              JSR CheckDest
000047C0  4E75                    4512              RTS                     ; return to input to get more input
000047C2                          4513  
000047C2  7803                    4514  MOVE_B_M3   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000047C4  4EB9 000048B0           4515              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000047CA  4EB9 00004B38           4516              JSR     PrintMove
000047D0  4EB9 00004BD8           4517              JSR     LengthB
000047D6  4EB9 00004C10           4518              JSR     PrintSpace
000047DC  4EB9 00004A50           4519              JSR     PrintPostIncAddrReg
000047E2                          4520  
000047E2  12EE 0025               4521              MOVE.B  37(A6),(A1)+             *,
000047E6  4EB8 43AA               4522              JSR CheckDest
000047EA  4E75                    4523              RTS                     ; return to input to get more input
000047EC                          4524  
000047EC  7803                    4525  MOVE_B_M4   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
000047EE  4EB9 000048B0           4526              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
000047F4  4EB9 00004B38           4527              JSR     PrintMove
000047FA  4EB9 00004BD8           4528              JSR     LengthB
00004800  4EB9 00004C10           4529              JSR     PrintSpace
00004806  4EB9 00004A5A           4530              JSR     PrintPreDeincAddrReg
0000480C                          4531  
0000480C  12EE 0025               4532              MOVE.B  37(A6),(A1)+             *,
00004810  4EB8 43AA               4533              JSR CheckDest
00004814  4E75                    4534              RTS                     ; return to input to get more input
00004816                          4535  
00004816  7803                    4536  MOVE_B_M7   MOVE.L  #3,D4          ; get the next 3 bit from (A4)(position 2-0) in to D5
00004818  4EB9 000048B0           4537              JSR     GetNextD4bit   ; D5 hold the next 3 bit of (A4), which tell us the source register
0000481E                          4538  
0000481E  BABC 00000000           4539              CMP.L   #0,D5          ; if position 2-0 is 0 the EA is (xxx).W
00004824  6700 001C               4540              BEQ     MOVE_B_xxxW
00004828                          4541  
00004828  BABC 00000001           4542              CMP.L   #1,D5          ; if position 2-0 is 1 the EA is (xxx).L
0000482E  6700 0034               4543              BEQ     MOVE_B_xxxL
00004832                          4544  
00004832  BABC 00000004           4545              CMP.L   #4,D5          ; if position 2-0 is 4 the EA is #<data>
00004838  6700 004C               4546              BEQ     MOVE_B_data
0000483C                          4547  
0000483C  4EF9 000048A8           4548              JMP     InvalidOpcode  ; for mode 7 if Source register is not 0 or 1 or 4, it is not a vaid NOT EA mode
00004842                          4549  
00004842  4EB9 00004B38           4550  MOVE_B_xxxW JSR     PrintMove
00004848  4EB9 00004BD8           4551              JSR     LengthB
0000484E  4EB9 00004C10           4552              JSR     PrintSpace
00004854  4EB9 000049AA           4553              JSR     PrintByteOrWord
0000485A                          4554  
0000485A  12EE 0025               4555              MOVE.B  37(A6),(A1)+             *,
0000485E  4EB8 43AA               4556              JSR CheckDest
00004862  4E75                    4557              RTS                     ; return to input to get more input
00004864                          4558  
00004864  4EB9 00004B38           4559  MOVE_B_xxxL JSR     PrintMove
0000486A  4EB9 00004BD8           4560              JSR     LengthB
00004870  4EB9 00004C10           4561              JSR     PrintSpace
00004876  4EB9 000049AA           4562              JSR     PrintByteOrWord
0000487C                          4563  
0000487C  12EE 0025               4564              MOVE.B  37(A6),(A1)+             *,
00004880  4EB8 43AA               4565              JSR CheckDest
00004884  4E75                    4566              RTS                     ; return to input to get more input
00004886                          4567  
00004886  4EB9 00004B38           4568  MOVE_B_data JSR     PrintMove
0000488C  4EB9 00004BD8           4569              JSR     LengthB
00004892  4EB9 00004C10           4570              JSR     PrintSpace
00004898  4EB9 0000499E           4571              JSR     PrintImmediateData
0000489E                          4572  
0000489E  12EE 0025               4573              MOVE.B  37(A6),(A1)+             *,
000048A2  4EB8 43AA               4574              JSR CheckDest
000048A6  4E75                    4575              RTS                     ; return to input to get more input
000048A8                          4576  
000048A8                          4577  
000048A8                          4578  *************************************************                Invalid Handle          *************************************************
000048A8                          4579  
000048A8                          4580  InvalidOpcode  ; don't use JSR to get here. Use JMP. If use JSR, RTS will not go back to input
000048A8  4EB9 000049E8           4581              JSR     NotFound        ; Call Output NotFound subroutine to print, since it did not match with any posible opcode
000048AE  4E75                    4582              RTS                     ; Return to input to get more input
000048B0                          4583  
000048B0                          4584  *************************************************                Subroutine             *************************************************
000048B0                          4585  
000048B0                          4586  GetNextD4bit ; Subroutine for get the next (D4) bit from (A4) into D5
000048B0                          4587               ; D4 should contain the number of loop you want to do
000048B0  7600                    4588              MOVE.L  #0,D3          ; initialize D3 to 0
000048B2  7A00                    4589              MOVE.L  #0,D5          ; initialize D5 to 0, for storing result of bit from (A4)
000048B4                          4590  
000048B4  B803                    4591  LOOP        CMP.B   D3,D4          ; for number of iterations
000048B6  6700 0012               4592              BEQ     next_code      ; if equal to each other, move on to next
000048BA  5283                    4593              ADDQ.L  #1,D3          ; D3++, increment D3
000048BC                          4594  
000048BC  E38D                    4595              LSL.L   #1,D5          ; Shift left one
000048BE                          4596  
000048BE  E34A                    4597              LSL.W   #1,D2          ; shift left one
000048C0  6500 0004               4598              BCS     ADD1           ; If there is a carry bit add one to D5
000048C4  60EE                    4599              BRA     LOOP
000048C6                          4600  
000048C6  5285                    4601  ADD1        ADDQ.L  #1,D5          ; add 1 to D5
000048C8  60EA                    4602              BRA     LOOP           ; The goal is for D5 to hold the same bit as the first 4 bit of A4
000048CA                          4603  
000048CA  4E75                    4604  next_code   RTS         ; return from subroutine
000048CC                          4605  
000048CC                          4606  *-----------------------------------------------------------
000048CC                          4607  * Title      : Output
000048CC                          4608  * Written by :
000048CC                          4609  * Date       :
000048CC                          4610  * Description: output data
000048CC                          4611  *-----------------------------------------------------------
000048CC                          4612  *******     Using A6 for a list of alphabetical characters              ********
000048CC                          4613  
000048CC                          4614  Print
000048CC  12BC 0000               4615      MOVE.B   #$00,(A1)               *Terminator for trap 14 - "hey! stop printing!"
000048D0  2279 00004EA0           4616      MOVE.L   PrintPointer,A1
000048D6  103C 000E               4617      MOVE.B   #14,D0
000048DA  4E4F                    4618      TRAP     #15
000048DC  4E75                    4619      RTS
000048DE                          4620  
000048DE                          4621  PrintLine
000048DE  12BC 0000               4622      MOVE.B   #$00,(A1)               *Terminator for trap 13 - "hey! stop printing!"
000048E2  5239 00004EA4           4623      ADD.B    #1,PrintLines
000048E8  1039 00004EA4           4624      MOVE.B   PrintLines,D0
000048EE  6000 0002               4625      BRA      TestWaited
000048F2                          4626  
000048F2                          4627  TestWaited
000048F2  0400 001E               4628      SUB.B    #30,D0
000048F6  B03C 0000               4629      CMP.B    #0,D0
000048FA  6700 0008               4630      BEQ      WaitMore
000048FE  6D00 001A               4631      BLT      GoAheadAndPrint
00004902  6EEE                    4632      BGT      TestWaited
00004904                          4633  
00004904                          4634  WaitMore
00004904  43F9 00004E2A           4635      LEA      WaitForMore,A1
0000490A  103C 000E               4636      MOVE.B   #14,D0
0000490E  4E4F                    4637      TRAP     #15
00004910  103C 0005               4638      MOVE.B   #5,D0
00004914  4E4F                    4639      TRAP     #15
00004916  6000 0002               4640      BRA      GoAheadAndPrint
0000491A                          4641  
0000491A                          4642  GoAheadAndPrint
0000491A  2279 00004EA0           4643      MOVE.L   PrintPointer,A1
00004920  103C 000D               4644      MOVE.B   #13,D0
00004924  4E4F                    4645      TRAP     #15
00004926  4E75                    4646      RTS
00004928                          4647  
00004928                          4648  ** Address
00004928                          4649  PrintAddr
00004928  2C0C                    4650      MOVE.L   A4,D6
0000492A  12EE 0000               4651      MOVE.B   0(A6),(A1)+             *68K always has address of 00XXXXXX, so we print 2 zeros
0000492E  12EE 0000               4652      MOVE.B   0(A6),(A1)+
00004932                          4653  
00004932  4EB9 000049E0           4654      JSR      RightTwenty             *3rd digit
00004938  12F6 6000               4655      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
0000493C  2C0C                    4656      MOVE.L   A4,D6                   *Re-set the address
0000493E                          4657  
0000493E  E18E                    4658      LSL.L    #8,D6                   *4th digit
00004940  E98E                    4659      LSL.L    #4,D6
00004942  4EB9 000049D6           4660      JSR      RightTwentyEight
00004948  12F6 6000               4661      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
0000494C  2C0C                    4662      MOVE.L   A4,D6                   *Re-set the address
0000494E                          4663  
0000494E  E18E                    4664      LSL.L    #8,D6                   *5th digit
00004950  E18E                    4665      LSL.L    #8,D6
00004952  4EB9 000049D6           4666      JSR      RightTwentyEight
00004958  12F6 6000               4667      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
0000495C  2C0C                    4668      MOVE.L   A4,D6                   *Re-set the address
0000495E                          4669  
0000495E  E18E                    4670      LSL.L    #8,D6                   *6th digit
00004960  E18E                    4671      LSL.L    #8,D6
00004962  E98E                    4672      LSL.L    #4,D6
00004964  4EB9 000049D6           4673      JSR      RightTwentyEight
0000496A  12F6 6000               4674      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
0000496E  2C0C                    4675      MOVE.L   A4,D6                   *Re-set the address
00004970                          4676  
00004970  E18E                    4677      LSL.L    #8,D6                   *7th digit
00004972  E18E                    4678      LSL.L    #8,D6
00004974  E18E                    4679      LSL.L    #8,D6
00004976  4EB9 000049D6           4680      JSR      RightTwentyEight
0000497C  12F6 6000               4681      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
00004980  2C0C                    4682      MOVE.L   A4,D6                   *Re-set the address
00004982                          4683  
00004982  E18E                    4684      LSL.L    #8,D6                   *8th digit
00004984  E18E                    4685      LSL.L    #8,D6
00004986  E18E                    4686      LSL.L    #8,D6
00004988  E98E                    4687      LSL.L    #4,D6
0000498A  4EB9 000049D6           4688      JSR      RightTwentyEight
00004990  12F6 6000               4689      MOVE.B   (A6,D6),(A1)+           *Move ascii to print
00004994                          4690  
00004994  4EB9 00004BF6           4691      JSR      PrintTab                *Add tab
0000499A  4286                    4692      CLR.L    D6
0000499C  4E75                    4693      RTS
0000499E                          4694  
0000499E                          4695  PrintImmediateData
0000499E  12EE 0029               4696              MOVE.B  41(A6),(A1)+             *#
000049A2  4EB9 000049C0           4697              JSR     PrintLong
000049A8  4E75                    4698              RTS
000049AA                          4699  
000049AA                          4700  PrintByteOrWord
000049AA  12EE 0026               4701      MOVE.B   38(A6),(A1)+        *$
000049AE  4EB8 48CC               4702              JSR     Print
000049B2                          4703  
000049B2  321C                    4704              MOVE.W  (A4)+,D1
000049B4  143C 0010               4705              MOVE.B  #16,D2
000049B8  103C 000F               4706              MOVE.B  #15,D0
000049BC  4E4F                    4707              TRAP    #15
000049BE  4E75                    4708              RTS
000049C0                          4709  
000049C0                          4710  PrintLong
000049C0  12EE 0026               4711      MOVE.B   38(A6),(A1)+        *$
000049C4  4EB8 48CC               4712              JSR     Print
000049C8                          4713  
000049C8  321C                    4714              MOVE.W  (A4)+,D1
000049CA  143C 0010               4715              MOVE.B  #16,D2
000049CE  103C 000F               4716              MOVE.B  #15,D0
000049D2  4E4F                    4717              TRAP    #15
000049D4  4E75                    4718              RTS
000049D6                          4719  
000049D6                          4720  RightTwentyEight
000049D6  E08E                    4721      LSR.L    #8,D6
000049D8  4EB9 000049E0           4722      JSR      RightTwenty
000049DE  4E75                    4723      RTS
000049E0                          4724  
000049E0                          4725  RightTwenty
000049E0  E08E                    4726      LSR.L    #8,D6
000049E2  E08E                    4727      LSR.L    #8,D6
000049E4  E88E                    4728      LSR.L    #4,D6
000049E6  4E75                    4729      RTS
000049E8                          4730  
000049E8                          4731  ** General
000049E8                          4732  NotFound
000049E8  12EE 000D               4733      MOVE.B   13(A6),(A1)+        *D
000049EC  12EE 000A               4734      MOVE.B   10(A6),(A1)+        *A
000049F0  12EE 001D               4735      MOVE.B   29(A6),(A1)+        *T
000049F4  12EE 000A               4736      MOVE.B   10(A6),(A1)+        *A
000049F8  4EB9 00004BF6           4737              JSR      PrintTab
000049FE  12EE 0026               4738      MOVE.B   38(A6),(A1)+        *$
00004A02                          4739  
00004A02  13E4 00004EA8           4740              MOVE.B   -(A4),CurDecode         ; Print out the next 16 bits (the opcode that couldn't be decoded)
00004A08  103C 0010               4741              MOVE.B   #16,D0
00004A0C  6000 0002               4742              BRA      PrintBits
00004A10                          4743  
00004A10                          4744  PrintBits
00004A10  B03C 0000               4745              CMP.B   #0,D0
00004A14  6700 0010               4746              BEQ     PBDone
00004A18  7801                    4747              MOVE.L  #1,D4                    ;Get 1 bit from A4
00004A1A  4EB8 48B0               4748              JSR     GetNextD4bit             ;Store in D5
00004A1E                          4749  
00004A1E  12F6 5000               4750              MOVE.B  (A6,D5),(A1)+            ;Put into print queue
00004A22                          4751  
00004A22  5300                    4752              SUB.B   #1,D0                    ;Sub 1, do 8 times?
00004A24                          4753  
00004A24  60EA                    4754              BRA     PrintBits
00004A26                          4755  
00004A26                          4756  PBDone
00004A26  101C                    4757              MOVE.B  (A4)+,D0
00004A28  4E75                    4758              RTS
00004A2A                          4759  
00004A2A                          4760  PrintDataReg
00004A2A  12EE 000D               4761      MOVE.B   13(A6),(A1)+        *D
00004A2E  4EB9 00004A64           4762      JSR      PrintRegNum
00004A34  4E75                    4763      RTS
00004A36                          4764  
00004A36                          4765  PrintAddrReg
00004A36  12EE 000A               4766      MOVE.B   10(A6),(A1)+        *A
00004A3A  4EB9 00004A64           4767      JSR      PrintRegNum
00004A40  4E75                    4768      RTS
00004A42                          4769  
00004A42                          4770  PrintIndirAddrReg
00004A42  12EE 0027               4771              MOVE.B  39(A6),(A1)+             *(
00004A46  4EB8 4A36               4772              JSR     PrintAddrReg             *Ax
00004A4A  12EE 0028               4773              MOVE.B  40(A6),(A1)+             *)
00004A4E  4E75                    4774              RTS
00004A50                          4775  
00004A50                          4776  PrintPostIncAddrReg
00004A50  4EB8 4A42               4777              JSR     PrintIndirAddrReg        *(Ax)
00004A54  12EE 002A               4778              MOVE.B  42(A6),(A1)+             *+
00004A58  4E75                    4779              RTS
00004A5A                          4780  
00004A5A                          4781  PrintPreDeincAddrReg
00004A5A  12EE 002B               4782              MOVE.B  43(A6),(A1)+             *-
00004A5E  4EB8 4A42               4783              JSR     PrintIndirAddrReg        *(Ax)
00004A62  4E75                    4784              RTS
00004A64                          4785  
00004A64                          4786  PrintRegNum
00004A64  12F6 5000               4787      MOVE.B   (A6,D5),(A1)+
00004A68  4E75                    4788      RTS
00004A6A                          4789  
00004A6A                          4790  ** OPCodes
00004A6A                          4791  PrintAdd
00004A6A  12EE 000A               4792      MOVE.B   10(A6),(A1)+        *A
00004A6E  12EE 000D               4793      MOVE.B   13(A6),(A1)+        *D
00004A72  12EE 000D               4794      MOVE.B   13(A6),(A1)+        *D
00004A76  4E75                    4795      RTS
00004A78                          4796  
00004A78                          4797  PrintAddA
00004A78  4EB8 4A6A               4798      JSR      PrintAdd            *ADD
00004A7C  12EE 000A               4799      MOVE.B   10(A6),(A1)+        *A
00004A80  4E75                    4800      RTS
00004A82                          4801  
00004A82                          4802  PrintAddQ
00004A82  4EB8 4A6A               4803      JSR      PrintAdd            *ADD
00004A86  12EE 001A               4804      MOVE.B   26(A6),(A1)+        *Q
00004A8A  4E75                    4805      RTS
00004A8C                          4806  
00004A8C                          4807  PrintAnd
00004A8C  12EE 000A               4808      MOVE.B   10(A6),(A1)+        *A
00004A90  12EE 0017               4809      MOVE.B   23(A6),(A1)+        *N
00004A94  12EE 000D               4810      MOVE.B   13(A6),(A1)+        *D
00004A98  4E75                    4811      RTS
00004A9A                          4812  
00004A9A                          4813  PrintASL
00004A9A  12EE 000A               4814      MOVE.B   10(A6),(A1)+        *A
00004A9E  12EE 001C               4815      MOVE.B   28(A6),(A1)+        *S
00004AA2  12EE 0015               4816      MOVE.B   21(A6),(A1)+        *L
00004AA6  4E75                    4817      RTS
00004AA8                          4818  
00004AA8                          4819  PrintASR
00004AA8  12EE 000A               4820      MOVE.B   10(A6),(A1)+        *A
00004AAC  12EE 001C               4821      MOVE.B   28(A6),(A1)+        *S
00004AB0  12EE 001B               4822      MOVE.B   27(A6),(A1)+        *R
00004AB4  4E75                    4823      RTS
00004AB6                          4824  
00004AB6                          4825  PrintBEQ
00004AB6  12EE 000B               4826      MOVE.B   11(A6),(A1)+        *B
00004ABA  12EE 000E               4827      MOVE.B   14(A6),(A1)+        *E
00004ABE  12EE 001A               4828      MOVE.B   26(A6),(A1)+        *Q
00004AC2  4E75                    4829      RTS
00004AC4                          4830  
00004AC4                          4831  PrintBGT
00004AC4  12EE 000B               4832      MOVE.B   11(A6),(A1)+        *B
00004AC8  12EE 0010               4833      MOVE.B   16(A6),(A1)+        *G
00004ACC  12EE 001D               4834      MOVE.B   29(A6),(A1)+        *T
00004AD0  4E75                    4835      RTS
00004AD2                          4836  
00004AD2                          4837  PrintBLE
00004AD2  12EE 000B               4838      MOVE.B   11(A6),(A1)+        *B
00004AD6  12EE 0015               4839      MOVE.B   21(A6),(A1)+        *L
00004ADA  12EE 000E               4840      MOVE.B   14(A6),(A1)+        *E
00004ADE  4E75                    4841      RTS
00004AE0                          4842  
00004AE0                          4843  PrintBRA
00004AE0  12EE 000B               4844      MOVE.B   11(A6),(A1)+        *B
00004AE4  12EE 001B               4845      MOVE.B   27(A6),(A1)+        *R
00004AE8  12EE 000A               4846      MOVE.B   10(A6),(A1)+        *A
00004AEC  4E75                    4847      RTS
00004AEE                          4848  
00004AEE                          4849  PrintDivu
00004AEE  12EE 000D               4850              MOVE.B   13(A6),(A1)+            *D
00004AF2  12EE 0012               4851              MOVE.B   18(A6),(A1)+            *I
00004AF6  12EE 001F               4852              MOVE.B   31(A6),(A1)+            *V
00004AFA  12EE 001E               4853              MOVE.B   30(A6),(A1)+            *U
00004AFE  4E75                    4854              RTS
00004B00                          4855  
00004B00                          4856  PrintJSR
00004B00  12EE 0013               4857      MOVE.B   19(A6),(A1)+        *J
00004B04  12EE 001C               4858      MOVE.B   28(A6),(A1)+        *S
00004B08  12EE 001B               4859      MOVE.B   27(A6),(A1)+        *R
00004B0C  4E75                    4860      RTS
00004B0E                          4861  
00004B0E                          4862  PrintLEA
00004B0E  12EE 0015               4863      MOVE.B   21(A6),(A1)+        *L
00004B12  12EE 000E               4864      MOVE.B   14(A6),(A1)+        *E
00004B16  12EE 000A               4865      MOVE.B   10(A6),(A1)+        *A
00004B1A  4E75                    4866      RTS
00004B1C                          4867  
00004B1C                          4868  PrintLSL
00004B1C  12EE 0015               4869      MOVE.B   21(A6),(A1)+        *L
00004B20  12EE 001C               4870      MOVE.B   28(A6),(A1)+        *S
00004B24  12EE 0015               4871      MOVE.B   21(A6),(A1)+        *L
00004B28  4E75                    4872      RTS
00004B2A                          4873  
00004B2A                          4874  PrintLSR
00004B2A  12EE 0015               4875      MOVE.B   21(A6),(A1)+        *L
00004B2E  12EE 001C               4876      MOVE.B   28(A6),(A1)+        *S
00004B32  12EE 001B               4877      MOVE.B   27(A6),(A1)+        *R
00004B36  4E75                    4878      RTS
00004B38                          4879  
00004B38                          4880  PrintMove
00004B38  12EE 0016               4881      MOVE.B   22(A6),(A1)+        *M
00004B3C  12EE 0018               4882      MOVE.B   24(A6),(A1)+        *O
00004B40  12EE 001F               4883      MOVE.B   31(A6),(A1)+        *V
00004B44  12EE 000E               4884      MOVE.B   14(A6),(A1)+        *E
00004B48  4E75                    4885      RTS
00004B4A                          4886  
00004B4A                          4887  PrintMoveA
00004B4A  4EB8 4B38               4888      JSR      PrintMove           *MOVE
00004B4E  12EE 000A               4889      MOVE.B   10(A6),(A1)+        *A
00004B52  4E75                    4890      RTS
00004B54                          4891  
00004B54                          4892  PrintMoveQ
00004B54  4EB8 4B38               4893      JSR      PrintMove           *MOVE
00004B58  12EE 001A               4894      MOVE.B   26(A6),(A1)+        *Q
00004B5C  4E75                    4895      RTS
00004B5E                          4896  
00004B5E                          4897  PrintMoveM
00004B5E  4EB8 4B38               4898      JSR      PrintMove           *MOVE
00004B62  12EE 0016               4899      MOVE.B   22(A6),(A1)+        *M
00004B66  4E75                    4900      RTS
00004B68                          4901  
00004B68                          4902  PrintMuls
00004B68  12EE 0016               4903              MOVE.B  22(A6),(A1)+             *M
00004B6C  12EE 001E               4904              MOVE.B  30(A6),(A1)+             *U
00004B70  12EE 0015               4905              MOVE.B  21(A6),(A1)+             *L
00004B74  12EE 001C               4906              MOVE.B  28(A6),(A1)+             *S
00004B78  4E75                    4907              RTS
00004B7A                          4908  
00004B7A                          4909  PrintNOP
00004B7A  12EE 0017               4910      MOVE.B   23(A6),(A1)+        *N
00004B7E  12EE 0018               4911      MOVE.B   24(A6),(A1)+        *O
00004B82  12EE 0019               4912      MOVE.B   25(A6),(A1)+        *P
00004B86  4E75                    4913      RTS
00004B88                          4914  
00004B88                          4915  PrintNot
00004B88  12EE 0017               4916      MOVE.B   23(A6),(A1)+         *N
00004B8C  12EE 0018               4917      MOVE.B   24(A6),(A1)+         *O
00004B90  12EE 001D               4918      MOVE.B   29(A6),(A1)+         *T
00004B94  4E75                    4919      RTS
00004B96                          4920  
00004B96                          4921  PrintOr
00004B96  12EE 0018               4922      MOVE.B   24(A6),(A1)+        *O
00004B9A  12EE 001B               4923      MOVE.B   27(A6),(A1)+        *R
00004B9E  4E75                    4924      RTS
00004BA0                          4925  
00004BA0                          4926  PrintROL
00004BA0  12EE 001B               4927      MOVE.B   27(A6),(A1)+        *R
00004BA4  12EE 0018               4928      MOVE.B   24(A6),(A1)+        *O
00004BA8  12EE 0015               4929      MOVE.B   21(A6),(A1)+        *L
00004BAC  4E75                    4930      RTS
00004BAE                          4931  
00004BAE                          4932  PrintROR
00004BAE  12EE 001B               4933      MOVE.B   27(A6),(A1)+        *R
00004BB2  12EE 0018               4934      MOVE.B   24(A6),(A1)+        *O
00004BB6  12EE 001B               4935      MOVE.B   27(A6),(A1)+        *R
00004BBA  4E75                    4936      RTS
00004BBC                          4937  
00004BBC                          4938  PrintRTS
00004BBC  12EE 001B               4939      MOVE.B   27(A6),(A1)+        *R
00004BC0  12EE 001D               4940      MOVE.B   29(A6),(A1)+        *T
00004BC4  12EE 001C               4941      MOVE.B   28(A6),(A1)+        *S
00004BC8  4E75                    4942      RTS
00004BCA                          4943  
00004BCA                          4944  PrintSub
00004BCA  12EE 001C               4945      MOVE.B   28(A6),(A1)+        *S
00004BCE  12EE 001E               4946      MOVE.B   30(A6),(A1)+        *U
00004BD2  12EE 000B               4947      MOVE.B   11(A6),(A1)+        *B
00004BD6  4E75                    4948      RTS
00004BD8                          4949  
00004BD8                          4950  ** Sizes
00004BD8                          4951  LengthB                          *Prints .B
00004BD8  12EE 0024               4952      MOVE.B   36(A6),(A1)+        *.
00004BDC  12EE 000B               4953      MOVE.B   11(A6),(A1)+        *B
00004BE0  4E75                    4954      RTS
00004BE2                          4955  
00004BE2                          4956  LengthW                          *Prints .W
00004BE2  12EE 0024               4957      MOVE.B   36(A6),(A1)+        *.
00004BE6  12EE 0020               4958      MOVE.B   32(A6),(A1)+        *W
00004BEA  4E75                    4959      RTS
00004BEC                          4960  
00004BEC                          4961  LengthL                          *Prints .L
00004BEC  12EE 0024               4962      MOVE.B   36(A6),(A1)+        *.
00004BF0  12EE 0015               4963      MOVE.B   21(A6),(A1)+        *L
00004BF4  4E75                    4964      RTS
00004BF6                          4965  
00004BF6                          4966  ** Other
00004BF6                          4967  PrintTab
00004BF6  4EB9 00004C10           4968      JSR      PrintSpace
00004BFC  4EB9 00004C10           4969      JSR      PrintSpace
00004C02  4EB9 00004C10           4970      JSR      PrintSpace
00004C08  4EB9 00004C10           4971      JSR      PrintSpace
00004C0E  4E75                    4972      RTS
00004C10                          4973  
00004C10                          4974  PrintSpace
00004C10  12EE 002C               4975      MOVE.B   44(A6),(A1)+
00004C14  4E75                    4976      RTS
00004C16                          4977  
00004C16  FFFF FFFF               4978      SIMHALT             ; halt simulator
00004C1A                          4979  
00004C1A                          4980  * Put variables and constants here
00004C1A  =0000000D               4981  CR           EQU     $0D
00004C1A  =0000000A               4982  LF           EQU     $0A
00004C1A                          4983  
00004C1A                          4984  ;EmptyChar    DC.W    '', 0
00004C1A                          4985  ;SpaceChar    DC.W ' ', 0
00004C1A                          4986  
00004C1A  =00000500               4987  EndAddr      EQU     $500                        ; store end address, avoid overwriting
00004C1A  =00000600               4988  StartAddr    EQU     $600                        ; store start address, avoid overwriting
00004C1A  =00000400               4989  Cur4bits     EQU     $400                        ; store first four bits
00004C1A                          4990  
00004C1A                          4991  * introduction message
00004C1A= 2A 2A 2A 2A 2A 2A ...   4992  IntroMsg     DC.B    '**************************************************************',CR,LF
00004C5A= 2A 20 20 54 45 41 ...   4993               DC.B    '*  TEAM 9 DISASSEMBLER',CR,LF,CR,LF
00004C74= 2A 20 20 4D 65 6D ...   4994               DC.B    '*  Members: MARIANA HUYNH, HANNY LONG, ALEX VAN MATRE',CR,LF,CR,LF
00004CAD= 2A 2A 2A 2A 2A 2A ...   4995               DC.B    '*************************************************************',CR,LF,CR,LF,0
00004CEF                          4996  
00004CEF= 45 6E 74 65 72 20 ...   4997  AskStartAddr DC.B 'Enter starting address in hexadecimal:', CR, LF, 0
00004D18                          4998  
00004D18= 45 6E 74 65 72 20 ...   4999  AskEndAddr   DC.B 'Enter ending address in hexadecimal:', CR, LF, 0
00004D3F                          5000  
00004D3F= 45 6E 74 65 72 20 ...   5001  AskRestartOrExitMsg DC.B 'Enter 0 to exit program or 1 to restart the program: ', 0
00004D75                          5002  
00004D75                          5003  * Error message
00004D75= 49 6E 76 61 6C 69 ...   5004  InvalidStartMessage  DC.B 'Invalid Start Address: input not valid hex value', CR, LF, 0
00004DA8= 49 6E 76 61 6C 69 ...   5005  InvalidEndMessage  DC.B 'Invalid End Address: input not valid hex value or End <= Start', CR, LF, 0
00004DE9                          5006  
00004DE9                          5007  
00004DE9                          5008  * Hex Srting Numbers
00004DEA= 3000 0000               5009  Str0                       DC.W '0', 0
00004DEE= 3100 0000               5010  Str1                       DC.W '1', 0
00004DF2= 3200 0000               5011  Str2                       DC.W '2', 0
00004DF6= 3300 0000               5012  Str3                       DC.W '3', 0
00004DFA= 3400 0000               5013  Str4                       DC.W '4', 0
00004DFE= 3500 0000               5014  Str5                       DC.W '5', 0
00004E02= 3600 0000               5015  Str6                       DC.W '6', 0
00004E06= 3700 0000               5016  Str7                       DC.W '7', 0
00004E0A= 3800 0000               5017  Str8                       DC.W '8', 0
00004E0E= 3900 0000               5018  Str9                       DC.W '9', 0
00004E12                          5019  
00004E12                          5020  * Hex String Letters
00004E12= 4100 0000               5021  StrA                       DC.W 'A', 0
00004E16= 4200 0000               5022  StrB                       DC.W 'B', 0
00004E1A= 4300 0000               5023  StrC                       DC.W 'C', 0
00004E1E= 4400 0000               5024  StrD                       DC.W 'D', 0
00004E22= 4500 0000               5025  StrE                       DC.W 'E', 0
00004E26= 4600 0000               5026  StrF                       DC.W 'F', 0
00004E2A                          5027  
00004E2A                          5028  
00004E2A= 4D 61 78 20 6E 75 ...   5029  WaitForMore     DC.B   'Max number of lines on screen. Press enter to continue dissassembling', CR, LF, 0
00004E72= 30 31 32 33 34 35 ...   5030  Values          DC.B   '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','.',',','$','(',')','#','+','-',' '
00004E9F                          5031  *                       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44
00004EA0= 00003500                5032  PrintPointer    DC.L   $3500
00004EA4= 00004500                5033  PrintLines      DC.L   $4500
00004EA8= 00005500                5034  CurDecode   DC.L   $5500
00004EAC                          5035  
00004EAC                          5036                END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD1                48C6
ADD_B_DESEA         1C3E
ADD_B_DESEA_M2      1C74
ADD_B_DESEA_M3      1CA6
ADD_B_DESEA_M4      1CD4
ADD_B_DESEA_M7      1D06
ADD_B_DESEA_XXXL    1D52
ADD_B_DESEA_XXXW    1D28
ADD_B_SRCEA         16D4
ADD_B_SRCEA_DATA    187C
ADD_B_SRCEA_M0      171E
ADD_B_SRCEA_M1      174C
ADD_B_SRCEA_M2      177A
ADD_B_SRCEA_M3      17A8
ADD_B_SRCEA_M4      17D6
ADD_B_SRCEA_M7      1804
ADD_B_SRCEA_XXXL    1856
ADD_B_SRCEA_XXXW    1830
ADD_L_DESEA         1EBA
ADD_L_DESEA_M2      1EF0
ADD_L_DESEA_M3      1F22
ADD_L_DESEA_M4      1F50
ADD_L_DESEA_M7      1F82
ADD_L_DESEA_XXXL    1FCE
ADD_L_DESEA_XXXW    1FA4
ADD_L_SRCEA         1A70
ADD_L_SRCEA_DATA    1C18
ADD_L_SRCEA_M0      1ABA
ADD_L_SRCEA_M1      1AE8
ADD_L_SRCEA_M2      1B16
ADD_L_SRCEA_M3      1B44
ADD_L_SRCEA_M4      1B72
ADD_L_SRCEA_M7      1BA0
ADD_L_SRCEA_XXXL    1BF2
ADD_L_SRCEA_XXXW    1BCC
ADD_OPCODE          1680
ADD_W_DESEA         1D7C
ADD_W_DESEA_M2      1DB2
ADD_W_DESEA_M3      1DE4
ADD_W_DESEA_M4      1E12
ADD_W_DESEA_M7      1E44
ADD_W_DESEA_XXXL    1E90
ADD_W_DESEA_XXXW    1E66
ADD_W_SRCEA         18A2
ADD_W_SRCEA_DATA    1A4A
ADD_W_SRCEA_M0      18EC
ADD_W_SRCEA_M1      191A
ADD_W_SRCEA_M2      1948
ADD_W_SRCEA_M3      1976
ADD_W_SRCEA_M4      19A4
ADD_W_SRCEA_M7      19D2
ADD_W_SRCEA_XXXL    1A24
ADD_W_SRCEA_XXXW    19FE
AND_B_DESEA         2518
AND_B_DESEA_M2      254E
AND_B_DESEA_M3      2580
AND_B_DESEA_M4      25B2
AND_B_DESEA_M7      25E4
AND_B_DESEA_XXXL    2630
AND_B_DESEA_XXXW    2606
AND_B_SRCEA         2056
AND_B_SRCEA_DATA    21C6
AND_B_SRCEA_M0      2096
AND_B_SRCEA_M2      20C4
AND_B_SRCEA_M3      20F2
AND_B_SRCEA_M4      2120
AND_B_SRCEA_M7      214E
AND_B_SRCEA_XXXL    21A0
AND_B_SRCEA_XXXW    217A
AND_L_DESEA         279C
AND_L_DESEA_M2      27D2
AND_L_DESEA_M3      2804
AND_L_DESEA_M4      2836
AND_L_DESEA_M7      2868
AND_L_DESEA_XXXL    28B4
AND_L_DESEA_XXXW    288A
AND_L_SRCEA         2382
AND_L_SRCEA_DATA    24F2
AND_L_SRCEA_M0      23C2
AND_L_SRCEA_M2      23F0
AND_L_SRCEA_M3      241E
AND_L_SRCEA_M4      244C
AND_L_SRCEA_M7      247A
AND_L_SRCEA_XXXL    24CC
AND_L_SRCEA_XXXW    24A6
AND_W_DESEA         265A
AND_W_DESEA_M2      2690
AND_W_DESEA_M3      26C2
AND_W_DESEA_M4      26F4
AND_W_DESEA_M7      2726
AND_W_DESEA_XXXL    2772
AND_W_DESEA_XXXW    2748
AND_W_SRCEA         21EC
AND_W_SRCEA_DATA    235C
AND_W_SRCEA_M0      222C
AND_W_SRCEA_M2      225A
AND_W_SRCEA_M3      2288
AND_W_SRCEA_M4      22B6
AND_W_SRCEA_M7      22E4
AND_W_SRCEA_XXXL    2336
AND_W_SRCEA_XXXW    2310
ASCIITOHEX          1088
ASKENDADDR          4D18
ASKEXITORRESTART    11A4
ASKRESTARTOREXITMSG  4D3F
ASKSTARTADDR        4CEF
ASL_COUNT_OPCODE    130C
ASL_MEMSHIFT        158E
ASL_MEMSHIFT_MODE_2  15C4
ASL_MEMSHIFT_MODE_3  15E6
ASL_MEMSHIFT_MODE_4  1608
ASL_MEMSHIFT_MODE_7  162A
ASL_MEMSHIFT_XXXL   1666
ASL_MEMSHIFT_XXXW   164C
ASL_OUTPUT_BYTE     1360
ASL_OUTPUT_LONG     1388
ASL_OUTPUT_SIZE     133C
ASL_OUTPUT_WORD     1374
ASL_REGISTER_OPCODE  143C
BCC_16BIT_DISP      3642
BCC_32BIT_DISP      364C
BCC_DISPLACEMENT    3624
BCC_OPCODE          35BE
BEQ_OPCODE          3618
BGT_OPCODE          35F4
BLE_OPCODE          3600
BRA_OPCODE          360C
CHECKCOUNT          142C
CHECKDEST           43AA
CLEAREVERYTHING     11C8
CONTINUE_MOVE_B     46F2
CONTINUE_MOVE_L     4502
CONTINUE_MOVE_W     427C
CONVERTFORLOOP      108E
CONVERTLOWERCASE    10D4
CONVERTNUM          10CA
CONVERTUPPERCASE    10DE
CR                  D
CUR4BITS            400
CURDECODE           4EA8
D0_TO_8             1438
DECODINGMACHINECODE  121E
DESTDN              43E8
DESTINDIRAN         43F2
DESTL               442E
DESTPOSTINCAN       43FC
DESTPREDEINCAN      4406
DESTW               4426
DESTWL              4410
DISPINVALIDENDERROR  1178
DISPINVALIDSTARTERROR  116A
DIVU_L              3CCA
DIVU_L_DATA         3E3A
DIVU_L_M0           3D0A
DIVU_L_M2           3D38
DIVU_L_M3           3D66
DIVU_L_M4           3D94
DIVU_L_M7           3DC2
DIVU_L_XXXL         3E14
DIVU_L_XXXW         3DEE
DIVU_W_DATA         3598
DIVU_W_M0           3468
DIVU_W_M2           3496
DIVU_W_M3           34C4
DIVU_W_M4           34F2
DIVU_W_M7           3520
DIVU_W_OPCODE       340C
DIVU_W_XXXL         3572
DIVU_W_XXXW         354C
ENDADDR             500
GETENDADDR          105E
GETNEXTD4BIT        48B0
GETSTARTADDR        1032
GOAHEADANDPRINT     491A
INTROMSG            4C1A
INVALIDADDRHANDLER  113A
INVALIDENDHANDLER   1158
INVALIDENDMESSAGE   4DA8
INVALIDOPCODE       48A8
INVALIDSTARTHANDLER  1146
INVALIDSTARTMESSAGE  4D75
JSR_M2              3E82
JSR_M7              3E9E
JSR_OPCODE          3E60
JSR_XXXL            3ED4
JSR_XXXW            3EC0
LEA_M2_OPCODE       36F8
LEA_M7_OPCODE       3720
LEA_OPCODE          36C2
LEA_XXXL_OPCODE     3762
LEA_XXXW_OPCODE     3742
LENGTHB             4BD8
LENGTHL             4BEC
LENGTHW             4BE2
LF                  A
LOADADDR            1126
LOOP                48B4
LSL_ASL_OPCODE      12A4
LSL_COUNT_OPCODE    139C
LSL_MEMSHIFT        1496
LSL_MEMSHIFT_MODE_2  14CC
LSL_MEMSHIFT_MODE_3  14EE
LSL_MEMSHIFT_MODE_4  1510
LSL_MEMSHIFT_MODE_7  1532
LSL_MEMSHIFT_XXXL   1574
LSL_MEMSHIFT_XXXW   1554
LSL_OUTPUT_BYTE     13F0
LSL_OUTPUT_LONG     1418
LSL_OUTPUT_SIZE     13CC
LSL_OUTPUT_WORD     1404
LSL_REGISTER_OPCODE  145C
MEMSHIFT            147C
MOVEM_M2R_L         3A4E
MOVEM_M2R_L_M2      3A7A
MOVEM_M2R_L_M4      3AA4
MOVEM_M2R_L_M7      3ACE
MOVEM_M2R_L_XXXL    3B12
MOVEM_M2R_L_XXXW    3AF0
MOVEM_M2R_W         3968
MOVEM_M2R_W_M2      3994
MOVEM_M2R_W_M4      39BE
MOVEM_M2R_W_M7      39E8
MOVEM_M2R_W_XXXL    3A2C
MOVEM_M2R_W_XXXW    3A0A
MOVEM_R2M_L         3882
MOVEM_R2M_L_M2      38AE
MOVEM_R2M_L_M4      38D8
MOVEM_R2M_L_M7      3902
MOVEM_R2M_L_XXXL    3946
MOVEM_R2M_L_XXXW    3924
MOVEM_R2M_W         379C
MOVEM_R2M_W_M2      37C8
MOVEM_R2M_W_M4      37F2
MOVEM_R2M_W_M7      381C
MOVEM_R2M_W_XXXL    3860
MOVEM_R2M_W_XXXW    383E
MOVE_B_DATA         4886
MOVE_B_DESM7_CHECK  4738
MOVE_B_M0           4744
MOVE_B_M1           476E
MOVE_B_M2           4798
MOVE_B_M3           47C2
MOVE_B_M4           47EC
MOVE_B_M7           4816
MOVE_B_OPCODE       46B8
MOVE_B_XXXL         4864
MOVE_B_XXXW         4842
MOVE_L_DATA         4696
MOVE_L_DESM7_CHECK  4548
MOVE_L_M0           4554
MOVE_L_M1           457E
MOVE_L_M2           45A8
MOVE_L_M3           45D2
MOVE_L_M4           45FC
MOVE_L_M7           4626
MOVE_L_OPCODE       44C8
MOVE_L_XXXL         4674
MOVE_L_XXXW         4652
MOVE_W_DATA         44A6
MOVE_W_DESM7_CHECK  42C2
MOVE_W_M0           42CE
MOVE_W_M1           42FA
MOVE_W_M2           4326
MOVE_W_M3           4352
MOVE_W_M4           437E
MOVE_W_M7           4436
MOVE_W_OPCODE       4242
MOVE_W_XXXL         4484
MOVE_W_XXXW         4462
MULS_L              3B34
MULS_L_DATA         3CA4
MULS_L_M0           3B74
MULS_L_M2           3BA2
MULS_L_M3           3BD0
MULS_L_M4           3BFE
MULS_L_M7           3C2C
MULS_L_XXXL         3C7E
MULS_L_XXXW         3C58
MULS_W              28DE
MULS_W_AND_OPCODE   1FF8
MULS_W_DATA         2A4E
MULS_W_M0           291E
MULS_W_M2           294C
MULS_W_M3           297A
MULS_W_M4           29A8
MULS_W_M7           29D6
MULS_W_XXXL         2A28
MULS_W_XXXW         2A02
NEEDMOREBIT         3656
NEXT_CODE           48CA
NOTFOUND            49E8
NOT_B_M0            3F28
NOT_B_M2            3F4A
NOT_B_M3            3F6C
NOT_B_M4            3F8E
NOT_B_M7            3FB0
NOT_B_OPCODE        3EE8
NOT_B_XXXL          3FEC
NOT_B_XXXW          3FD2
NOT_L_M0            4164
NOT_L_M2            4186
NOT_L_M3            41A8
NOT_L_M4            41CA
NOT_L_M7            41EC
NOT_L_OPCODE        4124
NOT_L_XXXL          4228
NOT_L_XXXW          420E
NOT_W_M0            4046
NOT_W_M2            4068
NOT_W_M3            408A
NOT_W_M4            40AC
NOT_W_M7            40CE
NOT_W_OPCODE        4006
NOT_W_XXXL          410A
NOT_W_XXXW          40F0
PBDONE              4A26
PRINT               48CC
PRINTADD            4A6A
PRINTADDA           4A78
PRINTADDQ           4A82
PRINTADDR           4928
PRINTADDRREG        4A36
PRINTAND            4A8C
PRINTASL            4A9A
PRINTASR            4AA8
PRINTBEQ            4AB6
PRINTBGT            4AC4
PRINTBITS           4A10
PRINTBLE            4AD2
PRINTBRA            4AE0
PRINTBYTEORWORD     49AA
PRINTDATAREG        4A2A
PRINTDIVU           4AEE
PRINTIMMEDIATEDATA  499E
PRINTINDIRADDRREG   4A42
PRINTJSR            4B00
PRINTLEA            4B0E
PRINTLINE           48DE
PRINTLINES          4EA4
PRINTLIST           3782
PRINTLONG           49C0
PRINTLSL            4B1C
PRINTLSR            4B2A
PRINTMOVE           4B38
PRINTMOVEA          4B4A
PRINTMOVEM          4B5E
PRINTMOVEQ          4B54
PRINTMULS           4B68
PRINTNOP            4B7A
PRINTNOT            4B88
PRINTOR             4B96
PRINTPOINTER        4EA0
PRINTPOSTINCADDRREG  4A50
PRINTPREDEINCADDRREG  4A5A
PRINTREGNUM         4A64
PRINTROL            4BA0
PRINTROR            4BAE
PRINTRTS            4BBC
PRINTSPACE          4C10
PRINTSUB            4BCA
PRINTTAB            4BF6
PUTENDTOMEMORY      111E
PUTSTARTTOMEMORY    1116
QUIT                1218
READNEXTLOOP        1188
READNEXTLOOPSTART   1186
RIGHTTWENTY         49E0
RIGHTTWENTYEIGHT    49D6
SAVESTART           10E8
START               1000
STARTADDR           600
STR0                4DEA
STR1                4DEE
STR2                4DF2
STR3                4DF6
STR4                4DFA
STR5                4DFE
STR6                4E02
STR7                4E06
STR8                4E0A
STR9                4E0E
STRA                4E12
STRB                4E16
STRC                4E1A
STRD                4E1E
STRE                4E22
STRF                4E26
SUB_B_DESEA         3032
SUB_B_DESEA_M2      3068
SUB_B_DESEA_M3      309A
SUB_B_DESEA_M4      30CC
SUB_B_DESEA_M7      30FE
SUB_B_DESEA_XXXL    3154
SUB_B_DESEA_XXXW    312A
SUB_B_SRCEA         2AC8
SUB_B_SRCEA_DATA    2C70
SUB_B_SRCEA_M0      2B12
SUB_B_SRCEA_M1      2B40
SUB_B_SRCEA_M2      2B6E
SUB_B_SRCEA_M3      2B9C
SUB_B_SRCEA_M4      2BCA
SUB_B_SRCEA_M7      2BF8
SUB_B_SRCEA_XXXL    2C4A
SUB_B_SRCEA_XXXW    2C24
SUB_L_DESEA         32CA
SUB_L_DESEA_M2      3300
SUB_L_DESEA_M3      3332
SUB_L_DESEA_M4      3364
SUB_L_DESEA_M7      3396
SUB_L_DESEA_XXXL    33E2
SUB_L_DESEA_XXXW    33B8
SUB_L_SRCEA         2E64
SUB_L_SRCEA_DATA    300C
SUB_L_SRCEA_M0      2EAE
SUB_L_SRCEA_M1      2EDC
SUB_L_SRCEA_M2      2F0A
SUB_L_SRCEA_M3      2F38
SUB_L_SRCEA_M4      2F66
SUB_L_SRCEA_M7      2F94
SUB_L_SRCEA_XXXL    2FE6
SUB_L_SRCEA_XXXW    2FC0
SUB_OPCODE          2A74
SUB_W_DESEA         317E
SUB_W_DESEA_M2      31B4
SUB_W_DESEA_M3      31E6
SUB_W_DESEA_M4      3218
SUB_W_DESEA_M7      324A
SUB_W_DESEA_XXXL    32A0
SUB_W_DESEA_XXXW    3276
SUB_W_SRCEA         2C96
SUB_W_SRCEA_DATA    2E3E
SUB_W_SRCEA_M0      2CE0
SUB_W_SRCEA_M1      2D0E
SUB_W_SRCEA_M2      2D3C
SUB_W_SRCEA_M3      2D6A
SUB_W_SRCEA_M4      2D98
SUB_W_SRCEA_M7      2DC6
SUB_W_SRCEA_XXXL    2E18
SUB_W_SRCEA_XXXW    2DF2
TESTWAITED          48F2
VALIDATEEND         10FE
VALUES              4E72
WAITFORMORE         4E2A
WAITMORE            4904
